var tipuesearch = {"pages":[{"text":"Lib_VTK_IO Lib_VTK_IO Lib_VTK_IO, VTK IO in pure Fortran (2003+) A KISS pure Fortran Library to IO data conforming the VTK standard Lib_VTK_IO is a pure Fortran library to write and read data conforming the VTK standard ; Lib_VTK_IO is Fortran 2003+ standard compliant; Lib_VTK_IO supports parallel architectures by means OpenMP and MPI paradigms; Lib_VTK_IO supports ascii , binary and base64 file formats; Lib_VTK_IO is a Free, Open Source Project. Table of Contents Main features Copyrights Documentation A Taste of Lib_VTK_IO Issues Compiler Support -brightgreen.svg) -brightgreen.svg) Main features VTK features Exporters Legacy standard Structured Points; Structured Grid; Unstructured Grid; Polydata; Rectilinear Grid; Field; XML standard serial dataset: Image Data; Polydata; Rectilinear Grid; Structured Grid; Unstructured Grid; parallel (partitioned) dataset: Image Data; Polydata; Rectilinear Grid; Structured Grid; Unstructured Grid; composite dataset: vtkMultiBlockDataSet. Importers The importers are under developing. Parallel Architectures Lib_VTK_IO can handle multiple concurrent files and it is \\b thread/processor-safe, meaning that it can be safely used into parallel architectures using OpenMP and/or MPI paradigms. Into section [[Parallel-benchmarks]] some more details can be found. Copyrights Lib_VTK_IO is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to Lib_VTK_IO is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the Lib_VTK_IO documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top A taste of Lib_VTK_IO Let us assume our aim being to save our pure Fortran data into a VTK structured grid file in binary XML form. This is simple as USE Lib_VTK_IO ... ! dataset dimensions integer , parameter :: nx1 = 0 , nx2 = 9 , ny1 = 0 , ny2 = 5 , nz1 = 0 , nz2 = 5 integer , parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) ! grid coordinates real , dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z ! variables associated at grid nodes real , dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v_R ! auxiliary variables integer :: E_IO ... E_IO = VTK_INI_XML ( output_format = 'binary' , filename = 'XML_STRG.vts' , mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'real scalar' , var = v_R ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML () E_IO = VTK_END_XML () Note that all Lib_VTK_IO functions return an error code ( E_IO ) that can be used for sophisticated error trapping algorithms. Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" Lib_VTK_IO "},{"text":"PVTK_XML interface definitions for Lib_VTK_IO. Source Code !< PVTK_XML interface definitions for Lib_VTK_IO. module Lib_VTK_IO_PVTK_XML !----------------------------------------------------------------------------------------------------------------------------------- !< PVTK_XML interface definitions for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: PVTK_INI_XML public :: PVTK_GEO_XML public :: PVTK_DAT_XML public :: PVTK_VAR_XML public :: PVTK_END_XML !----------------------------------------------------------------------------------------------------------------------------------- contains function PVTK_INI_XML ( filename , mesh_topology , tp , cf , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing parallel (partitioned) VTK-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< File name. character ( * ), intent ( IN ) :: mesh_topology !< Mesh topology. character ( * ), intent ( IN ) :: tp !< Type of geometry representation (Float32, Float64, ecc). integer ( I4P ), intent ( OUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ), intent ( IN ), optional :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ), optional :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ), optional :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ), optional :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ), optional :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ), optional :: nz2 !< Final node of z axis. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init call vtk_update ( act = 'add' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf vtk ( rf )% topology = trim ( mesh_topology ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ),& form = 'FORMATTED' , access = 'SEQUENTIAL' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' if ( endian == endianL ) then s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' endif write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = 2 select case ( trim ( vtk ( rf )% topology )) case ( 'PRectilinearGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' WholeExtent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\" GhostLevel=\"#\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PCoordinates>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\"/>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\"/>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\"/>' vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PCoordinates>' case ( 'PStructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' WholeExtent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\" GhostLevel=\"#\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PPoints>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\" NumberOfComponents=\"3\" Name=\"Points\"/>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PPoints>' case ( 'PUnstructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' GhostLevel=\"0\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PPoints>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\" NumberOfComponents=\"3\" Name=\"Points\"/>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PPoints>' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction PVTK_INI_XML function PVTK_GEO_XML ( source , cf , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving piece geometry source for parallel (partitioned) VTK-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: source !< Source file name containing the piece data. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ), intent ( IN ), optional :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ), optional :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ), optional :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ), optional :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ), optional :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ), optional :: nz2 !< Final node of z axis. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% topology ) case ( 'PRectilinearGrid' , 'PStructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\" Source=\"' // trim ( source ) // '\"/>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( 'PUnstructuredGrid' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Source=\"' // trim ( source ) // '\"/>' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction PVTK_GEO_XML function PVTK_DAT_XML ( var_location , var_block_action , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing/finalizing the saving of data associated to the mesh. !< !< Function that **must** be called before saving the data related to geometric mesh, this function initializes the !< saving of data variables indicating the *type* (node or cell centered) of variables that will be saved. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: var_location !< Location of saving variables: CELL or NODE centered. character ( * ), intent ( IN ) :: var_block_action !< Variables block action: OPEN or CLOSE block. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PCellData>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PCellData>' endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PPointData>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PPointData>' endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction PVTK_DAT_XML function PVTK_VAR_XML ( varname , tp , cf , Nc ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving variable associated to nodes or cells geometry. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: varname !< Variable name. character ( * ), intent ( IN ) :: tp !< Type of data representation (Float32, Float64, ecc). integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ), intent ( IN ), optional :: Nc !< Number of components of variable. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif if ( present ( Nc )) then s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"' // trim ( str (. true ., Nc )) // '\"/>' else s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<PDataArray type=\"' // trim ( tp ) // '\" Name=\"' // trim ( varname ) // '\"/>' endif write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction PVTK_VAR_XML function PVTK_END_XML ( cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for finalizing the parallel (partitioned) VTK-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( INOUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</' // trim ( vtk ( rf )% topology ) // '>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' close ( unit = vtk ( rf )% u , iostat = E_IO ) call vtk_update ( act = 'remove' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf return !--------------------------------------------------------------------------------------------------------------------------------- endfunction PVTK_END_XML endmodule Lib_VTK_IO_PVTK_XML","tags":"","loc":"sourcefile/lib_vtk_io_pvtk_xml.f90.html","title":"Lib_VTK_IO_PVTK_XML.f90 – Lib_VTK_IO"},{"text":"END_XML interface definition for Lib_VTK_IO. Source Code !< END_XML interface definition for Lib_VTK_IO. module Lib_VTK_IO_END_XML !----------------------------------------------------------------------------------------------------------------------------------- !< END_XML interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_END_XML !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_END_XML ( cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for finalizing the VTK-XML file. !< !<### Usage !<```fortran !< E_IO = VTK_END_XML() !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( INOUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( 2 ) :: var_type !< Varable type = R8,R4,I8,I4,I2,I1. real ( R8P ), allocatable :: v_R8 (:) !< R8 vector for IO in AppendData. real ( R4P ), allocatable :: v_R4 (:) !< R4 vector for IO in AppendData. integer ( I8P ), allocatable :: v_I8 (:) !< I8 vector for IO in AppendData. integer ( I4P ), allocatable :: v_I4 (:) !< I4 vector for IO in AppendData. integer ( I2P ), allocatable :: v_I2 (:) !< I2 vector for IO in AppendData. integer ( I1P ), allocatable :: v_I1 (:) !< I1 vector for IO in AppendData. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. #ifdef HUGE integer ( I8P ) :: N_v !< Vector dimension. integer ( I8P ) :: n1 !< Counter. #else integer ( I4P ) :: N_v !< Vector dimension. integer ( I4P ) :: n1 !< Counter. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</' // trim ( vtk ( rf )% topology ) // '>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' case ( raw , bin_app ) vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</' // trim ( vtk ( rf )% topology ) // '>' // end_rec if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<AppendedData encoding=\"raw\">' // end_rec else write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<AppendedData encoding=\"base64\">' // end_rec endif write ( unit = vtk ( rf )% u , iostat = E_IO ) '_' endfile ( unit = vtk ( rf )% ua , iostat = E_IO ) rewind ( unit = vtk ( rf )% ua , iostat = E_IO ) do read ( unit = vtk ( rf )% ua , iostat = E_IO , end = 100 ) vtk ( rf )% N_Byte , var_type , N_v select case ( var_type ) case ( 'R8' ) allocate ( v_R8 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_R8 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_R8 ( n1 ), n1 = 1 , N_v ) else call pack_data ( a1 = [ int ( vtk ( rf )% N_Byte , I4P )], a2 = v_R8 , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_R8 ) case ( 'R4' ) allocate ( v_R4 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_R4 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_R4 ( n1 ), n1 = 1 , N_v ) else call pack_data ( a1 = [ int ( vtk ( rf )% N_Byte , I4P )], a2 = v_R4 , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_R4 ) case ( 'I8' ) allocate ( v_I8 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_I8 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_I8 ( n1 ), n1 = 1 , N_v ) else call pack_data ( a1 = [ int ( vtk ( rf )% N_Byte , I4P )], a2 = v_I8 , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_I8 ) case ( 'I4' ) allocate ( v_I4 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_I4 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_I4 ( n1 ), n1 = 1 , N_v ) else Nvarp = size ( transfer ([ int ( vtk ( rf )% N_Byte , I4P ), v_I4 ], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( vtk ( rf )% N_Byte , I4P ), v_I4 ], varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_I4 ) case ( 'I2' ) allocate ( v_I2 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_I2 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_I2 ( n1 ), n1 = 1 , N_v ) else call pack_data ( a1 = [ int ( vtk ( rf )% N_Byte , I4P )], a2 = v_I2 , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_I2 ) case ( 'I1' ) allocate ( v_I1 ( 1 : N_v )) read ( unit = vtk ( rf )% ua , iostat = E_IO )( v_I1 ( n1 ), n1 = 1 , N_v ) if ( vtk ( rf )% f == raw ) then write ( unit = vtk ( rf )% u , iostat = E_IO ) int ( vtk ( rf )% N_Byte , I4P ),( v_I1 ( n1 ), n1 = 1 , N_v ) else call pack_data ( a1 = [ int ( vtk ( rf )% N_Byte , I4P )], a2 = v_I1 , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) var64 ; deallocate ( var64 ) endif deallocate ( v_I1 ) case default E_IO = 1 write ( stderr , '(A)' ) ' bad var_type = ' // var_type write ( stderr , '(A)' ) ' N_Byte = ' // trim ( str ( n = vtk ( rf )% N_Byte )) // ' N_v = ' // trim ( str ( n = N_v )) return endselect enddo 100 continue write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</AppendedData>' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) '</VTKFile>' // end_rec close ( unit = vtk ( rf )% ua , iostat = E_IO ) case ( binary ) vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</' // trim ( vtk ( rf )% topology ) // '>' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) '</VTKFile>' // end_rec endselect close ( unit = vtk ( rf )% u , iostat = E_IO ) call vtk_update ( act = 'remove' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END_XML endmodule Lib_VTK_IO_END_XML","tags":"","loc":"sourcefile/lib_vtk_io_end_xml.f90.html","title":"Lib_VTK_IO_END_XML.f90 – Lib_VTK_IO"},{"text":"GEO interface definition for Lib_VTK_IO. Source Code !< GEO interface definition for Lib_VTK_IO. module Lib_VTK_IO_GEO !----------------------------------------------------------------------------------------------------------------------------------- !< GEO interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_GEO !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTK_GEO !< Procedure for saving mesh with different topologies in VTK-legacy standard. !< !< VTK_GEO is an interface to 16 different functions, there are 2 functions for each of 4 different topologies actually supported: !< one function for mesh coordinates with R8P precision and one for mesh coordinates with R4P precision. !< !< @note This function must be called after VTK_INI. It saves the mesh geometry. The inputs that must be passed change depending !< on the topologies chosen. Not all VTK topologies have been implemented (*polydata* topologies are absent). !< !<### Examples of usage !< !<#### Structured points calling !<```fortran !< integer(I4P):: Nx,Ny,Nz !< real(I8P)::    X0,Y0,Z0,Dx,Dy,Dz !< ... !< E_IO=VTK_GEO(Nx,Ny,Nz,X0,Y0,Z0,Dx,Dy,Dz) !< ... !<``` !< !<#### Structured grid calling !<```fortran !< integer(I4P):: Nx,Ny,Nz,Nnodes !< real(R8P)::    X(1:Nnodes),Y(1:Nnodes),Z(1:Nnodes) !< ... !< E_IO=VTK_GEO(Nx,Ny,Nz,Nnodes,X,Y,Z) !< ... !<``` !< !<#### Rectilinear grid calling !<```fortran !< integer(I4P):: Nx,Ny,Nz !< real(R8P)::    X(1:Nx),Y(1:Ny),Z(1:Nz) !< ... !< E_IO=VTK_GEO(Nx,Ny,Nz,X,Y,Z) !< ... !<``` !< !<#### Unstructured grid calling !<```fortran !< integer(I4P):: NN !< real(R4P)::    X(1:NN),Y(1:NN),Z(1:NN) !< ... !< E_IO=VTK_GEO(NN,X,Y,Z) !< ... !<``` module procedure VTK_GEO_UNST_R8 , VTK_GEO_UNST_P_R8 , & ! real(R8P) UNSTRUCTURED_GRID, standard and packed API VTK_GEO_UNST_R4 , VTK_GEO_UNST_P_R4 , & ! real(R4P) UNSTRUCTURED_GRID, standard and packed API VTK_GEO_STRP_R8 , & ! real(R8P) STRUCTURED_POINTS VTK_GEO_STRP_R4 , & ! real(R4P) STRUCTURED_POINTS VTK_GEO_STRG_1DA_R8 , VTK_GEO_STRG_3DA_R8 , & ! real(R8P) STRUCTURED_GRID 1D/3D arrays VTK_GEO_STRG_1DAP_R8 , VTK_GEO_STRG_3DAP_R8 , & ! real(R8P) STRUCTURED_GRID 1D/3D arrays, packed API VTK_GEO_STRG_1DA_R4 , VTK_GEO_STRG_3DA_R4 , & ! real(R4P) STRUCTURED_GRID 1D/3D arrays VTK_GEO_STRG_1DAP_R4 , VTK_GEO_STRG_3DAP_R4 , & ! real(R4P) STRUCTURED_GRID 1D/3D arrays, packed API VTK_GEO_RECT_R8 , & ! real(R8P) RECTILINEAR_GRID VTK_GEO_RECT_R4 ! real(R4P) RECTILINEAR_GRID endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_GEO_STRP_R8 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_POINTS topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. real ( R8P ), intent ( IN ) :: X0 !< X coordinate of origin. real ( R8P ), intent ( IN ) :: Y0 !< Y coordinate of origin. real ( R8P ), intent ( IN ) :: Z0 !< Z coordinate of origin. real ( R8P ), intent ( IN ) :: Dx !< Space step in x direction. real ( R8P ), intent ( IN ) :: Dy !< Space step in y direction. real ( R8P ), intent ( IN ) :: Dz !< Space step in z direction. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'ORIGIN ' // trim ( str ( n = X0 )) // ' ' // trim ( str ( n = Y0 )) // ' ' // trim ( str ( n = Z0 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'SPACING ' // trim ( str ( n = Dx )) // ' ' // trim ( str ( n = Dy )) // ' ' // trim ( str ( n = Dz )) case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'ORIGIN ' // trim ( str ( n = X0 )) // ' ' // trim ( str ( n = Y0 )) // ' ' // trim ( str ( n = Z0 )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'SPACING ' // trim ( str ( n = Dx )) // ' ' // trim ( str ( n = Dy )) // ' ' // trim ( str ( n = Dz )) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R8 function VTK_GEO_STRP_R4 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_POINTS topology (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. real ( R4P ), intent ( IN ) :: X0 !< X coordinate of origin. real ( R4P ), intent ( IN ) :: Y0 !< Y coordinate of origin. real ( R4P ), intent ( IN ) :: Z0 !< Z coordinate of origin. real ( R4P ), intent ( IN ) :: Dx !< Space step in x direction. real ( R4P ), intent ( IN ) :: Dy !< Space step in y direction. real ( R4P ), intent ( IN ) :: Dz !< Space step in z direction. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'ORIGIN ' // trim ( str ( n = X0 )) // ' ' // trim ( str ( n = Y0 )) // ' ' // trim ( str ( n = Z0 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'SPACING ' // trim ( str ( n = Dx )) // ' ' // trim ( str ( n = Dy )) // ' ' // trim ( str ( n = Dz )) case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'ORIGIN ' // trim ( str ( n = X0 )) // ' ' // trim ( str ( n = Y0 )) // ' ' // trim ( str ( n = Z0 )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'SPACING ' // trim ( str ( n = Dx )) // ' ' // trim ( str ( n = Dy )) // ' ' // trim ( str ( n = Dz )) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R4 function VTK_GEO_STRG_1DA_R8 ( Nx , Ny , Nz , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: X ( 1 :) !< X coordinates [1:NN]. real ( R8P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates [1:NN]. real ( R8P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' do n1 = 1 , NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_1DA_R8 function VTK_GEO_STRG_1DAP_R8 ( Nx , Ny , Nz , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y and Z coordinates [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' do n1 = 1 , NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) XYZ write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_1DAP_R8 function VTK_GEO_STRG_3DA_R8 ( Nx , Ny , Nz , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: X ( 1 :, 1 :, 1 :) !< X coordinates [1:Nx,1:Ny,1:Nz]. real ( R8P ), intent ( IN ) :: Y ( 1 :, 1 :, 1 :) !< Y coordinates [1:Nx,1:Ny,1:Nz]. real ( R8P ), intent ( IN ) :: Z ( 1 :, 1 :, 1 :) !< Z coordinates [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 , n3 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' do n3 = 1 , Nz do n2 = 1 , Ny do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 , n2 , n3 )) // ' ' // str ( n = Y ( n1 , n2 , n3 )) // ' ' // str ( n = Z ( n1 , n2 , n3 )) enddo enddo enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO )((( X ( n1 , n2 , n3 ), Y ( n1 , n2 , n3 ), Z ( n1 , n2 , n3 ), n1 = 1 , Nx ), n2 = 1 , Ny ), n3 = 1 , Nz ) write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_3DA_R8 function VTK_GEO_STRG_3DAP_R8 ( Nx , Ny , Nz , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: XYZ ( 1 :, 1 :, 1 :, 1 :) !< X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 , n3 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' do n3 = 1 , Nz do n2 = 1 , Ny do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 , n2 , n3 )) // ' ' // str ( n = XYZ ( 2 , n1 , n2 , n3 )) // ' ' // str ( n = XYZ ( 3 , n1 , n2 , n3 )) enddo enddo enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) XYZ write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_3DAP_R8 function VTK_GEO_STRG_1DA_R4 ( Nx , Ny , Nz , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: X ( 1 :) !< X coordinates [1:NN]. real ( R4P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates [1:NN]. real ( R4P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' do n1 = 1 , NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_1DA_R4 function VTK_GEO_STRG_1DAP_R4 ( Nx , Ny , Nz , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y and Z coordinates [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' do n1 = 1 , NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) XYZ write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_1DAP_R4 function VTK_GEO_STRG_3DA_R4 ( Nx , Ny , Nz , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: X ( 1 :, 1 :, 1 :) !< X coordinates [1:Nx,1:Ny,1:Nz]. real ( R4P ), intent ( IN ) :: Y ( 1 :, 1 :, 1 :) !< Y coordinates [1:Nx,1:Ny,1:Nz]. real ( R4P ), intent ( IN ) :: Z ( 1 :, 1 :, 1 :) !< Z coordinates [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 , n3 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' do n3 = 1 , Nz do n2 = 1 , Ny do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 , n2 , n3 )) // ' ' // str ( n = Y ( n1 , n2 , n3 )) // ' ' // str ( n = Z ( n1 , n2 , n3 )) enddo enddo enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO )((( X ( n1 , n2 , n3 ), Y ( n1 , n2 , n3 ), Z ( n1 , n2 , n3 ), n1 = 1 , Nx ), n2 = 1 , Ny ), n3 = 1 , Nz ) write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_3DA_R4 function VTK_GEO_STRG_3DAP_R4 ( Nx , Ny , Nz , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: XYZ ( 1 :, 1 :, 1 :, 1 :) !< X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 , n3 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' do n3 = 1 , Nz do n2 = 1 , Ny do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 , n2 , n3 )) // ' ' // str ( n = XYZ ( 2 , n1 , n2 , n3 )) // ' ' // str ( n = XYZ ( 3 , n1 , n2 , n3 )) enddo enddo enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // trim ( str (. true ., NN )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) XYZ write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_3DAP_R4 function VTK_GEO_RECT_R8 ( Nx , Ny , Nz , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with RECTILINEAR_GRID topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. real ( R8P ), intent ( IN ) :: X ( 1 : Nx ) !< X coordinates. real ( R8P ), intent ( IN ) :: Y ( 1 : Ny ) !< Y coordinates. real ( R8P ), intent ( IN ) :: Z ( 1 : Nz ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'X_COORDINATES ' // trim ( str (. true ., Nx )) // ' double' do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'Y_COORDINATES ' // trim ( str (. true ., Ny )) // ' double' do n1 = 1 , Ny write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = Y ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'Z_COORDINATES ' // trim ( str (. true ., Nz )) // ' double' do n1 = 1 , Nz write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = Z ( n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'X_COORDINATES ' // trim ( str (. true ., Nx )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) X write ( vtk ( rf )% u , iostat = E_IO ) end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'Y_COORDINATES ' // trim ( str (. true ., Ny )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) Y write ( vtk ( rf )% u , iostat = E_IO ) end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'Z_COORDINATES ' // trim ( str (. true ., Nz )) // ' double' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) Z write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R8 function VTK_GEO_RECT_R4 ( Nx , Ny , Nz , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with RECTILINEAR_GRID topology (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx !< Number of nodes in x direction. integer ( I4P ), intent ( IN ) :: Ny !< Number of nodes in y direction. integer ( I4P ), intent ( IN ) :: Nz !< Number of nodes in z direction. real ( R4P ), intent ( IN ) :: X ( 1 : Nx ) !< X coordinates. real ( R4P ), intent ( IN ) :: Y ( 1 : Ny ) !< Y coordinates. real ( R4P ), intent ( IN ) :: Z ( 1 : Nz ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'X_COORDINATES ' // trim ( str (. true ., Nx )) // ' float' do n1 = 1 , Nx write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = X ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'Y_COORDINATES ' // trim ( str (. true ., Ny )) // ' float' do n1 = 1 , Ny write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = Y ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) 'Z_COORDINATES ' // trim ( str (. true ., Nz )) // ' float' do n1 = 1 , Nz write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) str ( n = Z ( n1 )) enddo case ( raw ) write ( vtk ( rf )% u , iostat = E_IO ) 'DIMENSIONS ' // trim ( str (. true ., Nx )) // ' ' // trim ( str (. true ., Ny )) // ' ' // trim ( str (. true ., Nz )) // end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'X_COORDINATES ' // trim ( str (. true ., Nx )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) X write ( vtk ( rf )% u , iostat = E_IO ) end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'Y_COORDINATES ' // trim ( str (. true ., Ny )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) Y write ( vtk ( rf )% u , iostat = E_IO ) end_rec write ( vtk ( rf )% u , iostat = E_IO ) 'Z_COORDINATES ' // trim ( str (. true ., Nz )) // ' float' // end_rec write ( vtk ( rf )% u , iostat = E_IO ) Z write ( vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R4 function VTK_GEO_UNST_R8 ( NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with UNSTRUCTURED_GRID topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. real ( R8P ), intent ( IN ) :: X ( 1 :) !< X coordinates of all nodes [1:NN]. real ( R8P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates of all nodes [1:NN]. real ( R8P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates of all nodes [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' double' do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' double' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R8 function VTK_GEO_UNST_P_R8 ( NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with UNSTRUCTURED_GRID topology (R8P, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. real ( R8P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y and Z coordinates of all nodes [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' double' do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' double' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) XYZ write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_P_R8 function VTK_GEO_UNST_R4 ( NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with UNSTRUCTURED_GRID topology (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN !< number of nodes. real ( R4P ), intent ( IN ) :: X ( 1 :) !< X coordinates of all nodes [1:NN]. real ( R4P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates of all nodes [1:NN]. real ( R4P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates of all nodes [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' float' do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' float' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R4 function VTK_GEO_UNST_P_R4 ( NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with UNSTRUCTURED_GRID topology (R4P, packed API). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN !< number of nodes. real ( R4P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y and Z coordinates of all nodes [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' float' do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'POINTS ' // str (. true ., NN ) // ' float' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) XYZ write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_P_R4 endmodule Lib_VTK_IO_GEO","tags":"","loc":"sourcefile/lib_vtk_io_geo.f90.html","title":"Lib_VTK_IO_GEO.f90 – Lib_VTK_IO"},{"text":"INI_XML interface definition for Lib_VTK_IO. Source Code !< INI_XML interface definition for Lib_VTK_IO. module Lib_VTK_IO_INI_XML !----------------------------------------------------------------------------------------------------------------------------------- !< INI_XML interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_INI_XML_WRITE public :: VTK_INI_XML_READ !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_INI_XML_WRITE ( fformat , filename , mesh_topology , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initializing VTK-XML file (exporter). !< !< The XML standard is more powerful than legacy one. It is flexible but on the other hand is (but not so more using this library !< ...) complex than legacy standard. The output of XML functions is a well-formated valid XML file, at least for the !< ascii, binary and binary appended formats (in the raw-binary format the library uses raw-binary-appended format that is not a !< valid XML file). !< Note that the XML functions have the same name of legacy functions with the suffix *XML*. !< @note This function must be the first to be called. !< !< Supported output formats are (the passed specifier value is case insensitive): !<- ASCII: data are saved in ASCII format; !<- BINARY: data are saved in base64 encoded format; !<- RAW: data are saved in raw-binary format in the appended tag of the XML file; !<- BINARY-APPENDED: data are saved in base64 encoded format in the appended tag of the XML file. !< Supported topologies are: !<- RectilinearGrid; !<- StructuredGrid; !<- UnstructuredGrid. !<### Example of usage !<```fortran !< integer(I4P):: nx1,nx2,ny1,ny2,nz1,nz2 !< ... !< E_IO = VTK_INI_XML('BINARY','XML_RECT_BINARY.vtr','RectilinearGrid',nx1=nx1,nx2=nx2,ny1=ny1,ny2=ny2,nz1=nz1,nz2=nz2) !< ... !<``` !< Note that the file extension is necessary in the file name. The XML standard has different extensions for each !< different topologies (e.g. *vtr* for rectilinear topology). See the VTK-standard file for more information. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: fformat !< File format: ASCII, BINARY, RAW or BINARY-APPENDED. character ( * ), intent ( IN ) :: filename !< File name. character ( * ), intent ( IN ) :: mesh_topology !< Mesh topology. integer ( I4P ), intent ( IN ), optional :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ), optional :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ), optional :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ), optional :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ), optional :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ), optional :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init call vtk_update ( act = 'add' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf vtk ( rf )% topology = trim ( mesh_topology ) select case ( trim ( Upper_Case ( fformat ))) case ( 'ASCII' ) vtk ( rf )% f = ascii open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), form = 'FORMATTED' ,& access = 'SEQUENTIAL' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) ! writing header of file write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' if ( endian == endianL ) then s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' endif write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = 2 select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' WholeExtent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' case ( 'UnstructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // '>' endselect write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'RAW' , 'BINARY-APPENDED' ) vtk ( rf )% f = raw if ( trim ( Upper_Case ( fformat )) == 'BINARY-APPENDED' ) vtk ( rf )% f = bin_app open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ),& form = 'UNFORMATTED' , access = 'STREAM' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) ! writing header of file write ( unit = vtk ( rf )% u , iostat = E_IO ) '<?xml version=\"1.0\"?>' // end_rec if ( endian == endianL ) then s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' endif write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = 2 select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' WholeExtent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' case ( 'UnstructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // '>' endselect write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 ! opening the SCRATCH file used for appending raw binary data open ( unit = Get_Unit ( vtk ( rf )% ua ), form = 'UNFORMATTED' , access = 'STREAM' , action = 'READWRITE' , status = 'SCRATCH' , iostat = E_IO ) vtk ( rf )% ioffset = 0 ! initializing offset pointer case ( 'BINARY' ) vtk ( rf )% f = binary open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ),& form = 'UNFORMATTED' , access = 'STREAM' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) ! writing header of file write ( unit = vtk ( rf )% u , iostat = E_IO ) '<?xml version=\"1.0\"?>' // end_rec if ( endian == endianL ) then s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"' // trim ( vtk ( rf )% topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' endif write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = 2 select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // ' WholeExtent=\"' // & trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' case ( 'UnstructuredGrid' ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<' // trim ( vtk ( rf )% topology ) // '>' endselect write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI_XML_WRITE function VTK_INI_XML_READ ( fformat , filename , mesh_topology , npieces , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initializing VTK-XML file (importer). !< !< Supported input formats are (the passed specifier value is case insensitive): !<- ASCII: data are saved in ASCII format; (Not implemented!) !<- BINARY: data are saved in base64 encoded format; (Not tested!) !<- RAW: data are saved in raw-binary format in the appended tag of the XML file; (Not implemented!) !<- BINARY-APPENDED: data are saved in base64 encoded format in the appended tag of the XML file. (Not implemented!) !< Supported topologies are: !<- RectilinearGrid; (Not tested!) !<- StructuredGrid; (Not tested!) !<- UnstructuredGrid. (Not tested!) !<### Example of usage !<```fortran !< integer(I4P):: nx1,nx2,ny1,ny2,nz1,nz2 !< ... !< E_IO = VTK_INI_XML_READ('BINARY','XML_RECT_BINARY.vtr','RectilinearGrid',nx1=nx1,nx2=nx2,ny1=ny1,ny2=ny2,nz1=nz1,nz2=nz2,cf=rf) !< ... !<``` !< Note that the file extension is necessary in the file name. The XML standard has different extensions for each !< different topologies (e.g. *vtr* for rectilinear topology). See the VTK-standard file for more information. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: fformat !< File format: ASCII,  BINARY or RAW character ( * ), intent ( IN ) :: filename !< File name character ( * ), intent ( IN ) :: mesh_topology !< Mesh topology integer ( I4P ), intent ( OUT ), optional :: npieces !< Number of pieces stored in the file integer ( I4P ), intent ( OUT ), optional :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ), optional :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ), optional :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ), optional :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ), optional :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ), optional :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: np !< Real number of pieces. character ( len = :), allocatable :: s_buffer !< Buffer string. character :: c1 , c2 !< Characters dummies. character ( len = :), allocatable :: aux !< Auxiliary string. integer ( I4P ), dimension ( 6 ) :: rn !< Real node ranges in WholeExtent [nx1,nx2,ny1,ny2,nz1,nz2]. logical :: fexist !< Flag for checking the existence of file to import. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init call vtk_update ( act = 'add' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf vtk ( rf )% topology = trim ( mesh_topology ) inquire ( file = trim ( filename ), exist = fexist ); if (. not . fexist ) return select case ( trim ( Upper_Case ( fformat ))) case ( 'ASCII' ) vtk ( rf )% f = ascii select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' , 'UnstructuredGrid' ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), status = 'old' , & form = 'UNFORMATTED' , access = 'STREAM' , action = 'READ' , & iostat = E_IO , position = 'REWIND' ) select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) ! get WholeExtent E_IO = move ( inside = 'VTKFile' , to_find = trim ( vtk ( rf )% topology ), cf = rf , buffer = s_buffer ) call get_char ( buffer = s_buffer , attrib = 'WholeExtent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * ) rn if ( present ( nx1 )) nx1 = rn ( 1 ); if ( present ( nx2 )) nx2 = rn ( 2 ) if ( present ( ny1 )) ny1 = rn ( 3 ); if ( present ( ny2 )) ny2 = rn ( 4 ) if ( present ( nz1 )) nz1 = rn ( 5 ); if ( present ( nz2 )) nz2 = rn ( 6 ) endif endselect ! count the pieces rewind ( unit = vtk ( rf )% u , iostat = E_IO ) np = 0 do E_IO = read_record ( buffer = s_buffer , cf = rf ); if ( E_IO /= 0 ) exit s_buffer = trim ( adjustl ( Upper_Case ( s_buffer ))) if ( index ( s_buffer , '</' // trim ( Upper_Case ( vtk ( rf )% topology ))) > 0 ) exit ! end of ASCII header section found if ( index ( s_buffer , '<PIECE' ) > 0 ) np = np + 1 enddo endselect case ( 'BINARY' ) vtk ( rf )% f = binary select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' , 'UnstructuredGrid' ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), status = 'old' , & form = 'UNFORMATTED' , access = 'STREAM' , action = 'READ' , & iostat = E_IO , position = 'REWIND' ) select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) ! Get WholeExtent E_IO = move ( inside = 'VTKFile' , to_find = trim ( vtk ( rf )% topology ), cf = rf , buffer = s_buffer ) call get_char ( buffer = s_buffer , attrib = 'WholeExtent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * ) rn if ( present ( nx1 )) nx1 = rn ( 1 ); if ( present ( nx2 )) nx2 = rn ( 2 ) if ( present ( ny1 )) ny1 = rn ( 3 ); if ( present ( ny2 )) ny2 = rn ( 4 ) if ( present ( nz1 )) nz1 = rn ( 5 ); if ( present ( nz2 )) nz2 = rn ( 6 ) endif endselect ! count the pieces rewind ( unit = vtk ( rf )% u , iostat = E_IO ) np = 0 do E_IO = read_record ( buffer = s_buffer , cf = rf ); if ( E_IO /= 0 ) exit s_buffer = trim ( adjustl ( Upper_Case ( s_buffer ))) if ( index ( s_buffer , '</' // trim ( Upper_Case ( vtk ( rf )% topology ))) > 0 ) exit ! end of ASCII header section found if ( index ( s_buffer , '<PIECE' ) > 0 ) np = np + 1 enddo endselect case ( 'RAW' ) vtk ( rf )% f = raw select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' , 'UnstructuredGrid' ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), status = 'old' , & form = 'UNFORMATTED' , access = 'STREAM' , action = 'READ' , & iostat = E_IO , position = 'REWIND' ) E_IO = move ( inside = 'VTKFile' , cf = rf , buffer = s_buffer ) call get_char ( buffer = s_buffer , attrib = 'byte_order' , val = aux , E_IO = E_IO ) ! check the file endianness if ( index ( trim ( aux ), 'LITTLEENDIAN' ) > 0 ) then close ( unit = vtk ( rf )% u , iostat = E_IO ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), status = 'old' , & form = 'UNFORMATTED' , access = 'STREAM' , action = 'READ' , & convert = 'LITTLE_ENDIAN' , iostat = E_IO , position = 'REWIND' ) elseif ( index ( trim ( aux ), 'BIGENDIAN' ) > 0 ) then close ( unit = vtk ( rf )% u , iostat = E_IO ) open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), status = 'old' , & form = 'UNFORMATTED' , access = 'STREAM' , action = 'READ' , & convert = 'BIG_ENDIAN' , iostat = E_IO , position = 'REWIND' ) else rewind ( unit = vtk ( rf )% u , iostat = E_IO ) endif select case ( trim ( vtk ( rf )% topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) ! Get WholeExtent E_IO = move ( inside = 'VTKFile' , to_find = trim ( vtk ( rf )% topology ), cf = rf , buffer = s_buffer ) call get_char ( buffer = s_buffer , attrib = 'WholeExtent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * ) rn if ( present ( nx1 )) nx1 = rn ( 1 ); if ( present ( nx2 )) nx2 = rn ( 2 ) if ( present ( ny1 )) ny1 = rn ( 3 ); if ( present ( ny2 )) ny2 = rn ( 4 ) if ( present ( nz1 )) nz1 = rn ( 5 ); if ( present ( nz2 )) nz2 = rn ( 6 ) endif endselect ! count the pieces rewind ( unit = vtk ( rf )% u , iostat = E_IO ) np = 0 do E_IO = read_record ( buffer = s_buffer , cf = rf ); if ( E_IO /= 0 ) exit s_buffer = trim ( adjustl ( Upper_Case ( s_buffer ))) if ( index ( s_buffer , '</' // trim ( Upper_Case ( vtk ( rf )% topology ))) > 0 ) exit ! end of ASCII header section found if ( index ( s_buffer , '<PIECE' ) > 0 ) np = np + 1 enddo ! calculate the offset to reach the appended data rewind ( unit = vtk ( rf )% u , iostat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO ) c1 do read ( unit = vtk ( rf )% u , iostat = E_IO ) c2 ; if ( E_IO /= 0 ) exit if ( iachar ( c1 ) == 1 0. and . c2 == '_' ) exit c1 = c2 enddo inquire ( unit = vtk ( rf )% u , pos = vtk ( rf )% ioffset ) endselect endselect if ( present ( npieces )) npieces = np endfunction VTK_INI_XML_READ endmodule Lib_VTK_IO_INI_XML","tags":"","loc":"sourcefile/lib_vtk_io_ini_xml.f90.html","title":"Lib_VTK_IO_INI_XML.f90 – Lib_VTK_IO"},{"text":"FLD_XML interface definition for Lib_VTK_IO. Source Code !< FLD_XML interface definition for Lib_VTK_IO. module Lib_VTK_IO_FLD_XML !----------------------------------------------------------------------------------------------------------------------------------- !< FLD_XML interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_FLD_XML !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTK_FLD_XML !< Procedure for saving field data (global auxiliary data, eg time, step number, dataset name, etc). !< !< VTK_FLD_XML is an interface to 7 different functions, there are 2 functions for real field data, 4 functions for integer one !< and one function for open and close field data tag. !< VTK_FLD_XML must be called after VTK_INI_XML and before VTK_GEO_XML. It must always called three times at least: !< !< 1. for opening the FieldData tag; !< 2. for saving at least one FieldData entry; !< 3. for closing the FieldData tag. !< !< Example of usage: !< !<```fortran !<... !<real(R8P)::    time !<integer(I4P):: step !<... !<E_IO=VTK_FLD_XML(fld_action='open') !<E_IO=VTK_FLD_XML(fld=time,fname='TIME') !<E_IO=VTK_FLD_XML(fld=step,fname='CYCLE') !<E_IO=VTK_FLD_XML(fld_action='close') !<... !<``` module procedure VTK_FLD_XML_OC , & ! open/close field data tag VTK_FLD_XML_R8 , & ! real(R8P)    scalar VTK_FLD_XML_R4 , & ! real(R4P)    scalar VTK_FLD_XML_I8 , & ! integer(I8P) scalar VTK_FLD_XML_I4 , & ! integer(I4P) scalar VTK_FLD_XML_I2 , & ! integer(I2P) scalar VTK_FLD_XML_I1 ! integer(I1P) scalar endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_FLD_XML_OC ( fld_action , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for open/close field data tag. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fld_action !< Field data tag action: OPEN or CLOSE tag. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( trim ( Upper_Case ( fld_action ))) case ( 'OPEN' ) select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<FieldData>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( raw , binary , bin_app ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<FieldData>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 endselect case ( 'CLOSE' ) select case ( vtk ( rf )% f ) case ( ascii ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</FieldData>' case ( raw , binary , bin_app ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</FieldData>' // end_rec endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_OC function VTK_FLD_XML_R8 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYR8P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( BYR8P , I4P )], a2 = [ fld ], packed = fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_R8 function VTK_FLD_XML_R4 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYR4P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( BYR4P , I4P )], a2 = [ fld ], packed = fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_R4 function VTK_FLD_XML_I8 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYI8P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( BYI8P , I4P )], a2 = [ fld ], packed = fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_I8 function VTK_FLD_XML_I4 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I8P ) :: Nfldp !< Dimension of fldp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYI4P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec Nfldp = size ( transfer ([ int ( BYI4P , I4P ), fld ], fldp ), kind = I8P ) ; if ( allocated ( fldp )) deallocate ( fldp ) ; allocate ( fldp ( 1 : Nfldp )) fldp = transfer ([ int ( BYI4P , I4P ), fld ], fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_I4 function VTK_FLD_XML_I2 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYI2P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( BYI2P , I4P )], a2 = [ fld ], packed = fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_I2 function VTK_FLD_XML_I1 ( fld , fname , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I1P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: fld !< Field data value. character ( * ), intent ( IN ) :: fname !< Field data name. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: fldp (:) !< Packed field data. character ( len = :), allocatable :: fld64 !< Field data encoded in base64. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"ascii\">' // & trim ( str ( n = fld )) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // & '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( BYI1P , I4P )) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , 1_I4P write ( unit = vtk ( rf )% ua , iostat = E_IO ) fld case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" NumberOfTuples=\"1\" Name=\"' // trim ( fname ) // '\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( BYI1P , I4P )], a2 = [ fld ], packed = fldp ) call b64_encode ( n = fldp , code = fld64 ) ; deallocate ( fldp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // fld64 // end_rec ; deallocate ( fld64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_FLD_XML_I1 endmodule Lib_VTK_IO_FLD_XML","tags":"","loc":"sourcefile/lib_vtk_io_fld_xml.f90.html","title":"Lib_VTK_IO_FLD_XML.f90 – Lib_VTK_IO"},{"text":"DAT_XML and VAR_XML interface definitions for Lib_VTK_IO. Source Code !< DAT_XML and VAR_XML interface definitions for Lib_VTK_IO. module Lib_VTK_IO_DAT_VAR_XML !----------------------------------------------------------------------------------------------------------------------------------- !< DAT_XML and VAR_XML interface definitions for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_DAT_XML public :: VTK_VAR_XML !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTK_VAR_XML !< Procedure for saving data variable(s) in VTK-XML standard. !< !< VTK_VAR_XML is an interface to 36 different functions, there are 6 functions for scalar variables, 6 functions for vectorial !< variables and 6 functions for 3D(or higher) vectorial variables: for all of types the precision can be R8P, R4P, I8P, I4P, I2P !< and I1P. This function saves the data variables related (cell-centered or node-centered) to geometric mesh. !< 1D/3D-rank arrays and packed API for any kinds !< The inputs arrays can be passed as 1D-rank or 3D-rank and the vectorial variables can be component-separated (one for each of !< the 3 components) or packed into one multidimensional array: !< !<- scalar input: !<    - input is 1D-rank array: var[1:NC_NN]; !<    - input is 3D-rank array: var[nx1:nx2,ny1:ny2,nz1:nz2]; !<- vectorial inputs: !<    - inputs are 1D-rank arrays: varX[1:NC_NN],varY[1:NC_NN],varZ[1:NC_NN]; !<    - inputs are 3D-rank arrays: varX[nx1:nx2,ny1:ny2,nz1:nz2],varY[nx1:nx2,ny1:ny2,nz1:nz2],varX[nx1:nx2,ny1:ny2,nz1:nz2]; !<- 3D(or higher) vectorial inputs: !<    - input is 1D-rank (packed API): var[1:N_COL,1:NC_NN]; !<    - input is 3D-rank (packed API): var[1:N_COL,nx1:nx2,ny1:ny2,nz1:nz2]. !< !< @note Note that the inputs that must be passed change depending on the data variables type. !< !<### Examples of usage !< !<#### Scalar data calling !<```fortran !< integer(I4P):: NN !< real(R8P)::    var(1:NN) !< ... !< E_IO=VTK_VAR_XML(NN,'Sca',var) !< ... !<``` !< !<#### Vectorial data calling !<```fortran !< integer(I4P):: NN !< real(R8P)::    varX(1:NN),varY(1:NN),varZ(1:NN), !< ... !< E_IO=VTK_VAR_XML(NN,'Vec',varX,varY,varZ) !< ... !<``` module procedure VTK_VAR_XML_SCAL_1DA_R8 , VTK_VAR_XML_SCAL_3DA_R8 , & ! real(R8P)    scalar    1D/3D array VTK_VAR_XML_SCAL_1DA_R4 , VTK_VAR_XML_SCAL_3DA_R4 , & ! real(R4P)    scalar    1D/3D array VTK_VAR_XML_SCAL_1DA_I8 , VTK_VAR_XML_SCAL_3DA_I8 , & ! integer(I8P) scalar    1D/3D array VTK_VAR_XML_SCAL_1DA_I4 , VTK_VAR_XML_SCAL_3DA_I4 , & ! integer(I4P) scalar    1D/3D array VTK_VAR_XML_SCAL_1DA_I2 , VTK_VAR_XML_SCAL_3DA_I2 , & ! integer(I2P) scalar    1D/3D array VTK_VAR_XML_SCAL_1DA_I1 , VTK_VAR_XML_SCAL_3DA_I1 , & ! integer(I1P) scalar    1D/3D array VTK_VAR_XML_VECT_1DA_R8 , VTK_VAR_XML_VECT_3DA_R8 , & ! real(R8P)    vectorial 1D/3D arrays VTK_VAR_XML_VECT_1DA_R4 , VTK_VAR_XML_VECT_3DA_R4 , & ! real(R4P)    vectorial 1D/3D arrays VTK_VAR_XML_VECT_1DA_I8 , VTK_VAR_XML_VECT_3DA_I8 , & ! integer(I8P) vectorial 1D/3D arrays VTK_VAR_XML_VECT_1DA_I4 , VTK_VAR_XML_VECT_3DA_I4 , & ! integer(I4P) vectorial 1D/3D arrays VTK_VAR_XML_VECT_1DA_I2 , VTK_VAR_XML_VECT_3DA_I2 , & ! integer(I2P) vectorial 1D/3D arrays VTK_VAR_XML_VECT_1DA_I1 , VTK_VAR_XML_VECT_3DA_I1 , & ! integer(I1P) vectorial 1D/3D arrays VTK_VAR_XML_LIST_1DA_R8 , VTK_VAR_XML_LIST_3DA_R8 , & ! real(R8P)    list      1D/3D array VTK_VAR_XML_LIST_1DA_R4 , VTK_VAR_XML_LIST_3DA_R4 , & ! real(R4P)    list      1D/3D array VTK_VAR_XML_LIST_1DA_I8 , VTK_VAR_XML_LIST_3DA_I8 , & ! integer(I4P) list      1D/3D array VTK_VAR_XML_LIST_1DA_I4 , VTK_VAR_XML_LIST_3DA_I4 , & ! integer(I4P) list      1D/3D array VTK_VAR_XML_LIST_1DA_I2 , VTK_VAR_XML_LIST_3DA_I2 , & ! integer(I2P) list      1D/3D array VTK_VAR_XML_LIST_1DA_I1 , VTK_VAR_XML_LIST_3DA_I1 ! integer(I1P) list      1D/3D array endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_DAT_XML ( var_location , var_block_action , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing/finalizing the saving of data associated to the mesh. !< !< Function that **must** be called before saving the data related to geometric mesh, this function initializes the !< saving of data variables indicating the *type* (node or cell centered) of variables that will be saved. !< @note A single file can contain both cell and node centered variables. In this case the VTK_DAT_XML function must be !< called two times, before saving cell-centered variables and before saving node-centered variables. !< !<### Examples of usage !< !<#### Opening node piece !<```fortran !< E_IO=VTK_DAT_XML('node','OPeN') !<``` !< !<#### Closing node piece !<```fortran !< E_IO=VTK_DAT_XML('node','CLosE') !<``` !< !<#### Opening cell piece !<```fortran !< E_IO=VTK_DAT_XML('cell','OPEN') !<``` !< !<#### Closing cell piece !<```fortran !< E_IO=VTK_DAT_XML('cell','close') !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: var_location !< Location of saving variables: CELL or NODE centered. character ( * ), intent ( IN ) :: var_block_action !< Variables block action: OPEN or CLOSE block. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<CellData>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</CellData>' endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PointData>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PointData>' endselect endselect case ( raw , binary , bin_app ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<CellData>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</CellData>' // end_rec endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<PointData>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 case ( 'CLOSE' ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</PointData>' // end_rec endselect endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT_XML function VTK_VAR_XML_SCAL_1DA_R8 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R8P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYR8P , I4P )], a2 = var , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_R8 function VTK_VAR_XML_SCAL_3DA_R8 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R8P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYR8P , I4P )], a2 = reshape ( var ,[ NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_R8 function VTK_VAR_XML_SCAL_1DA_R4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R4P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYR4P , I4P )], a2 = var , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_R4 function VTK_VAR_XML_SCAL_3DA_R4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R4P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYR4P , I4P )], a2 = reshape ( var ,[ NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_R4 function VTK_VAR_XML_SCAL_1DA_I8 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I8P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI8P , I4P )], a2 = var , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_I8 function VTK_VAR_XML_SCAL_3DA_I8 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I8P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI8P , I4P )], a2 = reshape ( var ,[ NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_I8 function VTK_VAR_XML_SCAL_1DA_I4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I4P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec Nvarp = size ( transfer ([ int ( NC_NN * BYI4P , I4P ), var ], varp ), kind = I8P ) ; if ( allocated ( varp )) deallocate ( varp ) ; allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( NC_NN * BYI4P , I4P ), var ], varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_I4 function VTK_VAR_XML_SCAL_3DA_I4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I4P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec Nvarp = size ( transfer ([ int ( NC_NN * BYI4P , I4P ), reshape ( var ,[ NC_NN ])], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( NC_NN * BYI4P , I4P ), reshape ( var ,[ NC_NN ])], varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_I4 function VTK_VAR_XML_SCAL_1DA_I2 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I2P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI2P , I4P )], a2 = var , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_I2 function VTK_VAR_XML_SCAL_3DA_I2 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I2P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI2P , I4P )], a2 = reshape ( var ,[ NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_I2 function VTK_VAR_XML_SCAL_1DA_I1 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I1P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: var ( 1 :) !< Variable to be saved [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),( ' ' // str ( n = var ( n1 )), n1 = 1 , NC_NN ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI1P , I4P )], a2 = var , packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_1DA_I1 function VTK_VAR_XML_SCAL_3DA_I1 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I1P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :) !< Variable to be saved [1:Nx,1:ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., NC_NN + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ((( ' ' // str ( n = var ( nx , ny , nz )), nx = 1 , size ( var , dim = 1 )), ny = 1 , size ( var , dim = 2 )), nz = 1 , size ( var , dim = 3 )) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( NC_NN * BYI1P , I4P )], a2 = reshape ( var ,[ NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_3DA_I1 function VTK_VAR_XML_VECT_1DA_R8 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R8P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. real ( R8P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. real ( R8P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R8P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYR8P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_R8 function VTK_VAR_XML_VECT_3DA_R8 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R8P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. real ( R8P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. real ( R8P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R8P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYR8P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_R8 function VTK_VAR_XML_VECT_1DA_R4 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R4P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. real ( R4P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. real ( R4P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R4P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYR4P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_R4 function VTK_VAR_XML_VECT_3DA_R4 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R4P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. real ( R4P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. real ( R4P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R4P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYR4P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_R4 function VTK_VAR_XML_VECT_1DA_I8 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I8P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. integer ( I8P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. integer ( I8P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I8P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( 3 * NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI8P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_I8 function VTK_VAR_XML_VECT_3DA_I8 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I8P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. integer ( I8P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. integer ( I8P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I8P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( 3 * NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI8P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_I8 function VTK_VAR_XML_VECT_1DA_I4 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I4P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. integer ( I4P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. integer ( I4P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo Nvarp = size ( transfer ([ int ( 3 * NC_NN * BYI4P , I4P ), var ], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( 3 * NC_NN * BYI4P , I4P ), var ], varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_I4 function VTK_VAR_XML_VECT_3DA_I4 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I4P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo Nvarp = size ( transfer ([ int ( 3 * NC_NN * BYI4P , I4P ), var ], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( 3 * NC_NN * BYI4P , I4P ), var ], varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_I4 function VTK_VAR_XML_VECT_1DA_I2 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I2P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. integer ( I2P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. integer ( I2P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I2P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI2P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_I2 function VTK_VAR_XML_VECT_3DA_I2 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I2P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. integer ( I2P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. integer ( I2P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I2P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI2P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_I2 function VTK_VAR_XML_VECT_1DA_I1 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I1P, 1D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: varX ( 1 :) !< X component [1:NC_NN]. integer ( I1P ), intent ( IN ) :: varY ( 1 :) !< Y component [1:NC_NN]. integer ( I1P ), intent ( IN ) :: varZ ( 1 :) !< Z component [1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NC_NN write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = varX ( n1 )) // ' ' // str ( n = varY ( n1 )) // ' ' // str ( n = varZ ( n1 )) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec vtk ( rf )% N_Byte = 3 * NC_NN * BYI1P call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) do n1 = 1 , NC_NN var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( n1 ), varY ( n1 ), varZ ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI1P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_1DA_I1 function VTK_VAR_XML_VECT_3DA_I1 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I1P, 3D arrays). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: varX ( 1 :, 1 :, 1 :) !< X component [1:Nx,1:Ny,1:Nz]. integer ( I1P ), intent ( IN ) :: varY ( 1 :, 1 :, 1 :) !< Y component [1:Nx,1:Ny,1:Nz]. integer ( I1P ), intent ( IN ) :: varZ ( 1 :, 1 :, 1 :) !< Z component [1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: var (:) !< X, Y, Z component. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = varX ( nx , ny , nz )) // ' ' // str ( n = varY ( nx , ny , nz )) // ' ' // str ( n = varZ ( nx , ny , nz )) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec vtk ( rf )% N_Byte = 3 * NC_NN * BYI1P call vtk ( rf )% byte_update ( N_Byte = 3 * NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , 3 * NC_NN write ( vtk ( rf )% ua , iostat = E_IO )((( varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz ),& nx = 1 , size ( varX , dim = 1 )), ny = 1 , size ( varX , dim = 2 )), nz = 1 , size ( varX , dim = 3 )) case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( var ( 1 : 3 * NC_NN )) n1 = 0_I4P do nz = 1 , size ( varX , dim = 3 ) ; do ny = 1 , size ( varX , dim = 2 ) ; do nx = 1 , size ( varX , dim = 1 ) n1 = n1 + 1_I4P ; var ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ varX ( nx , ny , nz ), varY ( nx , ny , nz ), varZ ( nx , ny , nz )] enddo ; enddo ; enddo call pack_data ( a1 = [ int ( 3 * NC_NN * BYI1P , I4P )], a2 = var , packed = varp ) ; deallocate ( var ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_3DA_I1 function VTK_VAR_XML_LIST_1DA_R8 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (R8P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYR8P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_R8 function VTK_VAR_XML_LIST_3DA_R8 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (R8P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYR8P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYR8P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_R8 function VTK_VAR_XML_LIST_1DA_R4 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (R4P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYR4P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_R4 function VTK_VAR_XML_LIST_3DA_R4 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (R4P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYR4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYR4P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_R4 function VTK_VAR_XML_LIST_1DA_I8 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I8P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( N_COL * NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI8P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_I8 function VTK_VAR_XML_LIST_3DA_I8 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I8P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I8P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = int ( N_COL * NC_NN * BYI8P , I4P )) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I8' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int64\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI8P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_I8 function VTK_VAR_XML_LIST_1DA_I4 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I4P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec Nvarp = size ( transfer ([ int ( N_COL * NC_NN * BYI4P , I4P ), reshape ( var ,[ N_COL * NC_NN ])], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( N_COL * NC_NN * BYI4P , I4P ), reshape ( var ,[ N_COL * NC_NN ])], varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_I4 function VTK_VAR_XML_LIST_3DA_I4 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I4P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. integer ( I8P ) :: Nvarp !< Dimension of varp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI4P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec Nvarp = size ( transfer ([ int ( N_COL * NC_NN * BYI4P , I4P ), reshape ( var ,[ N_COL * NC_NN ])], varp ), kind = I8P ) if ( allocated ( varp )) deallocate ( varp ); allocate ( varp ( 1 : Nvarp )) varp = transfer ([ int ( N_COL * NC_NN * BYI4P , I4P ), reshape ( var ,[ N_COL * NC_NN ])], varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_I4 function VTK_VAR_XML_LIST_1DA_I2 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I2P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI2P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_I2 function VTK_VAR_XML_LIST_3DA_I2 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I2P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I2P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI2P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I2' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int16\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI2P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_I2 function VTK_VAR_XML_LIST_1DA_I1 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I1P, 1D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: var ( 1 :, 1 :) !< Components [1:N_COL,1:NC_NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do n2 = 1 , NC_NN write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , n2 )), n1 = 1 , N_COL ) enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI1P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_1DA_I1 function VTK_VAR_XML_LIST_3DA_I1 ( NC_NN , N_COL , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of list variable (I1P, 3D array). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes. integer ( I4P ), intent ( IN ) :: N_COL !< Number of columns. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I1P ), intent ( IN ) :: var ( 1 :, 1 :, 1 :, 1 :) !< Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: varp (:) !< Packed data. character ( len = :), allocatable :: var64 !< Variable encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz , n1 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"ascii\">' write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = 1 , size ( var , dim = 4 ) ; do ny = 1 , size ( var , dim = 3 ) ; do nx = 1 , size ( var , dim = 2 ) write ( vtk ( rf )% u , '(' // trim ( str (. true ., N_COL + 1 )) // 'A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ),& ( ' ' // str ( n = var ( n1 , nx , ny , nz )), n1 = 1 , N_COL ) enddo ; enddo ; enddo write ( vtk ( rf )% u , '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"appended\" offset=\"' // trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = N_COL * NC_NN * BYI1P ) write ( vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , N_COL * NC_NN write ( vtk ( rf )% ua , iostat = E_IO ) var case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"' // trim ( varname ) // '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // '\" format=\"binary\">' write ( vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( N_COL * NC_NN * BYI1P , I4P )], a2 = reshape ( var ,[ N_COL * NC_NN ]), packed = varp ) call b64_encode ( n = varp , code = var64 ) ; deallocate ( varp ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // var64 // end_rec ; deallocate ( var64 ) write ( vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_3DA_I1 endmodule Lib_VTK_IO_DAT_VAR_XML","tags":"","loc":"sourcefile/lib_vtk_io_dat_var_xml.f90.html","title":"Lib_VTK_IO_DAT_VAR_XML.f90 – Lib_VTK_IO"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one module Lib_Pack_Data !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Procedure for packing different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 !> @brief Subroutine for packing different kinds of data into single I1P array. pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for packing different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( IN ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( INOUT ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule Lib_Pack_Data","tags":"","loc":"sourcefile/lib_pack_data.f90.html","title":"Lib_Pack_Data.f90 – Lib_VTK_IO"},{"text":"Pure Fortran (2003+) library to write and read data conforming the VTK standard Source Code !< Pure Fortran (2003+) library to write and read data conforming the VTK standard module Lib_VTK_IO !----------------------------------------------------------------------------------------------------------------------------------- !< Pure Fortran (2003+) library to write and read data conforming the VTK standard !<{!README-Lib_VTK_IO.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. USE Lib_VTK_IO_INI_XML ! INI_XML interface module. USE Lib_VTK_IO_FLD_XML ! FLD_XML interface module. USE Lib_VTK_IO_GEO_XML ! GEO_XML interface module. USE Lib_VTK_IO_CON_XML ! CON_XML interface module. USE Lib_VTK_IO_DAT_VAR_XML ! DAT_XML and VAR_XML interface module. USE Lib_VTK_IO_END_XML ! END_XML interface module. USE Lib_VTK_IO_VTM_XML ! VTM_XML interface module. USE Lib_VTK_IO_PVTK_XML ! PVTK_XML interface module. USE Lib_VTK_IO_PVD_XML ! PVD_XML interface module. USE Lib_VTK_IO_INI ! INI interface module. USE Lib_VTK_IO_GEO ! GEO interface module. USE Lib_VTK_IO_CON ! CON interface module. USE Lib_VTK_IO_DAT_VAR ! DAT and VAR interface module. USE Lib_VTK_IO_END ! END interface module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_INI_XML_WRITE , VTK_INI_XML_READ public :: VTK_FLD_XML public :: VTK_GEO_XML_WRITE , VTK_GEO_XML_READ public :: VTK_CON_XML public :: VTK_DAT_XML public :: VTK_VAR_XML public :: VTK_END_XML public :: VTM_INI_XML public :: VTM_BLK_XML public :: VTM_WRF_XML public :: VTM_END_XML public :: PVTK_INI_XML public :: PVTK_GEO_XML public :: PVTK_DAT_XML public :: PVTK_VAR_XML public :: PVTK_END_XML public :: PVD_INI_XML public :: PVD_DAT_XML public :: PVD_END_XML public :: VTK_INI public :: VTK_GEO public :: VTK_CON public :: VTK_DAT public :: VTK_VAR public :: VTK_END !----------------------------------------------------------------------------------------------------------------------------------- endmodule Lib_VTK_IO","tags":"","loc":"sourcefile/lib_vtk_io.f90.html","title":"Lib_VTK_IO.f90 – Lib_VTK_IO"},{"text":"CON_XML interface definition for Lib_VTK_IO. Source Code !< CON_XML interface definition for Lib_VTK_IO. module Lib_VTK_IO_CON_XML !----------------------------------------------------------------------------------------------------------------------------------- !< CON_XML interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_CON_XML !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_CON_XML ( NC , connect , offset , cell_type , idx , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh connectivity. !< !< Function that **must** be used when unstructured grid is used, it saves the connectivity of the unstructured gird. !< @note The vector **connect** must follow the VTK-XML standard. It is passed as *assumed-shape array* !< because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following !< equation: dc = \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i }. !< Note that this equation is different from the legacy one. The XML connectivity convention is quite different from the !< legacy standard. !< As an example suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with !< square basis (5 vertices) and suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells !< share 4 vertices. The above equation gives dc=8+5=13. The connectivity vector for this mesh can be: !< !<##### first cell !<+ connect(1)  = 0 identification flag of 1&#94;\\circ vertex of first cell !<+ connect(2)  = 1 identification flag of 2&#94;\\circ vertex of first cell !<+ connect(3)  = 2 identification flag of 3&#94;\\circ vertex of first cell !<+ connect(4)  = 3 identification flag of 4&#94;\\circ vertex of first cell !<+ connect(5)  = 4 identification flag of 5&#94;\\circ vertex of first cell !<+ connect(6)  = 5 identification flag of 6&#94;\\circ vertex of first cell !<+ connect(7)  = 6 identification flag of 7&#94;\\circ vertex of first cell !<+ connect(8)  = 7 identification flag of 8&#94;\\circ vertex of first cell !< !<##### second cell !<+ connect(9 ) = 0 identification flag of 1&#94;\\circ vertex of second cell !<+ connect(10) = 1 identification flag of 2&#94;\\circ vertex of second cell !<+ connect(11) = 2 identification flag of 3&#94;\\circ vertex of second cell !<+ connect(12) = 3 identification flag of 4&#94;\\circ vertex of second cell !<+ connect(13) = 8 identification flag of 5&#94;\\circ vertex of second cell !< !< Therefore this connectivity vector convention is more simple than the legacy convention, now we must create also the !< *offset* vector that contains the data now missing in the *connect* vector. The offset !< vector for this mesh can be: !< !<##### first cell !<+ offset(1) = 8  => summ of nodes of 1&#94;\\circ cell !< !<##### second cell !<+ offset(2) = 13 => summ of nodes of 1&#94;\\circ and 2&#94;\\circ cells !< !< The value of every cell-offset can be calculated by the following equation: offset_c=\\sum\\limits_{i=1}&#94;{c}{nvertex_i} !< where offset_c is the value of c&#94;{th} cell and nvertex_i is the number of vertices of i&#94;{th} cell. !< The function VTK_CON_XML does not calculate the connectivity and offset vectors: it writes the connectivity and offset !< vectors conforming the VTK-XML standard, but does not calculate them. !< The vector variable *cell\\_type* must conform the VTK-XML standard (see the file VTK-Standard at the !< Kitware homepage) that is the same of the legacy standard. It contains the !< *type* of each cells. For the above example this vector is: !< !<##### first cell !<+ cell\\_type(1) = 12 hexahedron type of first cell !< !<##### second cell !<+ cell\\_type(2) = 14 pyramid type of second cell !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC !< Number of cells. integer ( I4P ), intent ( IN ) :: connect ( 1 :) !< Mesh connectivity. integer ( I4P ), intent ( IN ) :: offset ( 1 : NC ) !< Cell offset. integer ( I1P ), intent ( IN ) :: cell_type ( 1 :) !< VTK cell type. integer ( I1P ), intent ( IN ), optional :: idx !< Id offset to convert Fortran (first id 1) to C (first id 0) standards. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: cocp (:) !< Packed data. character ( len = :), allocatable :: coc64 !< Data encoded in base64. integer ( I1P ) :: incr !< Actual id offset increment. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. integer ( I8P ) :: Ncocp !< Dimension of cocp, packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif incr = 0_I1P if ( present ( idx )) then incr = idx endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Cells>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FI4P , iostat = E_IO )( connect ( n1 ) + incr , n1 = 1 , offset ( NC )) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FI4P , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"types\" format=\"ascii\">' if ( lbound ( cell_type , dim = 1 ) == ubound ( cell_type , dim = 1 )) then write ( unit = vtk ( rf )% u , fmt = FI1P , iostat = E_IO )( cell_type ( 1 ), n1 = 1 , NC ) else write ( unit = vtk ( rf )% u , fmt = FI1P , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) endif write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Cells>' case ( raw , bin_app ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Cells>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = offset ( NC ) * BYI4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , offset ( NC ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( connect ( n1 ) + incr , n1 = 1 , offset ( NC )) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"offsets\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC * BYI4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I4' , NC write ( unit = vtk ( rf )% ua , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"types\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = NC * BYI1P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'I1' , NC if ( lbound ( cell_type , dim = 1 ) == ubound ( cell_type , dim = 1 )) then write ( unit = vtk ( rf )% ua , iostat = E_IO )( cell_type ( 1 ), n1 = 1 , NC ) else write ( unit = vtk ( rf )% ua , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) endif vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Cells>' // end_rec case ( binary ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Cells>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"binary\">' // end_rec Ncocp = size ( transfer ([ int ( offset ( NC ) * BYI4P , I4P ), connect ], cocp ), kind = I8P ) if ( allocated ( cocp )) deallocate ( cocp ) ; allocate ( cocp ( 1 : Ncocp )) cocp = transfer ([ int ( offset ( NC ) * BYI4P , I4P ), connect ], cocp ) call b64_encode ( n = cocp , code = coc64 ) deallocate ( cocp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // coc64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int32\" Name=\"offsets\" format=\"binary\">' // end_rec Ncocp = size ( transfer ([ int ( NC * BYI4P , I4P ), offset ], cocp ), kind = I8P ) ; if ( allocated ( cocp )) deallocate ( cocp ) ; allocate ( cocp ( 1 : Ncocp )) cocp = transfer ([ int ( NC * BYI4P , I4P ), offset ], cocp ) call b64_encode ( n = cocp , code = coc64 ) deallocate ( cocp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // coc64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Int8\" Name=\"types\" format=\"binary\">' // end_rec if ( lbound ( cell_type , dim = 1 ) == ubound ( cell_type , dim = 1 )) then call pack_data ( a1 = [ int ( NC * BYI1P , I4P )], a2 = [( cell_type ( 1 ), n1 = 1 , NC )], packed = cocp ) else call pack_data ( a1 = [ int ( NC * BYI1P , I4P )], a2 = cell_type , packed = cocp ) endif call b64_encode ( n = cocp , code = coc64 ) ; deallocate ( cocp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // coc64 // end_rec ; deallocate ( coc64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Cells>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON_XML endmodule Lib_VTK_IO_CON_XML","tags":"","loc":"sourcefile/lib_vtk_io_con_xml.f90.html","title":"Lib_VTK_IO_CON_XML.f90 – Lib_VTK_IO"},{"text":"Back-end module for Lib_VTK_IO. Source Code !< Back-end module for Lib_VTK_IO. module Lib_VTK_IO_Back_End !----------------------------------------------------------------------------------------------------------------------------------- !< Back-end module for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: stdout public :: stderr public :: maxlen public :: end_rec public :: ascii public :: binary public :: raw public :: bin_app public :: vtk public :: Nvtk public :: f public :: vtm public :: Get_Unit public :: Upper_Case public :: byte_update public :: vtk_update public :: adjustlt public :: get_int public :: get_char public :: read_record public :: move public :: search !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), parameter :: maxlen = 500 !< Max number of characters of static string. character ( 1 ), parameter :: end_rec = char ( 10 ) !< End-character for binary-record finalize. integer ( I4P ), parameter :: ascii = 0 !< Ascii-output-format parameter identifier. integer ( I4P ), parameter :: binary = 1 !< Base64-output-format parameter identifier. integer ( I4P ), parameter :: raw = 2 !< Raw-appended-binary-output-format parameter identifier. integer ( I4P ), parameter :: bin_app = 3 !< Base64-appended-output-format parameter identifier. type :: Type_VTK_File !< Derived type for handling VTK files. !< !< @note The OOP encapsulation allows safe use of parallel paradigms. integer ( I4P ) :: f = ascii !< Current output-format (initialized to ascii format). character ( len = maxlen ) :: topology = '' !< Mesh topology. integer ( I4P ) :: u = 0_I4P !< Logical unit. integer ( I4P ) :: ua = 0_I4P !< Logical unit for raw binary XML append file. #ifdef HUGE integer ( I8P ) :: N_Byte = 0_I8P !< Number of byte to be written/read. #else integer ( I4P ) :: N_Byte = 0_I4P !< Number of byte to be written/read. #endif integer ( I8P ) :: ioffset = 0_I8P !< Offset pointer. integer ( I4P ) :: indent = 0_I4P !< Indent pointer. contains procedure :: byte_update !< Procedure for updating N_Byte and ioffset pointer. endtype Type_VTK_File type ( Type_VTK_File ), allocatable :: vtk (:) !< Global data of VTK files [1:Nvtk]. integer ( I4P ) :: Nvtk = 0_I4P !< Number of (concurrent) VTK files. integer ( I4P ) :: f = 0_I4P !< Current VTK file index. type :: Type_VTM_File !< Derived type for handling VTM files. integer ( I4P ) :: u = 0_I4P !< Logical unit. integer ( I4P ) :: blk ( 1 : 2 ) = [ 0_I4P , 0_I4P ] !< Block indexes. integer ( I4P ) :: indent = 0_I4P !< Indent pointer. endtype Type_VTM_File type ( Type_VTM_File ) :: vtm !< Global data of VTM files. !----------------------------------------------------------------------------------------------------------------------------------- contains function Get_Unit ( Free_Unit ) result ( funit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for obtaining a free logic unit for safely opening a file. !< !< @note If no units are available, -1 is returned. !< !<### On-the-fly usage !< The unit value is returned by the function and also by the optional argument *Free_Unit*. This allows the function to !< be used directly (on-the-fly) in an open statement like !<```fortran !< open(unit=Get_Unit(myunit),...) ; read(myunit)... !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer :: funit !< Free logic unit. integer , intent ( OUT ), optional :: Free_Unit !< Free logic unit. integer :: n1 !< Counter. integer :: ios !< Inquiring flag. logical :: lopen !< Inquiring flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- funit = - 1 if ( present ( Free_Unit )) Free_Unit = funit n1 = 1 do if (( n1 /= stdout ). AND .( n1 /= stderr )) then inquire ( unit = n1 , opened = lopen , iostat = ios ) if ( ios == 0 ) then if (. NOT . lopen ) then funit = n1 ; if ( present ( Free_Unit )) Free_Unit = funit return endif endif endif n1 = n1 + 1 enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Get_Unit elemental function Upper_Case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for converting lower case characters of a string to upper case ones. !< !< The library uses this function in order to achieve case-insensitivty: all character variables used within the libary functions !< are pre-processed by Uppper_Case function before these variables are used. So the users can call the library functions without !< pay attention of the case of the keywords passed to the functions: calling the function VTK_INI with the string !< `E_IO = VTK_INI('Ascii',...)` is equivalent to `E_IO = VTK_INI('ASCII',...)`. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) select case ( ichar ( string ( n1 : n1 ))) case ( 97 : 122 ) Upper_Case ( n1 : n1 ) = char ( ichar ( string ( n1 : n1 )) - 32 ) ! Upper case conversion endselect enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case elemental subroutine byte_update ( vtk , N_Byte ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for updating N_Byte and ioffset pointer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_VTK_File ), intent ( INOUT ) :: vtk !< Global data of VTK file. #ifdef HUGE integer ( I8P ), intent ( IN ) :: N_Byte !< Number of bytes saved. #else integer ( I4P ), intent ( IN ) :: N_Byte !< Number of bytes saved. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vtk % N_Byte = N_Byte if ( vtk % f == raw ) then #ifdef HUGE vtk % ioffset = vtk % ioffset + BYI8P + N_Byte #else vtk % ioffset = vtk % ioffset + BYI4P + N_Byte #endif else #ifdef HUGE vtk % ioffset = vtk % ioffset + (( N_Byte + BYI8P + 2_I8P ) / 3_I8P ) * 4_I8P #else vtk % ioffset = vtk % ioffset + (( N_Byte + BYI4P + 2_I4P ) / 3_I4P ) * 4_I4P #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine byte_update pure subroutine vtk_update ( act , cf , Nvtk , vtk ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for updating (adding and removing elements into) vtk array. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: act !< Action: 'ADD' one more element, 'REMOVE' current element file. integer ( I4P ), intent ( INOUT ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ), intent ( INOUT ) :: Nvtk !< Number of (concurrent) VTK files. type ( Type_VTK_File ), allocatable , intent ( INOUT ) :: vtk (:) !< VTK files data. type ( Type_VTK_File ), allocatable :: vtk_tmp (:) !< Temporary array of VTK files data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( Upper_Case ( trim ( act ))) case ( 'ADD' ) if ( Nvtk > 0_I4P ) then allocate ( vtk_tmp ( 1 : Nvtk )) vtk_tmp = vtk deallocate ( vtk ) Nvtk = Nvtk + 1 allocate ( vtk ( 1 : Nvtk )) vtk ( 1 : Nvtk - 1 ) = vtk_tmp deallocate ( vtk_tmp ) cf = Nvtk else Nvtk = 1_I4P allocate ( vtk ( 1 : Nvtk )) cf = Nvtk endif case default if ( Nvtk > 1_I4P ) then allocate ( vtk_tmp ( 1 : Nvtk - 1 )) if ( cf == Nvtk ) then vtk_tmp = vtk ( 1 : Nvtk - 1 ) else vtk_tmp ( 1 : cf - 1 ) = vtk ( 1 : cf - 1 ) vtk_tmp ( cf : ) = vtk ( cf + 1 : ) endif deallocate ( vtk ) Nvtk = Nvtk - 1 allocate ( vtk ( 1 : Nvtk )) vtk = vtk_tmp deallocate ( vtk_tmp ) cf = 1_I4P else Nvtk = 0_I4P if ( allocated ( vtk )) deallocate ( vtk ) cf = Nvtk endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine vtk_update elemental function adjustlt ( string ) result ( res ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extend adjustl to remove tab characters (char(9)). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: string !< Input string. character ( len = len ( string )) :: res !< Output string with leading tab characters or blanks removed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- res = string if ( len_trim ( res ) > 0 ) then do while (( res ( 1 : 1 ) == char ( 9 ) . or . res ( 1 : 1 ) == ' ' ) . and . len_trim ( res ) > 0 ) res = res ( 2 :) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction adjustlt subroutine get_int ( case , E_IO , buffer , attrib , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get integer value of attribute 'attrib' defined into buffer. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), optional , intent ( IN ) :: case !< Attribute string case. integer ( I4P ), optional , intent ( OUT ) :: E_IO !< Error trapping flag. character ( len =* ), intent ( IN ) :: buffer !< String where to search the attrib. character ( len =* ), intent ( IN ) :: attrib !< XML attribute id. integer ( I4P ), intent ( OUT ) :: val !< Returned integer value. integer :: pos ( 2 ) !< Position counter. integer :: E_IOD !< Dummy error trapping flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( E_IO )) E_IO = - 1_I4P if ( present ( case )) then if ( trim ( adjustlt ( Upper_Case ( case ))) == 'LOWER' ) then pos ( 1 ) = index ( buffer , trim ( adjustlt ( attrib )) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 else pos ( 1 ) = index ( buffer , trim ( adjustlt ( Upper_Case ( attrib ))) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 endif else pos ( 1 ) = index ( buffer , trim ( adjustlt ( Upper_Case ( attrib ))) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 endif if ( pos ( 1 ) <= len_trim ( adjustlt ( attrib )) + 2 ) return pos ( 2 ) = index ( buffer ( pos ( 1 ): len_trim ( buffer )), '\"' ) + pos ( 1 ) - 2 if ( pos ( 2 ) < pos ( 1 )) return read ( buffer ( pos ( 1 ): pos ( 2 )), fmt =* , iostat = E_IOD ) val if ( present ( E_IO )) E_IO = E_IOD !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_int subroutine get_char ( case , E_IO , buffer , attrib , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get character value of attribute 'attrib' defined into buffer. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), optional , intent ( IN ) :: case !< Attribute string case. integer ( I4P ), optional , intent ( OUT ) :: E_IO !< Error trapping flag. character ( len =* ), intent ( IN ) :: buffer !< String where to search the attrib character ( len =* ), intent ( IN ) :: attrib !< XML attribute id character ( len = :), allocatable , intent ( OUT ) :: val !< Returned string value integer :: pos ( 2 ) !< Position counter. integer :: E_IOD !< Dummy error trapping flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( E_IO )) E_IO = - 1_I4P if ( present ( case )) then if ( trim ( adjustlt ( Upper_Case ( case ))) == 'LOWER' ) then pos ( 1 ) = index ( buffer , trim ( adjustlt ( attrib )) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 else pos ( 1 ) = index ( buffer , trim ( adjustlt ( Upper_Case ( attrib ))) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 endif else pos ( 1 ) = index ( buffer , trim ( adjustlt ( Upper_Case ( attrib ))) // '=\"' ) + len_trim ( adjustlt ( attrib )) + 2 endif if ( pos ( 1 ) <= len_trim ( adjustlt ( attrib )) + 2 ) return pos ( 2 ) = index ( buffer ( pos ( 1 ): len_trim ( buffer )), '\"' ) + pos ( 1 ) - 2 if ( pos ( 2 ) < pos ( 1 )) return allocate ( character ( pos ( 2 ) - pos ( 1 ) + 1 ) :: val ) read ( buffer ( pos ( 1 ): pos ( 2 )), fmt = '(a)' , iostat = E_IOD ) val if ( present ( E_IO )) E_IO = E_IOD !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_char function read_record ( from , cf , buffer ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< read_record: read characters in the unit 'vtk(rf)%u' from position 'from' to read string 'buffer' !< The read action stops when finding a EOR character (char(10)) !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), optional , intent ( IN ) :: from !< Offset. integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). character ( len = :), allocatable , intent ( OUT ) :: buffer !< String containing the next record. integer ( I4P ) :: rf !< Real file index. integer ( i4P ) :: E_IO !< Error trapping flag. character :: c !< Dummy character storage. integer :: n , p !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif n = 1 buffer = '' if ( present ( from )) then p = from else inquire ( unit = vtk ( rf )% u , iostat = E_IO , pos = p ) endif read ( unit = vtk ( rf )% u , iostat = E_IO , pos = p ) c do while ( c /= end_rec ) buffer = buffer // c n = n + 1 read ( unit = vtk ( rf )% u , iostat = E_IO ) c ; if ( E_IO /= 0 ) exit enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction read_record function move ( to_find , repeat , cf , upper , inside , buffer ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Advance in VTK file inside the mark 'inside', until find the mark 'to_find', 'repeat' times. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), optional , intent ( IN ) :: to_find !< Searched XML element. integer , optional , intent ( IN ) :: repeat !< Number of repetitions. integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). logical , optional , intent ( IN ) :: upper !< True if return buffer in upper case. character ( len =* ), intent ( IN ) :: inside !< XML element where to search 'to_find'. character ( len = :), allocatable , intent ( OUT ) :: buffer !< String. integer ( I4P ) :: E_IO !< Error trapping flag. character ( len = :), allocatable :: buff !< Auxiliary buffer. integer ( I4P ) :: rf !< Real file index. logical :: up !< Readl upper case logical. integer ( I4P ) :: n !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif up = . true . if ( present ( upper )) up = upper do !search the beginnig of the mark 'inside' E_IO = read_record ( buffer = buffer , cf = rf ); if ( E_IO /= 0 ) exit if (. not . up ) buff = buffer buffer = trim ( adjustlt ( Upper_Case ( buffer ))) if ( index ( buffer , '<' // trim ( adjustlt ( Upper_Case ( inside )))) > 0 ) exit !Mark 'inside' founded once enddo if ( E_IO == 0 . and . present ( to_find )) then n = 1 ; if ( present ( repeat )) n = repeat do !search 'repeat' times the mark 'to_find' E_IO = read_record ( buffer = buffer , cf = rf ); if ( E_IO /= 0 ) exit if (. not . up ) buff = buffer buffer = trim ( adjustlt ( Upper_Case ( buffer ))) if ( index ( buffer , '</' // trim ( adjustlt ( Upper_Case ( inside )))) > 0 ) exit if ( index ( buffer , '<' // trim ( adjustlt ( Upper_Case ( to_find )))) > 0 ) n = n - 1 !Mark 'to_find' founded once if ( n == 0 ) exit !Mark 'to_find' founded 'repeat' times enddo if (. not . up ) buffer = buff if ( n > 0 ) E_IO = - 1_I4P endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction move function search ( cf , from , content , inside , to_find , with_attribute , of_value , buffer ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search in VTK file from position 'pos' inside the mark 'inside', until find the mark 'to_find', eventually, having !< attribute 'with_attribute' matching the value 'of_value'. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ), optional , intent ( IN ) :: from !< Offset. Start point. character ( len = :), optional , allocatable , intent ( OUT ) :: content !< String with the content inside 'to_find' element. character ( len =* ), intent ( IN ) :: inside !< XML element where to search 'to_find'. character ( len =* ), intent ( IN ) :: to_find !< Searched XML element. character ( len =* ), intent ( IN ) :: with_attribute !< XML attribute id. character ( len =* ), intent ( IN ) :: of_value !< Attribute value. character ( len = :), allocatable , intent ( INOUT ) :: buffer !< String. integer ( I4P ) :: rf !< Real file index integer ( I4P ) :: E_IO !< Error trapping flag. character ( len = :), allocatable :: strng !< String. integer ( I4P ) :: pos !< Positional counter. integer ( I4P ) :: p1 , p2 , p3 !< Positional counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif pos = 1 ; if ( present ( from )) pos = from if ( present ( content )) content = '' E_IO = read_record ( buffer = buffer , from = pos , cf = rf ); if ( E_IO /= 0 ) return do !search the beginnig of the mark 'inside' from position 'pos' buffer = trim ( adjustlt ( Upper_Case ( buffer ))) if ( index ( buffer , '<' // trim ( adjustlt ( Upper_Case ( inside )))) > 0 ) exit !Mark 'inside' founded once E_IO = read_record ( buffer = buffer ); if ( E_IO /= 0 ) exit enddo if ( E_IO == 0 ) then do !search 'repeat' times the mark 'to_find' E_IO = read_record ( buffer = buffer , cf = rf ); if ( E_IO /= 0 ) exit buffer = trim ( adjustlt ( Upper_Case ( buffer ))) if ( index ( buffer , '</' // trim ( adjustlt ( Upper_Case ( inside )))) > 0 ) then E_IO = - 1_I4P ; return ! Not found endif if ( index ( buffer , '<' // trim ( adjustlt ( Upper_Case ( to_find )))) > 0 ) then if ( len_trim ( of_value ) == 0 ) exit !there is no attribute value to seach call get_char ( buffer = buffer , attrib = with_attribute , val = strng , E_IO = E_IO ) if ( E_IO == 0 . and . trim ( adjustlt ( Upper_Case ( strng ))) == trim ( adjustlt ( Upper_Case ( of_value )))) then !Attribute match if ( present ( content ) . and . index ( buffer , '/>' ) == 0 ) then !the value p1 = index ( buffer , '<' // trim ( adjustlt ( Upper_Case ( to_find )))) p2 = index ( buffer , '>' ) p3 = index ( buffer , '</' // trim ( adjustlt ( Upper_Case ( to_find )))) ! Data in the same record if ( p1 /= 0 . and . p2 /= 0 . and . p3 /= 0 . and . p2 < p3 ) then content = buffer ( p2 + 1 : p3 - 1 ) elseif ( p1 == 0 . and . p3 /= 0 ) then E_IO = - 1_I4P else do E_IO = read_record ( buffer = strng , cf = rf ); if ( E_IO /= 0 ) exit if ( index ( trim ( adjustlt ( Upper_Case ( strng ))), '</' // trim ( adjustlt ( Upper_Case ( to_find )))) > 0 ) exit content = content // strng enddo endif endif exit endif endif enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction search endmodule Lib_VTK_IO_Back_End","tags":"","loc":"sourcefile/lib_vtk_io_back_end.f90.html","title":"Lib_VTK_IO_Back_End.f90 – Lib_VTK_IO"},{"text":"INI interface definition for Lib_VTK_IO. Source Code !< INI interface definition for Lib_VTK_IO. module Lib_VTK_IO_INI !----------------------------------------------------------------------------------------------------------------------------------- !< INI interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_INI !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_INI ( fformat , filename , title , mesh_topology , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing VTK-legacy file. !< !< @note This function must be the first to be called. !< !<### Usage !<```fortran !< E_IO=VTK_INI('Binary','example.vtk','VTK legacy file','UNSTRUCTURED_GRID') !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fformat !< Output format: ASCII or RAW. character ( * ), intent ( IN ) :: filename !< Name of file. character ( * ), intent ( IN ) :: title !< Title. character ( * ), intent ( IN ) :: mesh_topology !< Mesh topology. integer ( I4P ), intent ( OUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init call vtk_update ( act = 'add' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf vtk ( rf )% topology = trim ( mesh_topology ) select case ( trim ( Upper_Case ( fformat ))) case ( 'ASCII' ) vtk ( rf )% f = ascii open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ), form = 'FORMATTED' ,& access = 'SEQUENTIAL' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) ! writing header of file write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '# vtk DataFile Version 3.0' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( title ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( Upper_Case ( fformat )) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'DATASET ' // trim ( vtk ( rf )% topology ) case ( 'RAW' ) vtk ( rf )% f = raw open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ),& form = 'UNFORMATTED' , access = 'STREAM' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) ! writing header of file write ( unit = vtk ( rf )% u , iostat = E_IO ) '# vtk DataFile Version 3.0' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( title ) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( Upper_Case ( fformat )) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) 'DATASET ' // trim ( vtk ( rf )% topology ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI endmodule Lib_VTK_IO_INI","tags":"","loc":"sourcefile/lib_vtk_io_ini.f90.html","title":"Lib_VTK_IO_INI.f90 – Lib_VTK_IO"},{"text":"PVD_XML interface definitions for Lib_VTK_IO. Source Code !< PVD_XML interface definitions for Lib_VTK_IO. module Lib_VTK_IO_PVD_XML !----------------------------------------------------------------------------------------------------------------------------------- !< PVD_XML interface definitions for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: PVD_INI_XML public :: PVD_DAT_XML public :: PVD_END_XML !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface PVD_DAT_XML !< Procedure for saving data variable(s) in VTK-XML standard. !< !< PVD_DAT_XML is an interface to 6 different functions, depending on the datatype of the timestep !< !<### Examples of usage !< !<#### Calling PVD_DAT_XML !<```fortran !< integer(I4P):: timestep !< ... !< E_IO=PVD_DAT_XML('file.vtu,timestep) !< ... !<``` module procedure PVD_DAT_XML_R8 , PVD_DAT_XML_R4 , & ! real timesteps PVD_DAT_XML_I8 , PVD_DAT_XML_I4 , & ! integer (I8 and I4) timesteps PVD_DAT_XML_I2 , PVD_DAT_XML_I1 ! integer (I2 and I1) timesteps endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function PVD_INI_XML ( filename , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing a PVD-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< File name. integer ( I4P ), intent ( OUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init call vtk_update ( act = 'add' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf open ( unit = Get_Unit ( vtk ( rf )% u ), file = trim ( filename ),& form = 'FORMATTED' , access = 'SEQUENTIAL' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' if ( endian == endianL ) then s_buffer = '<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"BigEndian\">' endif write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Collection>' vtk ( rf )% indent = vtk ( rf )% indent + 2 end function PVD_INI_XML function PVD_DAT_XML_R8 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. real ( R8P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_R8 function PVD_DAT_XML_R4 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. real ( R4P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_R4 function PVD_DAT_XML_I8 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. integer ( I8P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_I8 function PVD_DAT_XML_I4 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. integer ( I4P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_I4 function PVD_DAT_XML_I2 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. integer ( I2P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_I2 function PVD_DAT_XML_I1 ( filename , timestep , part , cf ) result ( E_IO ) !group, part, cf) result(E_IO) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving of PVD data associated to the sequence of VTK files !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< Location of saving variables: CELL or NODE centered. integer ( I1P ), intent ( IN ) :: timestep !< Timestep index integer ( I4P ), intent ( IN ), optional :: part !< Part index integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: rp !< Real part index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif rp = 0 if ( present ( part )) rp = part write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & '<DataSet timestep=\"' // trim ( str ( n = timestep )) // '\" group=\"\" part=\"' // trim ( str ( n = rp )) // '\" file=\"' // trim ( filename ) // '\"/>' return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_DAT_XML_I1 function PVD_END_XML ( cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for finalizing the PVD-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( INOUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Collection>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' close ( unit = vtk ( rf )% u , iostat = E_IO ) call vtk_update ( act = 'remove' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf return !--------------------------------------------------------------------------------------------------------------------------------- end function PVD_END_XML endmodule Lib_VTK_IO_PVD_XML","tags":"","loc":"sourcefile/lib_vtk_io_pvd_xml.f90.html","title":"Lib_VTK_IO_PVD_XML.f90 – Lib_VTK_IO"},{"text":"GEO_XML interface definition for Lib_VTK_IO. Source Code !< GEO_XML interface definition for Lib_VTK_IO. module Lib_VTK_IO_GEO_XML !----------------------------------------------------------------------------------------------------------------------------------- !< GEO_XML interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_GEO_XML_WRITE public :: VTK_GEO_XML_READ !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTK_GEO_XML_WRITE !< Export (write) mesh with different topologies in VTK-XML standard. !< !< VTK_GEO_XML is an interface to 15 different functions; there are 2 functions for each of 3 topologies supported and a function !< for closing XML pieces: one function for mesh coordinates with R8P precision and one for mesh coordinates with R4P precision. !< 1D/3D-rank arrays and packed API for any kinds !< !<- For StructuredGrid there are 4 functions for each real kinds: !<    - inputs are 1D-rank arrays: X[1:NN],Y[1:NN],Z[1:NN]; !<    - inputs are 3D-rank arrays: X[nx1:nx2,ny1:ny2,nz1:nz2],Y[nx1:nx2,ny1:ny2,nz1:nz2],Z[nx1:nx2,ny1:ny2,nz1:nz2]; !<    - input is 1D-rank array (packed API): XYZ[1:3,1:NN]; !<    - input is 3D-rank array (packed API): XYZ[1:3,nx1:nx2,ny1:ny2,nz1:nz2]. !<- For UnStructuredGrid there are 2 functions for each real kinds: !<    - inputs are 1D arrays: X[1:NN],Y[1:NN],Z[1:NN]; !<    - input is 1D array (packed API): XYZ[1:3,1:NN]. !< !< VTK_GEO_XML must be called after VTK_INI_XML. It saves the mesh geometry. The inputs that must be passed !< change depending on the topologies chosen. Not all VTK topologies have been implemented (*polydata* topologies are absent). !< !< @note The XML standard is more powerful than legacy. XML file can contain more than 1 mesh with its !< associated variables. Thus there is the necessity to close each *pieces* that compose the data-set saved in the !< XML file. The VTK_GEO_XML called in the *close piece* format is used just to close the !< current piece before saving another piece or closing the file. !< !<### Examples of usage !< !<#### Structured grid calling !<```fortran !< integer(I4P):: nx1,nx2,ny1,ny2,nz1,nz2,NN !< real(R8P)::    X(1:NN),Y(1:NN),Z(1:NN) !< ... !< E_IO=VTK_GEO_XML(nx1,nx2,ny1,ny2,nz1,nz2,Nn,X,Y,Z) !<``` !< !<#### Rectilinear grid calling !<```fortran !< integer(I4P):: nx1,nx2,ny1,ny2,nz1,nz2 !< real(R8P)::    X(nx1:nx2),Y(ny1:ny2),Z(nz1:nz2) !< ... !< E_IO=VTK_GEO_XML(nx1,nx2,ny1,ny2,nz1,nz2,X,Y,Z) !<``` !< !<#### Unstructured grid calling !<```fortran !< integer(I4P):: Nn,Nc !< real(R8P)::    X(1:Nn),Y(1:Nn),Z(1:Nn) !< ... !< E_IO=VTK_GEO_XML(Nn,Nc,X,Y,Z) !<``` !< !<#### Closing piece calling !<```fortran !< E_IO=VTK_GEO_XML() !<``` module procedure VTK_GEO_XML_STRG_1DA_R8_WRITE , VTK_GEO_XML_STRG_3DA_R8_WRITE , & VTK_GEO_XML_STRG_1DAP_R8_WRITE , VTK_GEO_XML_STRG_3DAP_R8_WRITE , & VTK_GEO_XML_STRG_1DA_R4_WRITE , VTK_GEO_XML_STRG_3DA_R4_WRITE , & VTK_GEO_XML_STRG_1DAP_R4_WRITE , VTK_GEO_XML_STRG_3DAP_R4_WRITE , & VTK_GEO_XML_RECT_R8_WRITE , & VTK_GEO_XML_RECT_R4_WRITE , & VTK_GEO_XML_UNST_R8_WRITE , VTK_GEO_XML_UNST_PACK_R4_WRITE , & VTK_GEO_XML_UNST_R4_WRITE , VTK_GEO_XML_UNST_PACK_R8_WRITE , & VTK_GEO_XML_CLOSEP_WRITE endinterface interface VTK_GEO_XML_READ !< Import (read) mesh with different topologies in VTK-XML standard. !< !< VTK_GEO_XML_READ is an interface to 14 different functions; there are 2 functions for each of 3 topologies supported and a !< function for closing XML pieces: one function for mesh coordinates with R8P (Ok!) precision and one for mesh coordinates with !< R4P (Not tested!) precision. 1D/3D-rank arrays and packed API for ascii and raw data, binary is not implemented yet! !< !<- For StructuredGrid there are 4 functions for each real kinds: !<    - inputs are 1D-rank arrays: X[1:NN],Y[1:NN],Z[1:NN]; (Not tested!) !<    - inputs are 3D-rank arrays: X[nx1:nx2,ny1:ny2,nz1:nz2],Y[nx1:nx2,ny1:ny2,nz1:nz2],Z[nx1:nx2,ny1:ny2,nz1:nz2]; (Not tested!) !<    - input is 1D-rank array (packed API): XYZ[1:3,1:NN]; (Not tested!) !<    - input is 3D-rank array (packed API): XYZ[1:3,nx1:nx2,ny1:ny2,nz1:nz2]. (Not tested!) !<- For UnStructuredGrid there are 2 functions for each real kinds: !<    - inputs are 1D arrays: X[1:NN],Y[1:NN],Z[1:NN]; (Ok!) !<    - input is 1D array (packed API): XYZ[1:3,1:NN]. (Not tested!) !< !< VTK_GEO_XML_READ must be called after VTK_INI_XML_READ. It reads the mesh geometry. The inputs that must be passed !< change depending on the topologies chosen. Not all VTK topologies have been implemented (*polydata* topologies are absent). !< !< @note The XML standard is more powerful than legacy. XML file can contain more than 1 mesh with its !< associated variables. Thus there is the necessity to close each *pieces* that compose the data-set saved in the !< XML file. The VTK_GEO_XML_READ uses the *close piece* format is used just to close the !< current piece before saving another piece or closing the file. !< !<### Examples of usage module procedure VTK_GEO_XML_STRG_1DA_R8_READ , VTK_GEO_XML_STRG_3DA_R8_READ , & VTK_GEO_XML_STRG_1DAP_R8_READ , VTK_GEO_XML_STRG_3DAP_R8_READ , & VTK_GEO_XML_STRG_1DA_R4_READ , VTK_GEO_XML_STRG_3DA_R4_READ , & VTK_GEO_XML_STRG_1DAP_R4_READ , VTK_GEO_XML_STRG_3DAP_R4_READ , & VTK_GEO_XML_RECT_R8_READ , & VTK_GEO_XML_RECT_R4_READ , & VTK_GEO_XML_UNST_R8_READ , VTK_GEO_XML_UNST_PACK_R4_READ , & VTK_GEO_XML_UNST_R4_READ , VTK_GEO_XML_UNST_PACK_R8_READ endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains ! exporters function VTK_GEO_XML_STRG_1DA_R8_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: X ( 1 :) !< X coordinates [1:NN]. real ( R8P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates [1:NN]. real ( R8P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I1P ), allocatable :: XYZp (:) !< Packed coordinates data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = [( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN )], packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_1DA_R8_WRITE function VTK_GEO_XML_STRG_3DA_R8_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: X ( nx1 :, ny1 :, nz1 :) !< X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real ( R8P ), intent ( IN ) :: Y ( nx1 :, ny1 :, nz1 :) !< Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real ( R8P ), intent ( IN ) :: Z ( nx1 :, ny1 :, nz1 :) !< Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Error trapping flag. integer ( I1P ), allocatable :: XYZp (:) !< Packed coordinates data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = nz1 , nz2 do ny = ny1 , ny2 do nx = nx1 , nx2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = X ( nx , ny , nz )) // ' ' // str ( n = Y ( nx , ny , nz )) // ' ' // str ( n = Z ( nx , ny , nz )) enddo enddo enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )((( X ( nx , ny , nz ), Y ( nx , ny , nz ), Z ( nx , ny , nz ), nx = nx1 , nx2 ), ny = ny1 , ny2 ), nz = nz1 , nz2 ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = [((( X ( nx , ny , nz ), Y ( nx , ny , nz ), Z ( nx , ny , nz ), nx = nx1 , nx2 ), ny = ny1 , ny2 ), nz = nz1 , nz2 )],& packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_3DA_R8_WRITE function VTK_GEO_XML_STRG_1DAP_R8_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y, Z coordinates (packed API) [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I1P ), allocatable :: XYZp (:) !< Packed coordinates data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = reshape ( XYZ ,[ 3 * NN ]), packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_1DAP_R8_WRITE function VTK_GEO_XML_STRG_3DAP_R8_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R8P ), intent ( IN ) :: XYZ ( 1 :, nx1 :, ny1 :, nz1 :) !< X, Y, Z coordinates (packed API). integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Error trapping flag. integer ( I1P ), allocatable :: XYZp (:) !< Packed coordinates data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = nz1 , nz2 do ny = ny1 , ny2 do nx = nx1 , nx2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , nx , ny , nz )) // ' ' // str ( n = XYZ ( 2 , nx , ny , nz )) // ' ' // str ( n = XYZ ( 3 , nx , ny , nz )) enddo enddo enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = reshape ( XYZ ,[ 3 * NN ]), packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_3DAP_R8_WRITE function VTK_GEO_XML_STRG_1DA_R4_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: X ( 1 :) !< X coordinates [1:NN]. real ( R4P ), intent ( IN ) :: Y ( 1 :) !< Y coordinates [1:NN]. real ( R4P ), intent ( IN ) :: Z ( 1 :) !< Z coordinates [1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = [( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN )], packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_1DA_R4_WRITE function VTK_GEO_XML_STRG_3DA_R4_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: X ( nx1 :, ny1 :, nz1 :) !< X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real ( R4P ), intent ( IN ) :: Y ( nx1 :, ny1 :, nz1 :) !< Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real ( R4P ), intent ( IN ) :: Z ( nx1 :, ny1 :, nz1 :) !< Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Error trapping flag. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = nz1 , nz2 do ny = ny1 , ny2 do nx = nx1 , nx2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = X ( nx , ny , nz )) // ' ' // str ( n = Y ( nx , ny , nz )) // ' ' // str ( n = Z ( nx , ny , nz )) enddo enddo enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )((( X ( nx , ny , nz ), Y ( nx , ny , nz ), Z ( nx , ny , nz ), nx = nx1 , nx2 ), ny = ny1 , ny2 ), nz = nz1 , nz2 ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = [((( X ( nx , ny , nz ), Y ( nx , ny , nz ), Z ( nx , ny , nz ), nx = nx1 , nx2 ), ny = ny1 , ny2 ), nz = nz1 , nz2 )], & packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_3DA_R4_WRITE function VTK_GEO_XML_STRG_1DAP_R4_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: XYZ ( 1 :, 1 :) !< X, Y, Z coordinates (packed API) [1:3,1:NN]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = reshape ( XYZ ,[ 3 * NN ]), packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_1DAP_R4_WRITE function VTK_GEO_XML_STRG_3DAP_R4_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( IN ) :: NN !< Number of all nodes. real ( R4P ), intent ( IN ) :: XYZ ( 1 :, nx1 :, ny1 :, nz1 :) !< X, Y, Z coordinates (packed API) [1:3,nx1:nx2,ny1:ny2,nz1:nz2]. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Error trapping flag. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: nx , ny , nz !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do nz = nz1 , nz2 do ny = ny1 , ny2 do nx = nx1 , nx2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , nx , ny , nz )) // ' ' // str ( n = XYZ ( 2 , nx , ny , nz )) // ' ' // str ( n = XYZ ( 3 , nx , ny , nz )) enddo enddo enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = reshape ( XYZ ,[ 3 * NN ]), packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_3DAP_R4_WRITE function VTK_GEO_XML_RECT_R8_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b RectilinearGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. real ( R8P ), intent ( IN ) :: X ( nx1 : nx2 ) !< X coordinates. real ( R8P ), intent ( IN ) :: Y ( ny1 : ny2 ) !< Y coordinates. real ( R8P ), intent ( IN ) :: Z ( nz1 : nz2 ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"X\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR8P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Y\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR8P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Z\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR8P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"X\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( nx2 - nx1 + 1 ) * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' ,( nx2 - nx1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Y\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( ny2 - ny1 + 1 ) * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' ,( ny2 - ny1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Z\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( nz2 - nz1 + 1 ) * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' ,( nz2 - nz1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"X\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( nx2 - nx1 + 1 ) * BYR8P , I4P )], a2 = X , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Y\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( ny2 - ny1 + 1 ) * BYR8P , I4P )], a2 = Y , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" Name=\"Z\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( nz2 - nz1 + 1 ) * BYR8P , I4P )], a2 = Z , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R8_WRITE function VTK_GEO_XML_RECT_R4_WRITE ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b RectilinearGrid topology (R4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( IN ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( IN ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( IN ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( IN ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( IN ) :: nz2 !< Final node of z axis. real ( R4P ), intent ( IN ) :: X ( nx1 : nx2 ) !< X coordinates. real ( R4P ), intent ( IN ) :: Y ( ny1 : ny2 ) !< Y coordinates. real ( R4P ), intent ( IN ) :: Z ( nz1 : nz2 ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"X\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR4P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Y\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR4P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Z\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = FR4P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"X\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( nx2 - nx1 + 1 ) * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' ,( nx2 - nx1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Y\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( ny2 - ny1 + 1 ) * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' ,( ny2 - ny1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Z\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = ( nz2 - nz1 + 1 ) * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' ,( nz2 - nz1 + 1 ) write ( unit = vtk ( rf )% ua , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece Extent=\"' // trim ( str ( n = nx1 )) // ' ' // trim ( str ( n = nx2 )) // ' ' // & trim ( str ( n = ny1 )) // ' ' // trim ( str ( n = ny2 )) // ' ' // & trim ( str ( n = nz1 )) // ' ' // trim ( str ( n = nz2 )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Coordinates>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"X\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( nx2 - nx1 + 1 ) * BYR4P , I4P )], a2 = X , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Y\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( ny2 - ny1 + 1 ) * BYR4P , I4P )], a2 = Y , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" Name=\"Z\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call pack_data ( a1 = [ int (( nz2 - nz1 + 1 ) * BYR4P , I4P )], a2 = Z , packed = XYZp ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R4_WRITE function VTK_GEO_XML_UNST_R8_WRITE ( NN , NC , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. integer ( I4P ), intent ( IN ) :: NC !< Number of cells. real ( R8P ), intent ( IN ) :: X ( 1 : NN ) !< X coordinates. real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) !< Y coordinates. real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R8P ), allocatable :: XYZa (:) !< X, Y, Z coordinates. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( XYZa ( 1 : 3 * NN )) do n1 = 1 , NN XYZa ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ X ( n1 ), Y ( n1 ), Z ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = XYZa , packed = XYZp ) ; deallocate ( XYZa ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R8_WRITE function VTK_GEO_XML_UNST_PACK_R8_WRITE ( NN , NC , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b UnstructuredGrid topology (R8P, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. integer ( I4P ), intent ( IN ) :: NC !< Number of cells. real ( R8P ), intent ( IN ) :: XYZ ( 1 : 3 , 1 : NN ) !< X, Y, Z coordinates (packed API). integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R8P ), allocatable :: XYZa (:) !< X, Y, Z coordinates. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR8P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R8' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( XYZa ( 1 : 3 * NN )) do n1 = 1 , NN XYZa ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = XYZ ( 1 : 3 , n1 ) enddo call pack_data ( a1 = [ int ( 3 * NN * BYR8P , I4P )], a2 = XYZa , packed = XYZp ) ; deallocate ( XYZa ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_PACK_R8_WRITE function VTK_GEO_XML_UNST_R4_WRITE ( NN , NC , X , Y , Z , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b UnstructuredGrid topology (R4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. integer ( I4P ), intent ( IN ) :: NC !< Number of cells. real ( R4P ), intent ( IN ) :: X ( 1 : NN ) !< X coordinates. real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) !< Y coordinates. real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) !< Z coordinates. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R4P ), allocatable :: XYZa (:) !< X, Y, Z coordinates. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // str ( n = X ( n1 )) // ' ' // str ( n = Y ( n1 )) // ' ' // str ( n = Z ( n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( XYZa ( 1 : 3 * NN )) do n1 = 1 , NN XYZa ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = [ X ( n1 ), Y ( n1 ), Z ( n1 )] enddo call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = XYZa , packed = XYZp ) ; deallocate ( XYZa ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R4_WRITE function VTK_GEO_XML_UNST_PACK_R4_WRITE ( NN , NC , XYZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh with \\b UnstructuredGrid topology (R4P, packed API). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: NN !< Number of nodes. integer ( I4P ), intent ( IN ) :: NC !< Number of cells. real ( R4P ), intent ( IN ) :: XYZ ( 1 : 3 , 1 : NN ) !< X, Y, Z coordinates (packed API). integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. real ( R4P ), allocatable :: XYZa (:) !< X, Y, Z coordinates. integer ( I1P ), allocatable :: XYZp (:) !< Packed data. character ( len = :), allocatable :: XYZ64 !< X, Y, Z coordinates encoded in base64. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"ascii\">' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) do n1 = 1 , NN write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // & str ( n = XYZ ( 1 , n1 )) // ' ' // str ( n = XYZ ( 2 , n1 )) // ' ' // str ( n = XYZ ( 3 , n1 )) enddo write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' ; vtk ( rf )% indent = vtk ( rf )% indent - 2 write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' case ( raw , bin_app ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"appended\" offset=\"' // & trim ( str (. true ., vtk ( rf )% ioffset )) // '\"/>' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec call vtk ( rf )% byte_update ( N_Byte = 3 * NN * BYR4P ) write ( unit = vtk ( rf )% ua , iostat = E_IO ) vtk ( rf )% N_Byte , 'R4' , 3 * NN write ( unit = vtk ( rf )% ua , iostat = E_IO ) XYZ vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec case ( binary ) s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<Piece NumberOfPoints=\"' // trim ( str ( n = NN )) // '\" NumberOfCells=\"' // trim ( str ( n = NC )) // '\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '<Points>' // end_rec ; vtk ( rf )% indent = vtk ( rf )% indent + 2 s_buffer = repeat ( ' ' , vtk ( rf )% indent ) // '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Points\" format=\"binary\">' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec allocate ( XYZa ( 1 : 3 * NN )) do n1 = 1 , NN XYZa ( 1 + ( n1 - 1 ) * 3 : 1 + ( n1 - 1 ) * 3 + 2 ) = XYZ ( 1 : 3 , n1 ) enddo call pack_data ( a1 = [ int ( 3 * NN * BYR4P , I4P )], a2 = XYZa , packed = XYZp ) ; deallocate ( XYZa ) call b64_encode ( n = XYZp , code = XYZ64 ) ; deallocate ( XYZp ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent + 2 ) // XYZ64 // end_rec ; deallocate ( XYZ64 ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</DataArray>' // end_rec vtk ( rf )% indent = vtk ( rf )% indent - 2 ; write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_PACK_R4_WRITE function VTK_GEO_XML_CLOSEP_WRITE ( cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for closing mesh block data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif vtk ( rf )% indent = vtk ( rf )% indent - 2 select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Piece>' case ( raw , binary , bin_app ) write ( unit = vtk ( rf )% u , iostat = E_IO ) repeat ( ' ' , vtk ( rf )% indent ) // '</Piece>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_CLOSEP_WRITE ! importers function VTK_GEO_XML_STRG_1DA_R8_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R8P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R8P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R8P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) do i = 1 , NN ; X ( i ) = XYZp ( i * 3 - 2 ); Y ( i ) = XYZp ( i * 3 - 1 ); Z ( i ) = XYZp ( i * 3 ); enddo if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_1DA_R8_READ function VTK_GEO_XML_STRG_3DA_R8_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R8P ), allocatable , intent ( OUT ) :: X (:,:,:) !< x coordinates real ( R8P ), allocatable , intent ( OUT ) :: Y (:,:,:) !< y coordinates real ( R8P ), allocatable , intent ( OUT ) :: Z (:,:,:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , k , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ((( X ( i , j , k ), Y ( i , j , k ), Z ( i , j , k ), i = nx1 , nx2 ), j = ny1 , ny2 ), k = nz1 , nz2 ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) s = 1 ; do k = nz1 , nz2 - nz1 ; do j = ny1 , ny2 ; do i = nx1 , nx2 ; X ( i , j , k ) = XYZp ( s ); s = s + 1 ; Y ( i , j , k ) = XYZp ( s ); s = s + 1 ; Z ( i , j , k ) = XYZp ( s ); s = s + 1 enddo ; enddo ; enddo ; if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , & ((( X ( i , j , k ), Y ( i , j , k ), Z ( i , j , k ), i = nx1 , nx2 ), j = ny1 , ny2 ), k = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_3DA_R8_READ function VTK_GEO_XML_STRG_1DAP_R8_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R8P ), allocatable , intent ( OUT ) :: XYZ (:,:) !< x coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , NN ), stat = E_IO ) XYZ = reshape ( XYZp ,( / 3 , NN / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_1DAP_R8_READ function VTK_GEO_XML_STRG_3DAP_R8_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R8P ), allocatable , intent ( OUT ) :: XYZ (:,:,:,:) !< x coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , k , l , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (((( XYZ ( i , j , k , l ), i = 1 , 3 ), j = nx1 , nx2 ), k = ny1 , ny2 ), l = nz1 , nz2 ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) XYZ ( 1 : 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) = reshape ( XYZp , ( / 3 , nx2 - nx1 + 1 , ny2 - ny1 + 1 , nz2 - nz1 + 1 / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , & (((( XYZ ( i , j , k , l ), i = 1 , 3 ), j = nx1 , nx2 ), k = ny1 , ny2 ), l = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_3DAP_R8_READ function VTK_GEO_XML_STRG_1DA_R4_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R4P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R4P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R4P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) do i = 1 , NN ; X ( i ) = XYZp ( i * 3 - 2 ); Y ( i ) = XYZp ( i * 3 - 1 ); Z ( i ) = XYZp ( i * 3 ); enddo if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_1DA_R4_READ function VTK_GEO_XML_STRG_3DA_R4_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R4P ), allocatable , intent ( OUT ) :: X (:,:,:) !< x coordinates real ( R4P ), allocatable , intent ( OUT ) :: Y (:,:,:) !< y coordinates real ( R4P ), allocatable , intent ( OUT ) :: Z (:,:,:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , k , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ((( X ( i , j , k ), Y ( i , j , k ), Z ( i , j , k ), i = nx1 , nx2 ), j = ny1 , ny2 ), k = nz1 , nz2 ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) s = 1 ; do k = nz1 , nz2 - nz1 ; do j = ny1 , ny2 ; do i = nx1 , nx2 ; X ( i , j , k ) = XYZp ( s ); s = s + 1 ; Y ( i , j , k ) = XYZp ( s ); s = s + 1 ; Z ( i , j , k ) = XYZp ( s ); s = s + 1 enddo ; enddo ; enddo ; if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), Z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , & ((( X ( i , j , k ), Y ( i , j , k ), Z ( i , j , k ), i = nx1 , nx2 ), j = ny1 , ny2 ), k = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function function VTK_GEO_XML_STRG_1DAP_R4_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R4P ), allocatable , intent ( OUT ) :: XYZ (:,:) !< x coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , NN ), stat = E_IO ) XYZ = reshape ( XYZp ,( / 3 , NN / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_1DAP_R4_READ function VTK_GEO_XML_STRG_3DAP_R4_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. integer ( I4P ), intent ( OUT ) :: NN !< Number of nodes real ( R4P ), allocatable , intent ( OUT ) :: XYZ (:,:,:,:) !< x coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , k , l , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (((( XYZ ( i , j , k , l ), i = 1 , 3 ), j = nx1 , nx2 ), k = ny1 , ny2 ), l = nz1 , nz2 ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) XYZ ( 1 : 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) = reshape ( XYZp , ( / 3 , nx2 - nx1 + 1 , ny2 - ny1 + 1 , nz2 - nz1 + 1 / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'StructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then NN = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , & (((( XYZ ( i , j , k , l ), i = 1 , 3 ), j = nx1 , nx2 ), k = ny1 , ny2 ), l = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_STRG_3DAP_R4_READ function VTK_GEO_XML_RECT_R8_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. real ( R8P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R8P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R8P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt , fmtX , fmtY , fmtZ character ( len = :), allocatable :: type , typeX , typeY , typeZ character ( len = :), allocatable :: data integer ( I4P ) :: offsX , offsY , offsZ integer ( I4P ) :: np , i , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), i = nx1 , nx2 ) !get X ascii array endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( Y ( ny1 : ny2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( Y ( i ), i = ny1 , ny2 ) !get Y ascii array endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( Z ( nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( Z ( i ), i = nz1 , nz2 ) !get Z ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( nx1 : nx2 ), stat = E_IO ) X ( nx1 : nx2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( Y ( ny1 : ny2 ), stat = E_IO ) Y ( ny1 : ny2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( Z ( nz1 : nz2 ), stat = E_IO ) Z ( nz1 : nz2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif if ( allocated ( data )) deallocate ( data ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsX , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtX , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeX , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsY , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtY , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeY , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsZ , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtZ , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeZ , E_IO = E_IO ) if ( E_IO == 0 ) then if ( trim ( adjustlt ( Upper_Case ( fmtX ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( fmtY ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( fmtZ ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( typeX ))) /= 'FLOAT64' . or . & trim ( adjustlt ( Upper_Case ( typeY ))) /= 'FLOAT64' . or . & trim ( adjustlt ( Upper_Case ( typeZ ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 ), Y ( ny1 : ny2 ), Z ( nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsX ) N_Byte , ( X ( i ), i = nx1 , nx2 ) !get appended array read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsY ) N_Byte , ( Y ( i ), i = ny1 , ny2 ) !get appended array read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsZ ) N_Byte , ( Z ( i ), i = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_RECT_R8_READ function VTK_GEO_XML_RECT_R4_READ ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: nx1 !< Initial node of x axis. integer ( I4P ), intent ( OUT ) :: nx2 !< Final node of x axis. integer ( I4P ), intent ( OUT ) :: ny1 !< Initial node of y axis. integer ( I4P ), intent ( OUT ) :: ny2 !< Final node of y axis. integer ( I4P ), intent ( OUT ) :: nz1 !< Initial node of z axis. integer ( I4P ), intent ( OUT ) :: nz2 !< Final node of z axis. real ( R4P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R4P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R4P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: aux !< Auxiliary string. character ( len = :), allocatable :: fmt , fmtX , fmtY , fmtZ character ( len = :), allocatable :: type , typeX , typeY , typeZ character ( len = :), allocatable :: data integer ( I4P ) :: offsX , offsY , offsZ integer ( I4P ) :: np , i , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), i = nx1 , nx2 ) !get X ascii array endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( Y ( ny1 : ny2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( Y ( i ), i = ny1 , ny2 ) !get Y ascii array endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( Z ( nz1 : nz2 ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( Z ( i ), i = nz1 , nz2 ) !get Z ascii array endif if ( allocated ( data )) deallocate ( data ) endif endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 if ( E_IO == 0 ) then E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( nx1 : nx2 ), stat = E_IO ) X ( nx1 : nx2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( Y ( ny1 : ny2 ), stat = E_IO ) Y ( ny1 : ny2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * (( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )) * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( Z ( nz1 : nz2 ), stat = E_IO ) Z ( nz1 : nz2 ) = XYZp (:) if ( allocated ( XYZp )) deallocate ( XYZp ) endif if ( allocated ( data )) deallocate ( data ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'RectilinearGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_char ( buffer = s_buffer , attrib = 'Extent' , val = aux , E_IO = E_IO ) if ( E_IO == 0 ) then read ( aux , * , iostat = E_IO ) nx1 , nx2 , ny1 , ny2 , nz1 , nz2 E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'X' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsX , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtX , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeX , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Y' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsY , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtY , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeY , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Coordinates' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Z' , buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offsZ , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmtZ , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = typeZ , E_IO = E_IO ) if ( E_IO == 0 ) then if ( trim ( adjustlt ( Upper_Case ( fmtX ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( fmtY ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( fmtZ ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( typeX ))) /= 'FLOAT32' . or . & trim ( adjustlt ( Upper_Case ( typeY ))) /= 'FLOAT32' . or . & trim ( adjustlt ( Upper_Case ( typeZ ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( nx1 : nx2 ), Y ( ny1 : ny2 ), Z ( nz1 : nz2 ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsX ) N_Byte , ( X ( i ), i = nx1 , nx2 ) !get appended array read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsY ) N_Byte , ( Y ( i ), i = ny1 , ny2 ) !get appended array read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offsZ ) N_Byte , ( Z ( i ), i = nz1 , nz2 ) !get appended array endif endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_RECT_R4_READ function VTK_GEO_XML_UNST_R8_READ ( NN , NC , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: NN !< number of nodes integer ( I4P ), intent ( OUT ) :: NC !< number of cells real ( R8P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R8P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R8P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P !stop 'Format not implemented' else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) do i = 1 , NN ; X ( i ) = XYZp ( i * 3 - 2 ); Y ( i ) = XYZp ( i * 3 - 1 ); Z ( i ) = XYZp ( i * 3 ); enddo if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get appended array endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_UNST_R8_READ function VTK_GEO_XML_UNST_PACK_R8_READ ( NN , NC , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: NN !< number of nodes integer ( I4P ), intent ( OUT ) :: NC !< number of cells real ( R8P ), allocatable , intent ( OUT ) :: XYZ (:,:) !< Coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R8P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P !stop 'Format not implemented' else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR8P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR8P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , NN ), stat = E_IO ) XYZ = reshape ( XYZp ,( / 3 , NN / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT64' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get appended array endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_UNST_PACK_R8_READ function VTK_GEO_XML_UNST_R4_READ ( NN , NC , X , Y , Z , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: NN !< number of nodes integer ( I4P ), intent ( OUT ) :: NC !< number of cells real ( R4P ), allocatable , intent ( OUT ) :: X (:) !< x coordinates real ( R4P ), allocatable , intent ( OUT ) :: Y (:) !< y coordinates real ( R4P ), allocatable , intent ( OUT ) :: Z (:) !< z coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P !stop 'Format not implemented' else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) do i = 1 , NN ; X ( i ) = XYZp ( i * 3 - 2 ); Y ( i ) = XYZp ( i * 3 - 1 ); Z ( i ) = XYZp ( i * 3 ); enddo if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( X ( NN ), Y ( NN ), Z ( NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , ( X ( i ), Y ( i ), Z ( i ), i = 1 , NN ) !get appended array endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_UNST_R4_READ function VTK_GEO_XML_UNST_PACK_R4_READ ( NN , NC , XYZ , npiece , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for reading mesh with \\b UnstructuredGrid topology (R8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( OUT ) :: NN !< number of nodes integer ( I4P ), intent ( OUT ) :: NC !< number of cells real ( R4P ), allocatable , intent ( OUT ) :: XYZ (:,:) !< Coordinates integer ( I4P ), optional , intent ( IN ) :: npiece !< Number of the piece to read (by default: 1) integer ( I4P ), optional , intent ( IN ) :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: rf !< Real file index. character ( len = :), allocatable :: s_buffer !< Buffer string. character ( len = :), allocatable :: fmt character ( len = :), allocatable :: type character ( len = :), allocatable :: data integer ( I4P ) :: np , i , j , offs , N_Byte , pos , s integer ( I1P ), allocatable :: dI1P (:) real ( R4P ), allocatable :: XYZp (:) !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- rf = f if ( present ( cf )) then rf = cf ; f = cf endif np = 1_I4P ; if ( present ( npiece )) np = npiece E_IO = - 1_I4P select case ( vtk ( rf )% f ) case ( ascii ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'ASCII' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( data , fmt =* , iostat = E_IO ) (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get ascii array endif if ( allocated ( data )) deallocate ( data ) endif case ( binary ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer , content = data ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'BINARY' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P !stop 'Format not implemented' else ! Decode base64 packed data data = trim ( adjustlt ( data )) allocate ( dI1P ( 3 * NN * int ( BYR4P , I4P ) + int ( BYI4P , I4P ))) call b64_decode ( code = data , n = dI1P ); if ( allocated ( data )) deallocate ( data ) ! Unpack data [1xI4P,3*NNxR4P] N_byte = transfer ( dI1P ( 1 : int ( BYI4P , I4P )), N_byte ) s = size ( transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp )); allocate ( XYZp ( 1 : s )) XYZp = transfer ( dI1P ( int ( BYI4P , I4P ) + 1 :), XYZp ); if ( allocated ( dI1P )) deallocate ( dI1P ) allocate ( XYZ ( 3 , NN ), stat = E_IO ) XYZ = reshape ( XYZp ,( / 3 , NN / )) if ( allocated ( XYZp )) deallocate ( XYZp ) endif endif case ( raw ) rewind ( unit = vtk ( rf )% u , iostat = E_IO ) E_IO = move ( inside = 'UnstructuredGrid' , to_find = 'Piece' , repeat = np , cf = rf , buffer = s_buffer ) ! find the 'np' piece inquire ( unit = vtk ( rf )% u , pos = pos , iostat = E_IO ) !annotate the current position in the file call get_int ( buffer = s_buffer , attrib = 'NumberOfPoints' , val = NN , E_IO = E_IO ) if ( E_IO == 0 ) then call get_int ( buffer = s_buffer , attrib = 'NumberOfCells' , val = NC , E_IO = E_IO ) E_IO = search ( from = pos , inside = 'Points' , to_find = 'DataArray' , with_attribute = 'Name' , of_value = 'Points' , & buffer = s_buffer ) call get_int ( buffer = s_buffer , attrib = 'offset' , val = offs , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'format' , val = fmt , E_IO = E_IO ) call get_char ( buffer = s_buffer , attrib = 'type' , val = type , E_IO = E_IO ) if ( trim ( adjustlt ( Upper_Case ( fmt ))) /= 'APPENDED' . or . & trim ( adjustlt ( Upper_Case ( type ))) /= 'FLOAT32' ) then E_IO = - 1_I4P else allocate ( XYZ ( 3 , NN ), stat = E_IO ) read ( unit = vtk ( rf )% u , iostat = E_IO , pos = vtk ( rf )% ioffset + offs ) N_Byte , (( XYZ ( i , j ), i = 1 , 3 ), j = 1 , NN ) !get appended array endif endif end select !--------------------------------------------------------------------------------------------------------------------------------- end function VTK_GEO_XML_UNST_PACK_R4_READ endmodule Lib_VTK_IO_GEO_XML","tags":"","loc":"sourcefile/lib_vtk_io_geo_xml.f90.html","title":"Lib_VTK_IO_GEO_XML.f90 – Lib_VTK_IO"},{"text":"END interface definition for Lib_VTK_IO. Source Code !< END interface definition for Lib_VTK_IO. module Lib_VTK_IO_END !----------------------------------------------------------------------------------------------------------------------------------- !< END interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_END !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_END ( cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for finalizing the VTK-XML file. !< !<### Usage !<```fortran !< E_IO = VTK_END() !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( INOUT ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif close ( unit = vtk ( rf )% u , iostat = E_IO ) call vtk_update ( act = 'remove' , cf = rf , Nvtk = Nvtk , vtk = vtk ) f = rf if ( present ( cf )) cf = rf return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END endmodule Lib_VTK_IO_END","tags":"","loc":"sourcefile/lib_vtk_io_end.f90.html","title":"Lib_VTK_IO_END.f90 – Lib_VTK_IO"},{"text":"CON interface definition for Lib_VTK_IO. Source Code !< CON interface definition for Lib_VTK_IO. module Lib_VTK_IO_CON !----------------------------------------------------------------------------------------------------------------------------------- !< CON interface definition for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_CON !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_CON ( NC , connect , cell_type , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving mesh connectivity. !< !< Function that **must** be used when unstructured grid is used, it saves the connectivity of the unstructured gird. !< @note The vector **connect** must follow the VTK-legacy standard. It is passed as *assumed-shape* array !< because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following !< equation: dc = NC + \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i } !< where dc is connectivity vector dimension and nvertex_i is the number of vertices of i&#94;{th} cell. The VTK- !< legacy standard for the mesh connectivity is quite obscure at least at first sight. It is more simple analyzing an example. !< Suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices) and !< suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices. !< The above equation !> gives dc=2+8+5=15. The connectivity vector for this mesh can be: !< !<##### first cell !<+ connect(1)  = 8 number of vertices of first cell !<+ connect(2)  = 0 identification flag of 1&#94;\\circ vertex of first cell !<+ connect(3)  = 1 identification flag of 2&#94;\\circ vertex of first cell !<+ connect(4)  = 2 identification flag of 3&#94;\\circ vertex of first cell !<+ connect(5)  = 3 identification flag of 4&#94;\\circ vertex of first cell !<+ connect(6)  = 4 identification flag of 5&#94;\\circ vertex of first cell !<+ connect(7)  = 5 identification flag of 6&#94;\\circ vertex of first cell !<+ connect(8)  = 6 identification flag of 7&#94;\\circ vertex of first cell !<+ connect(9)  = 7 identification flag of 8&#94;\\circ vertex of first cell !< !<##### second cell !<+ connect(10) = 5 number of vertices of first cell !<+ connect(11) = 0 identification flag of 1&#94;\\circ vertex of second cell !<+ connect(12) = 1 identification flag of 2&#94;\\circ vertex of second cell !<+ connect(13) = 2 identification flag of 3&#94;\\circ vertex of second cell !<+ connect(14) = 3 identification flag of 4&#94;\\circ vertex of second cell !<+ connect(15) = 8 identification flag of 5&#94;\\circ vertex of second cell !< !< Note that the first 4 identification flags of pyramid vertices as the same of the first 4 identification flags of !< the hexahedron because the two cells share this face. It is also important to note that the identification flags start !< form $0$ value: this is impose to the VTK standard. The function VTK_CON does not calculate the connectivity vector: it !< writes the connectivity vector conforming the VTK standard, but does not calculate it. !< The vector variable *cell\\_type* must conform the VTK-legacy standard (see the file VTK-Standard at the !< Kitware homepage). It contains the *type* of each cells. For the above example this vector is: !< !<##### first cell !< cell_type(1) = 12 hexahedron type of first cell !< !<##### second cell !< cell_type(2) = 14 pyramid type of second cell !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC !< Number of cells. integer ( I4P ), intent ( IN ) :: connect (:) !< Mesh connectivity. integer ( I4P ), intent ( IN ) :: cell_type ( 1 : NC ) !< VTK cell type. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: ncon !< Dimension of connectivity vector. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif ncon = size ( connect , 1 ) select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = vtk ( rf )% u , fmt = FI4P , iostat = E_IO ) connect write ( unit = vtk ( rf )% u , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = vtk ( rf )% u , fmt = FI4P , iostat = E_IO ) cell_type case ( raw ) write ( s_buffer , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) connect write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) cell_type write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON endmodule Lib_VTK_IO_CON","tags":"","loc":"sourcefile/lib_vtk_io_con.f90.html","title":"Lib_VTK_IO_CON.f90 – Lib_VTK_IO"},{"text":"DAT and VAR interface definitions for Lib_VTK_IO. Source Code !< DAT and VAR interface definitions for Lib_VTK_IO. module Lib_VTK_IO_DAT_VAR !----------------------------------------------------------------------------------------------------------------------------------- !< DAT and VAR interface definitions for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTK_DAT public :: VTK_VAR !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTK_VAR !< Procedure for saving data variable(s) in VTK-legacy standard. !< !< VTK_VAR is an interface to 8 different functions, there are 3 functions for scalar variables, 3 functions for vectorial !< variables and 2 functions texture variables: scalar and vectorial data can be R8P, R4P and I4P data while texture variables can !< be only R8P or R4P. This function saves the data variables related to geometric mesh. !< @note The inputs that must be passed change depending on the data !< variables type. !< !<### Examples of usage !< !<#### Scalar data calling !<```fortran !< integer(I4P):: NN !< real(R4P)::    var(1:NN) !< ... !< E_IO=VTK_VAR(NN,'Sca',var) !< ... !<``` !< !<#### Vectorial data calling !<```fortran !< integer(I4P):: NN !< real(R4P)::    varX(1:NN),varY(1:NN),varZ(1:NN) !< ... !< E_IO=VTK_VAR('vect',NN,'Vec',varX,varY,varZ) !< ... !<``` module procedure VTK_VAR_SCAL_R8 , & ! real(R8P)    scalar VTK_VAR_SCAL_R4 , & ! real(R4P)    scalar VTK_VAR_SCAL_I4 , & ! integer(I4P) scalar VTK_VAR_VECT_R8 , & ! real(R8P)    vectorial VTK_VAR_VECT_R4 , & ! real(R4P)    vectorial VTK_VAR_VECT_I4 , & ! integer(I4P) vectorial VTK_VAR_TEXT_R8 , & ! real(R8P)    vectorial (texture) VTK_VAR_TEXT_R4 ! real(R4P)    vectorial (texture) endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function VTK_DAT ( NC_NN , var_location , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing/finalizing the saving of data associated to the mesh. !< !< Function that **must** be called before saving the data related to geometric mesh, this function initializes the !< saving of data variables indicating the *type* (node or cell centered) of variables that will be saved. !< @note A single file can contain both cell and node centered variables. In this case the VTK_DAT function must be !< called two times, before saving cell-centered variables and before saving node-centered variables. !< !<### Examples of usage !< !<#### Saving node data !<```fortran !< E_IO=VTK_DAT_XML(50,'node') !<``` !< !<#### Saving cell data !<```fortran !< E_IO=VTK_DAT_XML(50,'cell') !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of cells or nodes of field. character ( * ), intent ( IN ) :: var_location !< Location of saving variables: cell for cell-centered, node for node-centered. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( unit = vtk ( rf )% u , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN case ( 'NODE' ) write ( unit = vtk ( rf )% u , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN endselect case ( raw ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec case ( 'NODE' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT function VTK_VAR_SCAL_R8 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN ) !< Variable to be saved. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = vtk ( rf )% u , fmt = FR8P , iostat = E_IO ) var case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) var write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R8 function VTK_VAR_SCAL_R4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN ) !< Variable to be saved. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = vtk ( rf )% u , fmt = FR4P , iostat = E_IO ) var case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) var write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R4 function VTK_VAR_SCAL_I4 ( NC_NN , varname , var , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of scalar variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN ) !< Variable to be saved. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = vtk ( rf )% u , fmt = FI4P , iostat = E_IO ) var case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO ) var write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_I4 function VTK_VAR_VECT_R8 ( vec_type , NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type !< Vector type: vect = generic vector , norm = normal vector. integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: varX ( 1 : NC_NN ) !< X component of vector. real ( R8P ), intent ( IN ) :: varY ( 1 : NC_NN ) !< Y component of vector. real ( R8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) !< Z component of vector. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' case ( 'NORM' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' endselect write ( unit = vtk ( rf )% u , fmt = '(3' // FR8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( raw ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' // end_rec case ( 'NORM' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' // end_rec endselect write ( unit = vtk ( rf )% u , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R8 function VTK_VAR_VECT_R4 ( vec_type , NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type !< Vector type: vect = generic vector , norm = normal vector. integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: varX ( 1 : NC_NN ) !< X component of vector. real ( R4P ), intent ( IN ) :: varY ( 1 : NC_NN ) !< Y component of vector. real ( R4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) !< Z component of vector. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' case ( 'norm' ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' endselect write ( unit = vtk ( rf )% u , fmt = '(3' // FR4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( raw ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' // end_rec case ( 'norm' ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' // end_rec endselect write ( unit = vtk ( rf )% u , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R4 function VTK_VAR_VECT_I4 ( NC_NN , varname , varX , varY , varZ , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving field of vectorial variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. character ( * ), intent ( IN ) :: varname !< Variable name. integer ( I4P ), intent ( IN ) :: varX ( 1 : NC_NN ) !< X component of vector. integer ( I4P ), intent ( IN ) :: varY ( 1 : NC_NN ) !< Y component of vector. integer ( I4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) !< Z component of vector. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' write ( unit = vtk ( rf )% u , fmt = '(3' // FI4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( raw ) write ( unit = vtk ( rf )% u , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_I4 function VTK_VAR_TEXT_R8 ( NC_NN , dimm , varname , textCoo , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving texture variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. integer ( I4P ), intent ( IN ) :: dimm !< Texture dimensions. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R8P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) !< Texture. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = vtk ( rf )% u , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( raw ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R8 function VTK_VAR_TEXT_R4 ( NC_NN , dimm , varname , textCoo , cf ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving texture variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN !< Number of nodes or cells. integer ( I4P ), intent ( IN ) :: dimm !< Texture dimensions. character ( * ), intent ( IN ) :: varname !< Variable name. real ( R4P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) !< Texture. integer ( I4P ), intent ( IN ), optional :: cf !< Current file index (for concurrent files IO). integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. integer ( I4P ) :: rf !< Real file index. integer ( I4P ) :: n1 , n2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P rf = f if ( present ( cf )) then rf = cf ; f = cf endif select case ( vtk ( rf )% f ) case ( ascii ) write ( unit = vtk ( rf )% u , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = vtk ( rf )% u , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( raw ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( unit = vtk ( rf )% u , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = vtk ( rf )% u , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = vtk ( rf )% u , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R4 endmodule Lib_VTK_IO_DAT_VAR","tags":"","loc":"sourcefile/lib_vtk_io_dat_var.f90.html","title":"Lib_VTK_IO_DAT_VAR.f90 – Lib_VTK_IO"},{"text":"VTM_XML interface definitions for Lib_VTK_IO. Source Code !< VTM_XML interface definitions for Lib_VTK_IO. module Lib_VTK_IO_VTM_XML !----------------------------------------------------------------------------------------------------------------------------------- !< VTM_XML interface definitions for Lib_VTK_IO. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Lib_Base64 ! Base64 encoding/decoding procedures. USE Lib_VTK_IO_Back_End ! Lib_VTK_IO back end module. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: VTM_INI_XML public :: VTM_BLK_XML public :: VTM_WRF_XML public :: VTM_END_XML !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface VTM_WRF_XML !< Procedure for saving the list of VTK-XML wrapped files by a mutliblock VTM file. !< !< VTK_WRF_XML is an interface to 2 different functions, one for files list passed as an array and one for files list passed !< a single string. If a single string is used, the delimiter of each file can be customized, while the default values is '&'. !<### Examples of usage !< !<#### Example with array files list: 3 files block with default delimiter !<```fortran !< E_IO = VTK_WRF_XML(flist=['file_1.vts','file_2.vts','file_3.vtu']) !<``` !<#### Example with single string files list: 3 files block with default delimiter !<```fortran !< E_IO = VTK_WRF_XML(flist='file_1.vts&file_2.vts&file_3.vtu') !<``` !<#### Example with single string files list: 2 files block with custom delimiter (!!) !<```fortran !< E_IO = VTK_WRF_XML(flist='file_1.vts!!file_2.vts',delimiter='!!') !<``` module procedure VTM_WRF_XML_array , VTM_WRF_XML_string endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function VTM_INI_XML ( filename ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK-XML files. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename !< File name of output VTM file. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. character ( len = maxlen ) :: s_buffer !< Buffer string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if (. not . ir_initialized ) call IR_Init if (. not . b64_initialized ) call b64_init if ( endian == endianL ) then s_buffer = '<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\" byte_order=\"LittleEndian\">' else s_buffer = '<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\" byte_order=\"BigEndian\">' endif open ( unit = Get_Unit ( vtm % u ), file = trim ( filename ), form = 'FORMATTED' , access = 'SEQUENTIAL' , action = 'WRITE' , status = 'REPLACE' , iostat = E_IO ) write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) trim ( s_buffer ) ; vtm % indent = 2 write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '<vtkMultiBlockDataSet>' ; vtm % indent = vtm % indent + 2 vtm % blk = - 1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_INI_XML function VTM_BLK_XML ( block_action , name ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for opening or closing a block level of a VTM file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: block_action !< Block action: OPEN or CLOSE block. character ( * ), optional , intent ( IN ) :: name !< Block name. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P select case ( trim ( Upper_Case ( block_action ))) case ( 'OPEN' ) vtm % blk = vtm % blk + 1 if ( present ( name )) then write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // & '<Block index=\"' // trim ( str (. true .,( vtm % blk ( 1 ) + vtm % blk ( 2 )))) // & '\" name=\"' // trim ( name ) // '\">' else write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // & '<Block index=\"' // trim ( str (. true .,( vtm % blk ( 1 ) + vtm % blk ( 2 )))) // '\">' endif vtm % indent = vtm % indent + 2 case ( 'CLOSE' ) vtm % indent = vtm % indent - 2 ; write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '</Block>' vtm % blk ( 2 ) = - 1 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_BLK_XML function VTM_WRF_XML_array ( nlist , flist ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. !< !< @note the list is passed as an array. !< !<#### Example of usage: 3 files blocks !<```fortran !< E_IO = VTK_WRF_XML(flist=['file_1.vts','file_2.vts','file_3.vtu']) !<``` !< !<#### Example of usage: 3 files blocks with custom name !<```fortran !< E_IO = VTK_WRF_XML(flist=['file_1.vts','file_2.vts','file_3.vtu'],& !<                    nlist=['block-bar','block-foo','block-baz']) !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: nlist (:) !< List names attributed to wrapped files. character ( * ), intent ( IN ) :: flist (:) !< List of VTK-XML wrapped files. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. integer ( I4P ) :: f !< File counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P if ( present ( nlist )) then if ( size ( nlist ) == size ( flist )) then do f = 1 , size ( flist ) write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '<DataSet index=\"' // trim ( str (. true ., f - 1 )) // '\" file=\"' // & trim ( adjustl ( flist ( f ))) // '\" name=\"' // trim ( adjustl ( nlist ( f ))) // '\"/>' enddo endif else do f = 1 , size ( flist ) write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '<DataSet index=\"' // trim ( str (. true ., f - 1 )) // '\" file=\"' // & trim ( adjustl ( flist ( f ))) // '\"/>' enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_WRF_XML_array function VTM_WRF_XML_string ( delimiter , nlist , flist ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. !< !< @note the list is passed as a single string. The delimiter of each file can be customized: default value is \"&\". For supporting !< compiler with not varying string support the maximum delimiter length is fixed to 50. !< !<### Examples of usage !< !<#### Example: 3 files block with default delimiter !<```fortran !< E_IO = VTK_WRF_XML(flist='file_1.vts&file_2.vts&file_3.vtu') !<``` !< !<#### Example: 3 files block with custom name !<```fortran !< E_IO = VTK_WRF_XML(flist='file_1.vts&file_2.vts&file_3.vtu',& !<                    nlist='foo&bar&baz') !<``` !< !<#### Example: 2 files block with custom delimiter (!!) !<```fortran !< E_IO = VTK_WRF_XML(flist='file_1.vts!!file_2.vts',delimiter='!!') !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: delimiter !< Delimiter of files into files list string. character ( * ), optional , intent ( IN ) :: nlist !< List names attributed to wrapped files. character ( * ), intent ( IN ) :: flist !< List of VTK-XML wrapped files. integer ( I4P ) :: E_IO !< Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. integer ( I4P ) :: f !< File counter. character ( 50 ) :: delimit !< Delimiter value. character ( len ( flist )) :: flistd !< Dummy files list. character ( len ( flist )) :: nlistd !< Dummy names list. character ( len ( flist )) :: dummy ( 1 : 2 ) !< Dummy strings. integer ( I4P ) :: d_len !< Delimiter character length. integer ( I4P ) :: i , n !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P delimit = '&' ; if ( present ( delimiter )) delimit = delimiter ; d_len = len_trim ( delimit ) flistd = flist if ( present ( nlist )) nlistd = nlist if ( len_trim ( flistd ) <= d_len ) return ! no list to save ! purging out leading and trailing delimeters if ( flistd ( 1 : d_len ) == trim ( delimit )) flistd = flistd ( d_len + 1 :) if ( flistd ( len_trim ( flistd ) - d_len :) == trim ( delimit )) flistd = flistd ( 1 : len_trim ( flistd ) - d_len - 1 ) if ( present ( nlist )) then if ( nlistd ( 1 : d_len ) == trim ( delimit )) nlistd = nlistd ( d_len + 1 :) if ( nlistd ( len_trim ( nlistd ) - d_len :) == trim ( delimit )) nlistd = nlistd ( 1 : len_trim ( nlistd ) - d_len - 1 ) endif f = - 1 do while ( len_trim ( flistd ) > 0 ) f = f + 1 i = index ( flistd , trim ( delimit )) if ( i > 0 ) then dummy ( 1 ) = trim ( adjustl ( flistd ( 1 : i - 1 ))) flistd = trim ( flistd ( i + 1 :)) elseif ( len_trim ( flistd ) > 0 ) then dummy ( 1 ) = trim ( adjustl ( flistd )) flistd = '' else exit endif if ( present ( nlist )) then n = index ( nlistd , trim ( delimit )) if ( n > 0 ) then dummy ( 2 ) = trim ( adjustl ( nlistd ( 1 : n - 1 ))) nlistd = trim ( nlistd ( n + 1 :)) else dummy ( 2 ) = trim ( adjustl ( nlistd )) nlistd = '' endif endif if ( present ( nlist )) then write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '<DataSet index=\"' // trim ( str (. true ., f )) // '\" file=\"' // & trim ( adjustl ( dummy ( 1 ))) // '\" name=\"' // trim ( adjustl ( dummy ( 2 ))) // '\"/>' else write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '<DataSet index=\"' // trim ( str (. true ., f )) // '\" file=\"' // & trim ( adjustl ( dummy ( 1 ))) // '\"/>' endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_WRF_XML_string function VTM_END_XML () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !< Function for finalizing the VTM-XML file. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO !< Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- E_IO = - 1_I4P vtm % indent = vtm % indent - 2 write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm % indent ) // '</vtkMultiBlockDataSet>' write ( unit = vtm % u , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' close ( unit = vtm % u ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_END_XML endmodule Lib_VTK_IO_VTM_XML","tags":"","loc":"sourcefile/lib_vtk_io_vtm_xml.f90.html","title":"Lib_VTK_IO_VTM_XML.f90 – Lib_VTK_IO"},{"text":"Testing program for Lib_VTK_IO, a pure Fortran (2003+) library to write and read data conforming the VTK standard Source Code !< Testing program for Lib_VTK_IO, a pure Fortran (2003+) library to write and read data conforming the VTK standard module Lib_Testers !< Module library of procedures for testing Lib_VTK_IO and for providing practical examples. !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE Lib_VTK_IO USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: test_stress public :: test_rect public :: test_unst public :: test_strg public :: test_punst public :: test_pstrg public :: test_vtm #ifdef OPENMP public :: test_openmp #endif #ifdef MPI2 public :: test_mpi #endif !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine test_stress () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing all functions. !< !< R4P and R8P mesh data, 1D and 3D arrays inputs, standard (X,Y,Z,... separated arrays) and !< packed API (X,Y,Z,... packed into a single array). All available formats are used. The StructuredGrid topology is used. !< @note This subroutine is designed not as an example rather than a comprehensive stress-tester for functions of any kind/rank. !--------------------------------------------------------------------------------------------------------------------------------- ! dataset dimensions integer ( I4P ), parameter :: nx1 = 0_I4P , nx2 = 9_I4P , ny1 = 0_I4P , ny2 = 5_I4P , nz1 = 0_I4P , nz2 = 5_I4P integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) ! grid coordinates real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z ! coordinates components real ( R8P ), dimension ( 1 : 3 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: xyz ! packed coordinates components ! variables associated at grid nodes real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v_R ! scalar (real) integer ( I8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v_I ! scalar (integer) real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: vX_R , vY_R , Vz_R ! 3 dimensional vector components (real) integer ( I8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: vX_I , vY_I , Vz_I ! 3 dimensional vector components (integer) real ( R8P ), dimension ( 1 : 4 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: vP_R ! packed 4 dimensional vector (real) integer ( I8P ), dimension ( 1 : 4 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: vP_I ! packed 4 dimensional vector (integer) ! auxiliary variables integer ( I4P ) :: E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing StructuredGrid functions. Output files are XML_STRG#.vts' ! arrays initialization call initialize ! testing 64 bits grid coordinates data, 1D rank arrays non packed, ASCII format E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . false ., out_f = 'ASCII' ) ! testing 64 bits grid coordinates data, 1D rank arrays packed, ASCII format E_IO = save_strg ( xyz64 = xyz , threeD = . false ., out_f = 'ASCII' ) ! testing 64 bits grid coordinates data, 3D rank arrays non packed, ASCII format E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . true ., out_f = 'ASCII' ) ! testing 64 bits grid coordinates data, 3D rank arrays packed, ASCII format E_IO = save_strg ( xyz64 = xyz , threeD = . true ., out_f = 'ASCII' ) ! testing 64 bits grid coordinates data, 1D rank arrays non packed, BINARY format E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . false ., out_f = 'BINARY' ) ! testing 64 bits grid coordinates data, 1D rank arrays packed, BINARY format E_IO = save_strg ( xyz64 = xyz , threeD = . false ., out_f = 'BINARY' ) ! testing 64 bits grid coordinates data, 3D rank arrays non packed, ABINARYformat E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . true ., out_f = 'BINARY' ) ! testing 64 bits grid coordinates data, 3D rank arrays packed, BINARY format E_IO = save_strg ( xyz64 = xyz , threeD = . true ., out_f = 'BINARY' ) ! testing 64 bits grid coordinates data, 1D rank arrays non packed, RAW format E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . false ., out_f = 'RAW' ) ! testing 64 bits grid coordinates data, 1D rank arrays packed, RAW format E_IO = save_strg ( xyz64 = xyz , threeD = . false ., out_f = 'RAW' ) ! testing 64 bits grid coordinates data, 3D rank arrays non packed, RAW format E_IO = save_strg ( x64 = x , y64 = y , z64 = z , threeD = . true ., out_f = 'RAW' ) ! testing 64 bits grid coordinates data, 3D rank arrays packed, RAW format E_IO = save_strg ( xyz64 = xyz , threeD = . true ., out_f = 'RAW' ) ! testing 32 bits grid coordinates data, 1D rank arrays non packed, ASCII format E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . false ., out_f = 'ASCII' ) ! testing 32 bits grid coordinates data, 1D rank arrays packed, ASCII format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . false ., out_f = 'ASCII' ) ! testing 32 bits grid coordinates data, 3D rank arrays non packed, ASCII format E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . true ., out_f = 'ASCII' ) ! testing 32 bits grid coordinates data, 3D rank arrays packed, ASCII format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . true ., out_f = 'ASCII' ) ! testing 32 bits grid coordinates data, 1D rank arrays non packed, BINARY format E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . false ., out_f = 'BINARY' ) ! testing 32 bits grid coordinates data, 1D rank arrays packed, BINARY format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . false ., out_f = 'BINARY' ) ! testing 32 bits grid coordinates data, 3D rank arrays non packed, ABINARYformat E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . true ., out_f = 'BINARY' ) ! testing 32 bits grid coordinates data, 3D rank arrays packed, BINARY format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . true ., out_f = 'BINARY' ) ! testing 32 bits grid coordinates data, 1D rank arrays non packed, RAW format E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . false ., out_f = 'RAW' ) ! testing 32 bits grid coordinates data, 1D rank arrays packed, RAW format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . false ., out_f = 'RAW' ) ! testing 32 bits grid coordinates data, 3D rank arrays non packed, RAW format E_IO = save_strg ( x32 = real ( x , R4P ), y32 = real ( y , R4P ), z32 = real ( z , R4P ), threeD = . true ., out_f = 'RAW' ) ! testing 32 bits grid coordinates data, 3D rank arrays packed, RAW format E_IO = save_strg ( xyz32 = real ( xyz , R4P ), threeD = . true ., out_f = 'RAW' ) return !--------------------------------------------------------------------------------------------------------------------------------- contains subroutine initialize () !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initializing data. !------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: i , j , k , p !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = i * 1._R8P ; xyz ( 1 , i , j , k ) = x ( i , j , k ) y ( i , j , k ) = j * 1._R8P ; xyz ( 2 , i , j , k ) = y ( i , j , k ) z ( i , j , k ) = k * 1._R8P ; xyz ( 3 , i , j , k ) = z ( i , j , k ) v_R ( i , j , k ) = real ( i * j * k , R8P ) v_I ( i , j , k ) = int ( i * j * k , I8P ) vX_R ( i , j , k ) = x ( i , j , k ) ; vX_I ( i , j , k ) = int ( x ( i , j , k ), I8P ) vY_R ( i , j , k ) = y ( i , j , k ) ; vY_I ( i , j , k ) = int ( y ( i , j , k ), I8P ) vZ_R ( i , j , k ) = z ( i , j , k ) ; vZ_I ( i , j , k ) = int ( z ( i , j , k ), I8P ) vP_R (:, i , j , k ) = [( x ( i , j , k ) * p , p = 1 , 4 )] vP_I (:, i , j , k ) = int ( vP_R (:, i , j , k ), I8P ) enddo enddo enddo return !------------------------------------------------------------------------------------------------------------------------------- endsubroutine initialize function save_node_variables ( threeD ) result ( E_IO ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for saving StructuredGrid files. !------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: threeD !< Flag for checking the rank-dimensions of outputs. integer ( I4P ) :: E_IO !< Error trapping flag. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) if ( threeD ) then ! 3D rank arrays E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_R8' , var = v_R ) ! scalar, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_R4' , var = real ( v_R , R4P )) ! scalar, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I8' , var = v_I ) ! scalar, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I4' , var = int ( v_I , I4P )) ! scalar, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I2' , var = int ( v_I , I2P )) ! scalar, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I1' , var = int ( v_I , I1P )) ! scalar, I1P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_R8' , varX = vX_R , varY = vY_R , varZ = vZ_R ) ! vector, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_R4' , varX = real ( vX_R , R4P ), varY = real ( vY_R , R4P ), varZ = real ( vZ_R , R4P )) ! vector, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I8' , varX = vX_I , varY = vY_I , varZ = vZ_I ) ! vector, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I4' , varX = int ( vX_I , I4P ), varY = int ( vY_I , I4P ), varZ = int ( vZ_I , I4P )) ! vector, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I2' , varX = int ( vX_I , I2P ), varY = int ( vY_I , I2P ), varZ = int ( vZ_I , I2P )) ! vector, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I1' , varX = int ( vX_I , I1P ), varY = int ( vY_I , I1P ), varZ = int ( vZ_I , I1P )) ! vector, I1P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_R8' , var = vP_R ) ! packed 4D vector, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_R4' , var = real ( vP_R , R4P )) ! packed 4D vector, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I8' , var = vP_I ) ! packed 4D vector, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I4' , var = int ( vP_I , I4P )) ! packed 4D vector, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I2' , var = int ( vP_I , I2P )) ! packed 4D vector, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I1' , var = int ( vP_I , I1P )) ! packed 4D vector, I1P else ! 1D rank arrays E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_R8' , var = reshape ( v_R ,[ nn ]) ) ! scalar, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_R4' , var = real ( reshape ( v_R ,[ nn ]), R4P )) ! scalar, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I8' , var = reshape ( v_I ,[ nn ]) ) ! scalar, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I4' , var = int ( reshape ( v_I ,[ nn ]), I4P )) ! scalar, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I2' , var = int ( reshape ( v_I ,[ nn ]), I2P )) ! scalar, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_I1' , var = int ( reshape ( v_I ,[ nn ]), I1P )) ! scalar, I1P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_R8' , varX = reshape ( vX_R ,[ nn ]), & varY = reshape ( vY_R ,[ nn ]), & varZ = reshape ( vZ_R ,[ nn ]) ) ! vector, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_R4' , varX = real ( reshape ( vX_R ,[ nn ]), R4P ),& varY = real ( reshape ( vY_R ,[ nn ]), R4P ),& varZ = real ( reshape ( vZ_R ,[ nn ]), R4P )) ! vector, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I8' , varX = reshape ( vX_I ,[ nn ]), & varY = reshape ( vY_I ,[ nn ]), & varZ = reshape ( vZ_I ,[ nn ]) ) ! vector, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I4' , varX = int ( reshape ( vX_I ,[ nn ]), I4P ),& varY = int ( reshape ( vY_I ,[ nn ]), I4P ),& varZ = int ( reshape ( vZ_I ,[ nn ]), I4P )) ! vector, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I2' , varX = int ( reshape ( vX_I ,[ nn ]), I2P ),& varY = int ( reshape ( vY_I ,[ nn ]), I2P ),& varZ = int ( reshape ( vZ_I ,[ nn ]), I2P )) ! vector, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'vect_I1' , varX = int ( reshape ( vX_I ,[ nn ]), I1P ),& varY = int ( reshape ( vY_I ,[ nn ]), I1P ),& varZ = int ( reshape ( vZ_I ,[ nn ]), I1P )) ! vector, I1P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_R8' , var = reshape ( vP_R ,[ 4 , nn ]) ) ! packed 4D vector, R8P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_R4' , var = real ( reshape ( vP_R ,[ 4 , nn ]), R4P )) ! packed 4D vector, R4P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I8' , var = reshape ( vP_I ,[ 4 , nn ]) ) ! packed 4D vector, I8P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I4' , var = int ( reshape ( vP_I ,[ 4 , nn ]), I4P )) ! packed 4D vector, I4P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I2' , var = int ( reshape ( vP_I ,[ 4 , nn ]), I2P )) ! packed 4D vector, I2P E_IO = VTK_VAR_XML ( NC_NN = nn , N_COL = 4_I4P , varname = 'vectP_I1' , var = int ( reshape ( vP_I ,[ 4 , nn ]), I1P )) ! packed 4D vector, I1P endif E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction save_node_variables function save_strg ( x64 , y64 , z64 , xyz64 , x32 , y32 , z32 , xyz32 , threeD , out_f ) result ( E_IO ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for saving node-located variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), optional , intent ( IN ) :: x64 (:,:,:) !< X Coordinates components (64 bits). real ( R8P ), optional , intent ( IN ) :: y64 (:,:,:) !< Y Coordinates components (64 bits). real ( R8P ), optional , intent ( IN ) :: z64 (:,:,:) !< Z Coordinates components (64 bits). real ( R8P ), optional , intent ( IN ) :: xyz64 (:,:,:,:) !< Packed coordinates components (64 bits). real ( R4P ), optional , intent ( IN ) :: x32 (:,:,:) !< X Coordinates components (32 bits). real ( R4P ), optional , intent ( IN ) :: y32 (:,:,:) !< Y Coordinates components (32 bits). real ( R4P ), optional , intent ( IN ) :: z32 (:,:,:) !< Z Coordinates components (32 bits). real ( R4P ), optional , intent ( IN ) :: xyz32 (:,:,:,:) !< Packed coordinates components (32 bits). logical , intent ( IN ) :: threeD !< Flag for checking the rank-dimensions of outputs. character ( * ), intent ( IN ) :: out_f !< Output format. integer ( I4P ) :: E_IO !< Error trapping flag. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- if ( threeD ) then if ( present ( x64 )) then ! non packed, 3D rank array, 64 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-3DA-' // trim ( out_f ) // '-64.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = x64 , Y = y64 , Z = z64 ) elseif ( present ( x32 )) then ! non packed, 3D rank array, 32 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-3DA-' // trim ( out_f ) // '-32.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = x32 , Y = y32 , Z = z32 ) elseif ( present ( xyz64 )) then ! packed, 3D rank array, 64 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-3DAP-' // trim ( out_f ) // '-64.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , XYZ = xyz64 ) elseif ( present ( xyz32 )) then ! packed, 3D rank array, 32 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-3DAP-' // trim ( out_f ) // '-32.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , XYZ = xyz32 ) endif else if ( present ( x64 )) then ! non packed, 1D rank array, 64 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-1DA-' // trim ( out_f ) // '-64.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn ,& X = reshape ( x64 ,[ nn ]), Y = reshape ( y64 ,[ nn ]), Z = reshape ( z64 ,[ nn ])) elseif ( present ( x32 )) then ! non packed, 1D rank array, 32 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-1DA-' // trim ( out_f ) // '-32.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn ,& X = reshape ( x32 ,[ nn ]), Y = reshape ( y32 ,[ nn ]), Z = reshape ( z32 ,[ nn ])) elseif ( present ( xyz64 )) then ! packed, 1D rank array, 64 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-1DAP-' // trim ( out_f ) // '-64.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , XYZ = reshape ( xyz64 ,[ 3 , nn ])) elseif ( present ( xyz32 )) then ! packed, 1D rank array, 32 bits data E_IO = VTK_INI_XML_WRITE ( fformat = trim ( out_f ), filename = 'XML_STRG-1DAP-' // trim ( out_f ) // '-32.vts' ,& mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , XYZ = reshape ( xyz32 ,[ 3 , nn ])) endif endif E_IO = save_node_variables ( threeD = threeD ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () return !------------------------------------------------------------------------------------------------------------------------------- endfunction save_strg endsubroutine test_stress subroutine test_unst () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing UnstructuredGrid functions. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: Nn = 27_I4P integer ( I4P ), parameter :: Ne = 11_I4P real ( R4P ), dimension ( 1 : Nn ) :: x = [ 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ] real ( R4P ), dimension ( 1 : Nn ) :: y = [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] real ( R4P ), dimension ( 1 : Nn ) :: z = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 6 ] integer ( I1P ), dimension ( 1 : Ne ) :: cell_type = [ 12_I1P , 12_I1P , 10_I1P , 10_I1P , 7_I1P , 6_I1P , 9_I1P , 5_I1P , 5_I1P , 3_I1P , 1_I1P ] integer ( I4P ), dimension ( 1 : Ne ) :: offset = [ 8_I4P , 16_I4P , 20_I4P , 24_I4P , 30_I4P , 36_I4P , 40_I4P , 43_I4P , 46_I4P , 48_I4P , 49_I4P ] integer ( I4P ), dimension ( 1 : 49 ) :: connect real ( R8P ), dimension ( 1 : Nn ) :: v integer ( I4P ), dimension ( 1 : Nn ) :: v_X integer ( I4P ), dimension ( 1 : Nn ) :: v_Y integer ( I4P ), dimension ( 1 : Nn ) :: v_Z integer ( I4P ) :: E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing UnstructuredGrid functions. Output file is XML_UNST#.vtu' connect = ( / 0 , 1 , 4 , 3 , 6 , 7 , 10 , 9 , & 1 , 2 , 5 , 4 , 7 , 8 , 11 , 10 , & 6 , 10 , 9 , 12 , & 5 , 11 , 10 , 14 , & 15 , 16 , 17 , 14 , 13 , 12 , & 18 , 15 , 19 , 16 , 20 , 17 , & 22 , 23 , 20 , 19 , & 21 , 22 , 18 , & 22 , 19 , 18 , & 26 , 25 , & 24 / ) v = ( / 0.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 1 0.0 , 1 1.0 , 1 2.0 , 1 3.0 , 1 4.0 , 1 5.0 , 1 6.0 , 1 7.0 , & 1 8.0 , 1 9.0 , 2 0.0 , 2 1.0 , 2 2.0 , 2 3.0 , 2 4.0 , 2 5.0 , 2 6.0 / ) v_X = ( / 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 / ) v_Y = ( / 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 / ) v_Z = ( / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) ! ascii E_IO = VTK_INI_XML_WRITE ( fformat = 'ascii' , filename = 'XML_UNST-ascii.vtu' , mesh_topology = 'UnstructuredGrid' ) E_IO = VTK_GEO_XML_WRITE ( NN = Nn , NC = Ne , X = x , Y = y , Z = z ) E_IO = VTK_CON_XML ( NC = Ne , connect = connect , offset = offset , cell_type = cell_type ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'opeN' ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'scalars' , var = v ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'vector' , varX = v_X , varY = v_Y , varZ = v_Z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'CLOSE' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! raw E_IO = VTK_INI_XML_WRITE ( fformat = 'raw' , filename = 'XML_UNST-raw.vtu' , mesh_topology = 'UnstructuredGrid' ) E_IO = VTK_GEO_XML_WRITE ( NN = Nn , NC = Ne , X = x , Y = y , Z = z ) E_IO = VTK_CON_XML ( NC = Ne , connect = connect , offset = offset , cell_type = cell_type ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'opeN' ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'scalars' , var = v ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'vector' , varX = v_X , varY = v_Y , varZ = v_Z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'CLOSE' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! binary E_IO = VTK_INI_XML_WRITE ( fformat = 'binary' , filename = 'XML_UNST-binary.vtu' , mesh_topology = 'UnstructuredGrid' ) E_IO = VTK_GEO_XML_WRITE ( NN = Nn , NC = Ne , X = x , Y = y , Z = z ) E_IO = VTK_CON_XML ( NC = Ne , connect = connect , offset = offset , cell_type = cell_type ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'opeN' ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'scalars' , var = v ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'vector' , varX = v_X , varY = v_Y , varZ = v_Z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'CLOSE' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_unst subroutine test_strg () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing StructuredGrid functions. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: nx1 = 0_I4P , nx2 = 9_I4P , ny1 = 0_I4P , ny2 = 5_I4P , nz1 = 0_I4P , nz2 = 5_I4P integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v_R integer ( I4P ) :: E_IO integer ( I4P ) :: i , j , k !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing StructuredGrid functions. Output files is XML_STRG.vts' ! initializing data do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = i * 1._R8P y ( i , j , k ) = j * 1._R8P z ( i , j , k ) = k * 1._R8P v_R ( i , j , k ) = real ( i * j * k , R8P ) enddo enddo enddo E_IO = VTK_INI_XML_WRITE ( fformat = 'binary' , filename = 'XML_STRG.vts' , mesh_topology = 'StructuredGrid' ,& nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'scal_R8' , var = v_R ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_strg subroutine test_rect () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing RectilinearGrid functions. !< !< @note This subroutine also shows the usage of FieldData functions that are useful for saving global auxiliary data, e.g. time, !< time step, ecc. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: nx1 = 0_I4P , nx2 = 16_I4P , ny1 = 0_I4P , ny2 = 16_I4P , nz1 = 0_I4P , nz2 = 16_I4P integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) real ( R8P ) :: x ( nx1 : nx2 ), y ( ny1 : ny2 ), z ( nz1 : nz2 ) real ( R8P ) :: x1 =- 3._R8P , x2 = 3._R8P real ( R8P ) :: y1 =- 2._R8P , y2 = 0.25_R8P real ( R8P ) :: z1 =- 2._R8P , z2 = 0.16_R8P integer ( I4P ) :: v ( 1 : nn ) integer ( I4P ) :: i , j , k , n , E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing RectilinearGrid functions. Output file is XML_RECT#.vtr' ! arrays initialization n = 0 do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 n = n + 1 v ( n ) = i * j * k enddo enddo enddo do i = nx1 , nx2 x ( i ) = x1 + ( i - 1 ) * ( x2 - x1 ) / real ( nx2 - nx1 , kind = R8P ) enddo do j = ny1 , ny2 y ( j ) = y1 + ( j - 1 ) * ( y2 - y1 ) / real ( ny2 - ny1 , kind = R8P ) enddo do k = nz1 , nz2 z ( k ) = z1 + ( k - 1 ) * ( z2 - z1 ) / real ( nz2 - nz1 , kind = R8P ) enddo ! ascii E_IO = VTK_INI_XML_WRITE ( fformat = 'ascii' , filename = 'XML_RECT-ascii.vtr' , & mesh_topology = 'RectilinearGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_FLD_XML ( fld_action = 'open' ) E_IO = VTK_FLD_XML ( fld = 0._R8P , fname = 'TIME' ) E_IO = VTK_FLD_XML ( fld = 1_I8P , fname = 'CYCLE' ) E_IO = VTK_FLD_XML ( fld_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'cell_value' , var = v ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! raw E_IO = VTK_INI_XML_WRITE ( fformat = 'raw' , filename = 'XML_RECT-raw.vtr' , & mesh_topology = 'RectilinearGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_FLD_XML ( fld_action = 'open' ) E_IO = VTK_FLD_XML ( fld = 0._R8P , fname = 'TIME' ) E_IO = VTK_FLD_XML ( fld = 1_I8P , fname = 'CYCLE' ) E_IO = VTK_FLD_XML ( fld_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'cell_value' , var = v ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! binary E_IO = VTK_INI_XML_WRITE ( fformat = 'binary' , filename = 'XML_RECT-binary.vtr' , & mesh_topology = 'RectilinearGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_FLD_XML ( fld_action = 'open' ) E_IO = VTK_FLD_XML ( fld = 0._R8P , fname = 'TIME' ) E_IO = VTK_FLD_XML ( fld = 1_I8P , fname = 'CYCLE' ) E_IO = VTK_FLD_XML ( fld_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'cell_value' , var = v ) E_IO = VTK_DAT_XML ( var_location = 'cell' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rect subroutine test_punst () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing parallel (partitioned) PStructuredGrid functions. !< !< @note Note that the two parts are completely independet. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: Nn = 27_I4P integer ( I4P ), parameter :: Ne = 11_I4P real ( R4P ), dimension ( 1 : Nn ) :: x = [ 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ] real ( R4P ), dimension ( 1 : Nn ) :: y = [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] real ( R4P ), dimension ( 1 : Nn ) :: z = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 6 ] integer ( I1P ), dimension ( 1 : Ne ) :: cell_type = [ 12_I1P , 12_I1P , 10_I1P , 10_I1P , 7_I1P , 6_I1P , 9_I1P , 5_I1P , 5_I1P , 3_I1P , 1_I1P ] integer ( I4P ), dimension ( 1 : Ne ) :: offset = [ 8_I4P , 16_I4P , 20_I4P , 24_I4P , 30_I4P , 36_I4P , 40_I4P , 43_I4P , 46_I4P , 48_I4P , 49_I4P ] integer ( I4P ), dimension ( 1 : 49 ) :: connect real ( R8P ), dimension ( 1 : Nn ) :: v integer ( I4P ), dimension ( 1 : Nn ) :: v_X integer ( I4P ), dimension ( 1 : Nn ) :: v_Y integer ( I4P ), dimension ( 1 : Nn ) :: v_Z integer ( I4P ) :: E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing parallel (partitioned) PUnstructuredGrid functions' write ( stdout , '(A)' ) ' Output files are XML_UNST.pvtu, XML_UNST_part0.vtu, XML_UNST_part1.vtu' connect = ( / 0 , 1 , 4 , 3 , 6 , 7 , 10 , 9 , & 1 , 2 , 5 , 4 , 7 , 8 , 11 , 10 , & 6 , 10 , 9 , 12 , & 5 , 11 , 10 , 14 , & 15 , 16 , 17 , 14 , 13 , 12 , & 18 , 15 , 19 , 16 , 20 , 17 , & 22 , 23 , 20 , 19 , & 21 , 22 , 18 , & 22 , 19 , 18 , & 26 , 25 , & 24 / ) v = ( / 0.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 1 0.0 , 1 1.0 , 1 2.0 , 1 3.0 , 1 4.0 , 1 5.0 , 1 6.0 , 1 7.0 , & 1 8.0 , 1 9.0 , 2 0.0 , 2 1.0 , 2 2.0 , 2 3.0 , 2 4.0 , 2 5.0 , 2 6.0 / ) v_X = ( / 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 / ) v_Y = ( / 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 / ) v_Z = ( / 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) ! first part E_IO = VTK_INI_XML_WRITE ( fformat = 'raw' , filename = 'XML_UNST_part0.vtu' , mesh_topology = 'UnstructuredGrid' ) E_IO = VTK_GEO_XML_WRITE ( NN = Nn , NC = Ne , X = x , Y = y , Z = z ) E_IO = VTK_CON_XML ( NC = Ne , connect = connect , offset = offset , cell_type = cell_type ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'opeN' ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'scalars' , var = v ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'vector' , varX = v_X , varY = v_Y , varZ = v_Z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'CLOSE' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! second part x = x + 1 0._R4P E_IO = VTK_INI_XML_WRITE ( fformat = 'raw' , filename = 'XML_UNST_part1.vtu' , mesh_topology = 'UnstructuredGrid' ) E_IO = VTK_GEO_XML_WRITE ( NN = Nn , NC = Ne , X = x , Y = y , Z = z ) E_IO = VTK_CON_XML ( NC = Ne , connect = connect , offset = offset , cell_type = cell_type ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'opeN' ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'scalars' , var = v ) E_IO = VTK_VAR_XML ( NC_NN = Nn , varname = 'vector' , varX = v_X , varY = v_Y , varZ = v_Z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'CLOSE' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () ! pvtu E_IO = PVTK_INI_XML ( filename = 'XML_UNST.pvtu' , mesh_topology = 'PUnstructuredGrid' , tp = 'Float32' ) E_IO = PVTK_GEO_XML ( source = 'XML_UNST_part0.vtu' ) E_IO = PVTK_GEO_XML ( source = 'XML_UNST_part1.vtu' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'OPEN' ) E_IO = PVTK_VAR_XML ( varname = 'scalars' , tp = 'Float64' ) E_IO = PVTK_VAR_XML ( Nc = 3 , varname = 'vector' , tp = 'Int32' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'Close' ) E_IO = PVTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_punst subroutine test_pstrg () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing parallel (partitioned) PStructuredGrid functions. !< !< The mesh is a simple prism partitioned into two pieces along x direction at ordinate i=nx2_p(1). !<``` !< y &#94; !<   |               ny2 +-----------------+--------------+ !<   |                   |                 |              | !<   |                   |                 |              | !<   |                   |                 |              | !<   |                   |                 |              | !<   o-------->      ny1 +-----------------+--------------+ !<            x         nx1               i=nx2_p(1)     nx2 !<``` !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: nx1 = 0_I4P , nx2 = 9_I4P , ny1 = 0_I4P , ny2 = 5_I4P , nz1 = 0_I4P , nz2 = 5_I4P integer ( I4P ), parameter :: nx1_p ( 1 : 2 ) = [ nx1 , 4_I4P ] integer ( I4P ), parameter :: nx2_p ( 1 : 2 ) = [ 4_I4P , nx2 ] integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) integer ( I4P ), parameter :: nn_p ( 1 : 2 ) = [( nx2_p ( 1 ) - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ),& ( nx2_p ( 2 ) - nx2_p ( 1 ) + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 )] real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z integer ( I4P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v integer ( I4P ) :: i , j , k , p , mf ( 1 : 2 ), E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing parallel (partitioned) PStructuredGrid functions' write ( stdout , '(A)' ) ' Output files are XML_STRG.pvts, XML_STRG_part0.vts, XML_STRG_part1.vts' ! arrays initialization do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = i * 1._R8P y ( i , j , k ) = j * 1._R8P z ( i , j , k ) = k * 1._R8P v ( i , j , k ) = i * j * k enddo enddo enddo do p = 1 , 2 ! loop over pieces E_IO = VTK_INI_XML_WRITE ( cf = mf ( p ), fformat = 'raw' , filename = 'XML_STRG_part' // trim ( str (. true ., p - 1 )) // '.vts' , & mesh_topology = 'StructuredGrid' , nx1 = nx1_p ( p ), nx2 = nx2_p ( p ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML_WRITE ( cf = mf ( p ), nx1 = nx1_p ( p ), nx2 = nx2_p ( p ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn_p ( p ), & X = reshape ( x ( nx1_p ( p ): nx2_p ( p ),:,:),( / nn_p ( p ) / )), & Y = reshape ( y ( nx1_p ( p ): nx2_p ( p ),:,:),( / nn_p ( p ) / )), & Z = reshape ( z ( nx1_p ( p ): nx2_p ( p ),:,:),( / nn_p ( p ) / ))) E_IO = VTK_DAT_XML ( cf = mf ( p ), var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( cf = mf ( p ), NC_NN = nn_p ( p ), varname = 'node_value' , var = reshape ( v ( nx1_p ( p ): nx2_p ( p ),:,:),( / nn_p ( p ) / ))) E_IO = VTK_DAT_XML ( cf = mf ( p ), var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( cf = mf ( p )) E_IO = VTK_END_XML () enddo ! pvts E_IO = PVTK_INI_XML ( filename = 'XML_STRG.pvts' , mesh_topology = 'PStructuredGrid' , & nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , tp = 'Float64' ) E_IO = PVTK_GEO_XML ( nx1 = nx1 , nx2 = nx2_p ( 1 ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , source = 'XML_STRG_part0.vts' ) E_IO = PVTK_GEO_XML ( nx1 = nx2_p ( 1 ), nx2 = nx2_p ( 2 ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , source = 'XML_STRG_part1.vts' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = PVTK_VAR_XML ( varname = 'node_value' , tp = 'Int32' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = PVTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_pstrg subroutine test_vtm () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing multi-blocks VTM functions. !< !< There are 4 subset of data organized into 2 blocks. All the subsets are simple StructuredGrid prisms shifted along x direction. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), parameter :: nx1 = 0_I4P , nx2 = 9_I4P , ny1 = 0_I4P , ny2 = 5_I4P , nz1 = 0_I4P , nz2 = 5_I4P integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) real ( R8P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z integer ( I4P ), dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v integer ( I4P ) :: i , j , k , b , mf ( 1 : 4 ), E_IO !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Testing multi-blocks VTM functions' write ( stdout , '(A)' ) ' Output files are XML_M-STRG.vtm, XML_M-STRG_part.0.vts, XML_M-STRG_part.1.vts' ! arrays initialization do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = i * 1._R8P y ( i , j , k ) = j * 1._R8P z ( i , j , k ) = k * 1._R8P v ( i , j , k ) = 1_I4P enddo enddo enddo ! vts do b = 1 , 4 ! loop over blocks E_IO = VTK_INI_XML_WRITE ( cf = mf ( b ), fformat = 'binary' , filename = 'XML_M-STRG_part.' // trim ( str (. true ., b - 1 )) // '.vts' , & mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) if ( b > 1 ) then x = x + nx2 * 1._R8P v = b endif E_IO = VTK_GEO_XML_WRITE ( cf = mf ( b ), nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , & X = reshape ( x ( nx1 : nx2 ,:,:),( / nn / )), & Y = reshape ( y ( nx1 : nx2 ,:,:),( / nn / )), & Z = reshape ( z ( nx1 : nx2 ,:,:),( / nn / ))) E_IO = VTK_DAT_XML ( cf = mf ( b ), var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( cf = mf ( b ), NC_NN = nn , varname = 'node_value' , var = reshape ( v ( nx1 : nx2 ,:,:),( / nn / ))) E_IO = VTK_DAT_XML ( cf = mf ( b ), var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( cf = mf ( b )) E_IO = VTK_END_XML () enddo ! vtm E_IO = VTM_INI_XML ( 'XML_M-STRG.vtm' ) E_IO = VTM_BLK_XML ( block_action = 'open' ) E_IO = VTM_WRF_XML ( flist = ( / ( 'XML_M-STRG_part.' // trim ( str (. true ., b - 1 )) // '.vts' , b = 1 , 2 ) / )) E_IO = VTM_BLK_XML ( block_action = 'close' ) E_IO = VTM_BLK_XML ( block_action = 'open' ) E_IO = VTM_WRF_XML ( flist = ( / ( 'XML_M-STRG_part.' // trim ( str (. true ., b - 1 )) // '.vts' , b = 3 , 4 ) / )) E_IO = VTM_BLK_XML ( block_action = 'close' ) E_IO = VTM_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_vtm #ifdef OPENMP subroutine test_openmp ( Nf_tot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing the libray in an OpenMP parallel framework. !< !< It is used for testing thread-safe capability and the !< library speedup into OpenMP parallel framework. The output is a parallel (partitioned) PStructuredGrid file. !< @note The whole grid is composed of blocks of 32x32x32 structured mesh. The total number of blocks/files, Nf_tot, is passed as !< argument. The whole grid is built up composing the blocks along the X axis with a regular shift as following: !<``` !< y &#94; !<   |               ny2 +------------+------------+------------+------///////////-----+ !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   o-------->      ny1 +------------+------------+------------+------///////////-----+ !<            x         nx1          nx2    2*(nx2-nx+1)  3*(nx2-nx+1)          Nf_tot*(nx2-nx+1) !<``` !< @note When the total number of blocks/files, Nf_tot, is not an integral of the number of threads used, Nths, the last !< thread saves its own files (Nf_tot/Nths) plus the remainder blocks/files (mod(Nf_tot,Nths)). As a consequence the last !< thread could has different elapsed time and it could degrade the speedup. Therefore the subroutine prints to stdout the !< maximum and minimum elapsed time among the threads as well the average elapsed time in order to facilitate the assessing !< of the parallel scalability. !< !< @note It is important to note that the output files initialization and finalization must be done outside the parallel ambient. !< !< @note The array containing the files indexes could be shared among threads, but the counter of this array ('p' in this example) !< must be private. !--------------------------------------------------------------------------------------------------------------------------------- USE omp_lib ! OpenMP runtime library. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nf_tot !< Total number of files saved. integer ( I4P ), parameter :: nx1 = 1_I4P !< First node in x direction. integer ( I4P ), parameter :: nx2 = 32_I4P !< Last node in x direction. integer ( I4P ), parameter :: ny1 = 1_I4P !< First node in y direction. integer ( I4P ), parameter :: ny2 = 32_I4P !< Last node in y direction. integer ( I4P ), parameter :: nz1 = 1_I4P !< First node in z direction. integer ( I4P ), parameter :: nz2 = 32_I4P !< Last node in z direction. integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1_I4P ) * ( ny2 - ny1 + 1_I4P ) * ( nz2 - nz1 + 1_I4P ) !< Whole grid extents. real ( R8P ) :: x ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in x direction. real ( R8P ) :: y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in y direction. real ( R8P ) :: z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in z direction. real ( R8P ) :: xf ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in x shifted by file offset. integer ( I4P ), allocatable :: v (:,:,:,:) !< Variable associated to nodes. integer ( I4P ) :: mf ( 1 : Nf_tot ) !< File indexes. integer ( I4P ) :: Nths !< Number of concurrent threads. integer ( I4P ) :: i , j , k , f , nxf , th !< Counters. integer ( I4P ) :: E_IO !< Error trapping flag. real ( R8P ) :: vtk_start , vtk_stop !< Timing variables. real ( R8P ), allocatable :: t (:) !< Timing variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL Nths = OMP_GET_NUM_THREADS () !$OMP END PARALLEL allocate ( v ( 0 : Nths - 1 , nx1 : nx2 , ny1 : ny2 , nz1 : nz2 )) allocate ( t ( 0 : Nths - 1 )) write ( stdout , '(A)' ) ' Testing OpenMP parallel framework' write ( stdout , '(A)' ) ' The test uses ' // trim ( str (. true ., Nf_tot )) // ' vts files of ' // trim ( str (. true ., nn )) // ' grid nodes as' // & ' benchmark' write ( stdout , '(A)' ) ' Number of files saved by each thread is ' // trim ( str (. true ., Nf_tot / Nths )) ! arrays initialization do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = real ( i - nx1 , R8P ) / real ( nx2 - nx1 , R8P ) y ( i , j , k ) = real ( j - ny1 , R8P ) / real ( ny2 - ny1 , R8P ) z ( i , j , k ) = real ( k - nz1 , R8P ) / real ( nz2 - nz1 , R8P ) do f = 0 , Nths - 1 v ( f , i , j , k ) = f enddo enddo enddo enddo ! opening files outside OpenMP framework do f = 1 , Nf_tot nxf = ( nx2 - nx1 + 1 ) * f - ( f - 1 ) E_IO = VTK_INI_XML_WRITE ( cf = mf ( f ), fformat = 'binary' , filename = 'XML_OPENMP_f' // trim ( strz ( 3 , f )) // '.vts' , & mesh_topology = 'StructuredGrid' , nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf ,& ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) enddo ! saving files t = 0._R8P !$OMP PARALLEL                                     & !$OMP DEFAULT(NONE)                                & !$OMP PRIVATE(f,E_IO,th,nxf,vtk_start,vtk_stop,xf) & !$OMP SHARED(mf,x,y,z,v,Nf_tot,t) th = OMP_GET_THREAD_NUM () !$OMP DO do f = 1 , Nf_tot ! loop over files nxf = ( nx2 - nx1 + 1 ) * f - ( f - 1 ) xf = x + real ( f - 1_I4P , R8P ) vtk_start = OMP_GET_WTIME () E_IO = VTK_GEO_XML_WRITE ( cf = mf ( f ), nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = xf , Y = y , Z = z ) E_IO = VTK_DAT_XML ( cf = mf ( f ), var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( cf = mf ( f ), NC_NN = nn , varname = 'node_value' , var = v ( th ,:,:,:)) E_IO = VTK_DAT_XML ( cf = mf ( f ), var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE ( cf = mf ( f )) vtk_stop = OMP_GET_WTIME () t ( th ) = t ( th ) + vtk_stop - vtk_start enddo !$OMP END PARALLEL ! closing files outside OpenMP framework do f = 1 , Nf_tot E_IO = VTK_END_XML () enddo write ( stdout , '(A)' ) ' Maximum elapsed time of single thread ' // trim ( adjustl ( str ( '(F9.4)' , maxval ( t )))) write ( stdout , '(A)' ) ' Minimum elapsed time of single thread ' // trim ( adjustl ( str ( '(F9.4)' , minval ( t )))) write ( stdout , '(A)' ) ' Average elapsed time ' // trim ( adjustl ( str ( '(F9.4)' , sum ( t ) / Nths ))) ! saving the composite .pvts file E_IO = PVTK_INI_XML ( filename = 'XML_OPENMP.pvts' , mesh_topology = 'PStructuredGrid' ,& nx1 = nx1 , nx2 = ( nx2 - nx1 + 1 ) * Nf_tot - ( Nf_tot - 1 ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , tp = 'Float64' ) do f = 1 , Nf_tot nxf = ( nx2 - nx1 + 1 ) * f - ( f - 1 ) E_IO = PVTK_GEO_XML ( nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ,& source = 'XML_OPENMP_f' // trim ( strz ( 3 , f )) // '.vts' ) enddo E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = PVTK_VAR_XML ( varname = 'node_value' , tp = 'Int32' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = PVTK_END_XML () return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_openmp #endif #ifdef MPI2 subroutine test_mpi ( Nf_tot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for testing the library in an MPI parallel framework. !< !< It is used for testing the process-safe capability and the !< library speedup into MPI parallel framework.  The output is a parallel (partitioned) PStructuredGrid file. !< @note The whole grid is composed of blocks of 32x32x32 structured mesh. The total number of blocks/files, Nf_tot, is passed as !< argument. The whole grid is built up composing the blocks along the X axis with a regular shift as following: !<``` !< y &#94; !<   |               ny2 +------------+------------+------------+------///////////-----+ !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   |                   |            |            |            |                      | !<   o-------->      ny1 +------------+------------+------------+------///////////-----+ !<            x         nx1          nx2    2*(nx2-nx+1)  3*(nx2-nx+1)          Nf_tot*(nx2-nx+1) !<``` !< @note When the total number of blocks/files, Nf_tot, is not an integral of the number of processes used, nproc, the last !< process saves its own files (Nf_tot/nproc) plus the remainder blocks/files (mod(Nf_tot,nproc)). As a consequence the last !< process could has different elapsed time and it could degrade the speedup. Therefore the subroutine prints to stdout the !< maximum and minimum elapsed time among the processes as well the average elapsed time in order to facilitate the assessing !< of the parallel scalability. !--------------------------------------------------------------------------------------------------------------------------------- USE MPI ! MPI runtime library. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nf_tot !< Total number of files saved. integer ( I4P ), parameter :: nx1 = 1_I4P !< First node in x direction. integer ( I4P ), parameter :: nx2 = 32_I4P !< Last node in x direction. integer ( I4P ), parameter :: ny1 = 1_I4P !< First node in y direction. integer ( I4P ), parameter :: ny2 = 32_I4P !< Last node in y direction. integer ( I4P ), parameter :: nz1 = 1_I4P !< First node in z direction. integer ( I4P ), parameter :: nz2 = 32_I4P !< Last node in z direction. integer ( I4P ), parameter :: nn = ( nx2 - nx1 + 1_I4P ) * ( ny2 - ny1 + 1_I4P ) * ( nz2 - nz1 + 1_I4P ) !< Whole grid extents. real ( R8P ) :: x ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in x direction. real ( R8P ) :: y ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in y direction. real ( R8P ) :: z ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in z direction. integer ( I4P ) :: v ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Variable associated to nodes. real ( R8P ) :: xf ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) !< Coordinates in x shifted by file offset direction. integer ( I4P ) :: i , j , k , f , foffset , nxf !< Counters. integer ( I4P ) :: myrank !< Rank of current process. integer ( I4P ) :: Nf !< Number of files saved by the current process. integer ( I4P ) :: nproc !< Number of concurrent processes. integer ( I4P ) :: E_IO !< Error trapping flag. real ( R8P ) :: vtk_start , vtk_stop , t , tmax , tmin , tmean !< Timing variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing parallel environments call MPI_INIT ( E_IO ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myrank , E_IO ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nproc , E_IO ) ! computing the number of files to be saved if ( myrank == nproc - 1 ) then ! the last process must save also the rest of the files if Nf_tot is not an integral of nproc Nf = Nf_tot / nproc + mod ( Nf_tot , nproc ) else Nf = Nf_tot / nproc endif if ( myrank == 0 ) then write ( stdout , '(A)' ) ' Testing MPI parallel framework' write ( stdout , '(A)' ) ' The test uses ' // trim ( str (. true ., Nf_tot )) // ' vts files of ' // trim ( str (. true ., nn )) // ' grid nodes as' // & ' benchmark' write ( stdout , '(A)' ) ' Number of files saved by processes other than the last is ' // trim ( str (. true ., Nf )) elseif ( myrank == nproc - 1 ) then write ( stdout , '(A)' ) ' Number of files saved by last process is ' // trim ( str (. true ., Nf )) endif ! arrays initialization do k = nz1 , nz2 do j = ny1 , ny2 do i = nx1 , nx2 x ( i , j , k ) = real ( i - nx1 , R8P ) / real ( nx2 - nx1 , R8P ) y ( i , j , k ) = real ( j - ny1 , R8P ) / real ( ny2 - ny1 , R8P ) z ( i , j , k ) = real ( k - nz1 , R8P ) / real ( nz2 - nz1 , R8P ) enddo enddo enddo v = myrank ! saving files t = 0._R8P do f = 1 , Nf ! loop over files of current process if ( myrank < nproc - 1 ) then foffset = f + myrank * Nf else foffset = f + myrank * ( Nf - mod ( Nf_tot , nproc )) endif nxf = ( nx2 - nx1 + 1 ) * foffset - ( foffset - 1 ) vtk_start = MPI_Wtime () E_IO = VTK_INI_XML_WRITE ( fformat = 'binary' , filename = 'XML_MPI_f' // trim ( strz ( 3 , foffset )) // '.vts' , & mesh_topology = 'StructuredGrid' , nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf , & ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) ! updating x coordinates of current process/file xf = x + real ( foffset - 1_I4P , R8P ) E_IO = VTK_GEO_XML_WRITE ( nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = xf , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'node_value' , var = v ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML_WRITE () E_IO = VTK_END_XML () vtk_stop = MPI_Wtime () t = t + vtk_stop - vtk_start enddo call MPI_REDUCE ( t , tmax , 1 , MPI_REAL8 , MPI_MAX , 0 , MPI_COMM_WORLD , E_IO ) call MPI_REDUCE ( t , tmin , 1 , MPI_REAL8 , MPI_MIN , 0 , MPI_COMM_WORLD , E_IO ) call MPI_REDUCE ( t , tmean , 1 , MPI_REAL8 , MPI_SUM , 0 , MPI_COMM_WORLD , E_IO ) if ( myrank == 0 ) then tmean = tmean / nproc ! first process prints the elapsed time to stdout write ( stdout , '(A)' ) ' Maximum elapsed time of single process ' // trim ( adjustl ( str ( '(F9.4)' , tmax ))) write ( stdout , '(A)' ) ' Minimum elapsed time of single process ' // trim ( adjustl ( str ( '(F9.4)' , tmin ))) write ( stdout , '(A)' ) ' Average elapsed time ' // trim ( adjustl ( str ( '(F9.4)' , tmean ))) ! first process saves also the composite .pvts file E_IO = PVTK_INI_XML ( filename = 'XML_MPI.pvts' , mesh_topology = 'PStructuredGrid' ,& nx1 = nx1 , nx2 = ( nx2 - nx1 + 1 ) * Nf_tot - ( Nf_tot - 1 ), ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , tp = 'Float64' ) do f = 1 , Nf_tot nxf = ( nx2 - nx1 + 1 ) * f - ( f - 1 ) E_IO = PVTK_GEO_XML ( nx1 = nxf - ( nx2 - nx1 + 1 ) + 1 , nx2 = nxf , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ,& source = 'XML_MPI_f' // trim ( strz ( 3 , f )) // '.vts' ) enddo E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = PVTK_VAR_XML ( varname = 'node_value' , tp = 'Int32' ) E_IO = PVTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = PVTK_END_XML () endif ! finalizing parallel environments call MPI_FINALIZE ( E_IO ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_mpi #endif endmodule Lib_Testers program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for Lib_VTK_IO, a pure Fortran (2003+) library to write and read data conforming the VTK standard !< !<### Usage !< For printing help message for usage run it without command line arguments !<```bash !< ./Test_Driver !<``` !< !<#### Testing UnstructuredGrid functions !<```bash !< ./Test_Driver -unst !<``` !< !<#### Testing StructuredGrid functions !<```bash !< ./Test_Driver -strg !<``` !< !<#### Testing RectilinearGrid functions !<```bash !< ./Test_Driver -rect !<``` !< !<#### Testing parallel (partitioned) PUnstructuredGrid functions !<```bash !< ./Test_Driver -punst !<``` !< !<#### Testing parallel (partitioned) PStructuredGrid functions !<```bash !< ./Test_Driver -pstrg !<``` !< !<#### Testing multi-blocks VTM functions !<```bash !< ./Test_Driver -vtm !<``` !< !<#### Testing thread-safe capability into an OpenMP parallel framework !<```bash !< ./Test_Driver -openmp !<``` !< !<#### Testing process-safe capability into a MPI parallel framework !<```bash !< ./Test_Driver -mpi !<``` !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision USE Lib_Testers USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: Nca = 0 !<  Number of command line arguments. character ( 7 ) :: cas !<  Command line argument switch. character ( 10 ) :: nF !<  Number of files for MPI and OpenMP benchmarks. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- nF = '' Nca = command_argument_count () if ( Nca == 0 ) then call print_usage endif call get_command_argument ( 1 , cas ) select case ( trim ( cas )) case ( '-unst' ) call test_unst case ( '-strg' ) call test_strg case ( '-rect' ) call test_rect case ( '-punst' ) call test_punst case ( '-pstrg' ) call test_pstrg case ( '-vtm' ) call test_vtm case ( '-openmp' ) #ifndef OPENMP write ( stderr , '(A)' ) ' The code has not been compiled with OpenMP directives... nothing to test' stop #else call get_command_argument ( 2 , nF ) call test_openmp ( Nf_tot = cton ( str = trim ( nF ), knd = I4P )) #endif case ( '-mpi' ) #ifndef MPI2 write ( stderr , '(A)' ) ' The code has not been compiled with MPI library... nothing to test' stop #else call get_command_argument ( 2 , nF ) call test_mpi ( Nf_tot = cton ( str = trim ( nF ), knd = I4P )) #endif case ( '-all' ) call test_rect call test_unst call test_strg call test_punst call test_pstrg call test_vtm case ( '-stress' ) call test_stress case default write ( stderr , '(A)' ) ' Switch ' // trim ( cas ) // ' unknown' call print_usage endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine print_usage () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing usage help message to stdout. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( stdout , '(A)' ) ' Test_Driver: a \"driver\" program for testing Lib_VTK_IO functions' write ( stdout , '(A)' ) ' Usage:' write ( stdout , '(A)' ) '   Test_Driver [-switch]' write ( stdout , '(A)' ) '     switch = unst   => testing UnstructuredGrid functions' write ( stdout , '(A)' ) '     switch = strg   => testing StructuredGrid functions' write ( stdout , '(A)' ) '     switch = rect   => testing RectilinearGrid functions' write ( stdout , '(A)' ) '     switch = punst  => testing parallel (partitioned) PUnstructuredGrid functions' write ( stdout , '(A)' ) '     switch = pstrg  => testing parallel (partitioned) StructuredGrid functions' write ( stdout , '(A)' ) '     switch = vtm    => testing multi-block XML functions' write ( stdout , '(A)' ) '     switch = all    => testing all above functions' write ( stdout , '(A)' ) '     switch = openmp => testing functions in parallel OpenMP framework' write ( stdout , '(A)' ) '     switch = mpi    => testing functions in parallel MPI    framework' write ( stdout , '(A)' ) '     switch = stress => testing functions of any kind/rank producing many files' write ( stdout , '(A)' ) ' Examples:' write ( stdout , '(A)' ) '   Test_Driver -pstrg' write ( stdout , '(A)' ) '   Test_Driver -vtm' write ( stdout , '(A)' ) '   Test_Driver -openmp' write ( stdout , '(A)' ) ' If switch is not passed (or is unknown) this help message is printed to stdout' stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 – Lib_VTK_IO"},{"text":"type, private :: Type_VTK_File Derived type for handling VTK files. Note The OOP encapsulation allows safe use of parallel paradigms. Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: f = ascii Current output-format (initialized to ascii format). character(len=maxlen), public :: topology = '' Mesh topology. integer(kind=I4P), public :: u = 0_I4P Logical unit. integer(kind=I4P), public :: ua = 0_I4P Logical unit for raw binary XML append file. integer(kind=I8P), public :: N_Byte = 0_I8P Number of byte to be written/read. integer(kind=I4P), public :: N_Byte = 0_I4P Number of byte to be written/read. integer(kind=I8P), public :: ioffset = 0_I8P Offset pointer. integer(kind=I4P), public :: indent = 0_I4P Indent pointer. Type-Bound Procedures procedure, public :: byte_update Procedure for updating N_Byte and ioffset pointer. public elementalsubroutine byte_update (vtk, N_Byte) Arguments Type Intent Optional Attributes Name class( Type_VTK_File ), intent(inout) :: vtk Global data of VTK file. integer(kind=I8P), intent(in) :: N_Byte Number of bytes saved. Description Subroutine for updating N_Byte and ioffset pointer.","tags":"","loc":"type/type_vtk_file.html","title":"Type_VTK_File – Lib_VTK_IO "},{"text":"type, private :: Type_VTM_File Derived type for handling VTM files. Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: u = 0_I4P Logical unit. integer(kind=I4P), public :: blk (1:2) = [0_I4P,0_I4P] Block indexes. integer(kind=I4P), public :: indent = 0_I4P Indent pointer.","tags":"","loc":"type/type_vtm_file.html","title":"Type_VTM_File – Lib_VTK_IO "},{"text":"public function PVTK_INI_XML(filename, mesh_topology, tp, cf, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. character(len=*), intent(in) :: mesh_topology Mesh topology. character(len=*), intent(in) :: tp Type of geometry representation (Float32, Float64, ecc). integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing parallel (partitioned) VTK-XML file. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvtk_ini_xml.html","title":"PVTK_INI_XML – Lib_VTK_IO"},{"text":"public function PVTK_GEO_XML(source, cf, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source file name containing the piece data. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving piece geometry source for parallel (partitioned) VTK-XML file. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvtk_geo_xml.html","title":"PVTK_GEO_XML – Lib_VTK_IO"},{"text":"public function PVTK_DAT_XML(var_location, var_block_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location Location of saving variables: CELL or NODE centered. character(len=*), intent(in) :: var_block_action Variables block action: OPEN or CLOSE block. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. Function that must be called before saving the data related to geometric mesh, this function initializes the\n saving of data variables indicating the type (node or cell centered) of variables that will be saved. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvtk_dat_xml.html","title":"PVTK_DAT_XML – Lib_VTK_IO"},{"text":"public function PVTK_VAR_XML(varname, tp, cf, Nc) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: varname Variable name. character(len=*), intent(in) :: tp Type of data representation (Float32, Float64, ecc). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: Nc Number of components of variable. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving variable associated to nodes or cells geometry. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvtk_var_xml.html","title":"PVTK_VAR_XML – Lib_VTK_IO"},{"text":"public function PVTK_END_XML(cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the parallel (partitioned) VTK-XML file. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvtk_end_xml.html","title":"PVTK_END_XML – Lib_VTK_IO"},{"text":"public function VTK_END_XML(cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTK-XML file. Usage E_IO = VTK_END_XML () Variables Type Visibility Attributes Name Initial character(len=2), public :: var_type Varable type = R8,R4,I8,I4,I2,I1. real(kind=R8P), public, allocatable :: v_R8 (:) R8 vector for IO in AppendData. real(kind=R4P), public, allocatable :: v_R4 (:) R4 vector for IO in AppendData. integer(kind=I8P), public, allocatable :: v_I8 (:) I8 vector for IO in AppendData. integer(kind=I4P), public, allocatable :: v_I4 (:) I4 vector for IO in AppendData. integer(kind=I2P), public, allocatable :: v_I2 (:) I2 vector for IO in AppendData. integer(kind=I1P), public, allocatable :: v_I1 (:) I1 vector for IO in AppendData. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data. integer(kind=I8P), public :: N_v Vector dimension. integer(kind=I8P), public :: n1 Counter. integer(kind=I4P), public :: N_v Vector dimension. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_end_xml.html","title":"VTK_END_XML – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRP_R8(Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X0 X coordinate of origin. real(kind=R8P), intent(in) :: Y0 Y coordinate of origin. real(kind=R8P), intent(in) :: Z0 Z coordinate of origin. real(kind=R8P), intent(in) :: Dx Space step in x direction. real(kind=R8P), intent(in) :: Dy Space step in y direction. real(kind=R8P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_geo_strp_r8.html","title":"VTK_GEO_STRP_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRP_R4(Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X0 X coordinate of origin. real(kind=R4P), intent(in) :: Y0 Y coordinate of origin. real(kind=R4P), intent(in) :: Z0 Z coordinate of origin. real(kind=R4P), intent(in) :: Dx Space step in x direction. real(kind=R4P), intent(in) :: Dy Space step in y direction. real(kind=R4P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_geo_strp_r4.html","title":"VTK_GEO_STRP_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_1DA_R8(Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_strg_1da_r8.html","title":"VTK_GEO_STRG_1DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_1DAP_R8(Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_strg_1dap_r8.html","title":"VTK_GEO_STRG_1DAP_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_3DA_R8(Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 integer(kind=I4P), public :: n3 Counters.","tags":"","loc":"proc/vtk_geo_strg_3da_r8.html","title":"VTK_GEO_STRG_3DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_3DAP_R8(Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 integer(kind=I4P), public :: n3 Counters.","tags":"","loc":"proc/vtk_geo_strg_3dap_r8.html","title":"VTK_GEO_STRG_3DAP_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_1DA_R4(Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_strg_1da_r4.html","title":"VTK_GEO_STRG_1DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_1DAP_R4(Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_strg_1dap_r4.html","title":"VTK_GEO_STRG_1DAP_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_3DA_R4(Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 integer(kind=I4P), public :: n3 Counters.","tags":"","loc":"proc/vtk_geo_strg_3da_r4.html","title":"VTK_GEO_STRG_3DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_STRG_3DAP_R4(Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 integer(kind=I4P), public :: n3 Counters.","tags":"","loc":"proc/vtk_geo_strg_3dap_r4.html","title":"VTK_GEO_STRG_3DAP_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_RECT_R8(Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X (1:Nx) X coordinates. real(kind=R8P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R8P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_rect_r8.html","title":"VTK_GEO_RECT_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_RECT_R4(Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X (1:Nx) X coordinates. real(kind=R4P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R4P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_rect_r4.html","title":"VTK_GEO_RECT_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_UNST_R8(NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_unst_r8.html","title":"VTK_GEO_UNST_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_UNST_P_R8(NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_unst_p_r8.html","title":"VTK_GEO_UNST_P_R8 – Lib_VTK_IO"},{"text":"private function VTK_GEO_UNST_R4(NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 counter.","tags":"","loc":"proc/vtk_geo_unst_r4.html","title":"VTK_GEO_UNST_R4 – Lib_VTK_IO"},{"text":"private function VTK_GEO_UNST_P_R4(NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 counter.","tags":"","loc":"proc/vtk_geo_unst_p_r4.html","title":"VTK_GEO_UNST_P_R4 – Lib_VTK_IO"},{"text":"public interface VTK_GEO Procedure for saving mesh with different topologies in VTK-legacy standard. VTK_GEO is an interface to 16 different functions, there are 2 functions for each of 4 different topologies actually supported:\n one function for mesh coordinates with R8P precision and one for mesh coordinates with R4P precision. Note This function must be called after VTK_INI. It saves the mesh geometry. The inputs that must be passed change depending\n on the topologies chosen. Not all VTK topologies have been implemented ( polydata topologies are absent). Examples of usage Structured points calling integer ( I4P ) :: Nx , Ny , Nz real ( I8P ) :: X0 , Y0 , Z0 , Dx , Dy , Dz ... E_IO = VTK_GEO ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz ) ... Structured grid calling integer ( I4P ) :: Nx , Ny , Nz , Nnodes real ( R8P ) :: X ( 1 : Nnodes ), Y ( 1 : Nnodes ), Z ( 1 : Nnodes ) ... E_IO = VTK_GEO ( Nx , Ny , Nz , Nnodes , X , Y , Z ) ... Rectilinear grid calling integer ( I4P ) :: Nx , Ny , Nz real ( R8P ) :: X ( 1 : Nx ), Y ( 1 : Ny ), Z ( 1 : Nz ) ... E_IO = VTK_GEO ( Nx , Ny , Nz , X , Y , Z ) ... Unstructured grid calling integer ( I4P ) :: NN real ( R4P ) :: X ( 1 : NN ), Y ( 1 : NN ), Z ( 1 : NN ) ... E_IO = VTK_GEO ( NN , X , Y , Z ) ... Module Procedures private function VTK_GEO_UNST_R8 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P). private function VTK_GEO_UNST_P_R8 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P, packed API). private function VTK_GEO_UNST_R4 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P). private function VTK_GEO_UNST_P_R4 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P, packed API). private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X0 X coordinate of origin. real(kind=R8P), intent(in) :: Y0 Y coordinate of origin. real(kind=R8P), intent(in) :: Z0 Z coordinate of origin. real(kind=R8P), intent(in) :: Dx Space step in x direction. real(kind=R8P), intent(in) :: Dy Space step in y direction. real(kind=R8P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R8P). private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X0 X coordinate of origin. real(kind=R4P), intent(in) :: Y0 Y coordinate of origin. real(kind=R4P), intent(in) :: Z0 Z coordinate of origin. real(kind=R4P), intent(in) :: Dx Space step in x direction. real(kind=R4P), intent(in) :: Dy Space step in y direction. real(kind=R4P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R4P). private function VTK_GEO_STRG_1DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays). private function VTK_GEO_STRG_3DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays). private function VTK_GEO_STRG_1DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays, packed API). private function VTK_GEO_STRG_3DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays, packed API). private function VTK_GEO_STRG_1DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays). private function VTK_GEO_STRG_3DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays). private function VTK_GEO_STRG_1DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays, packed API). private function VTK_GEO_STRG_3DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays, packed API). private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X (1:Nx) X coordinates. real(kind=R8P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R8P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R8P). private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X (1:Nx) X coordinates. real(kind=R4P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R4P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R4P).","tags":"","loc":"interface/vtk_geo.html","title":"VTK_GEO – Lib_VTK_IO"},{"text":"public function VTK_INI_XML_WRITE(fformat, filename, mesh_topology, nx1, nx2, ny1, ny2, nz1, nz2, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat File format: ASCII, BINARY, RAW or BINARY-APPENDED. character(len=*), intent(in) :: filename File name. character(len=*), intent(in) :: mesh_topology Mesh topology. integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Procedure for initializing VTK-XML file (exporter). The XML standard is more powerful than legacy one. It is flexible but on the other hand is (but not so more using this library\n ...) complex than legacy standard. The output of XML functions is a well-formated valid XML file, at least for the\n ascii, binary and binary appended formats (in the raw-binary format the library uses raw-binary-appended format that is not a\n valid XML file).\n Note that the XML functions have the same name of legacy functions with the suffix XML . Note This function must be the first to be called. Supported output formats are (the passed specifier value is case insensitive):\n- ASCII: data are saved in ASCII format;\n- BINARY: data are saved in base64 encoded format;\n- RAW: data are saved in raw-binary format in the appended tag of the XML file;\n- BINARY-APPENDED: data are saved in base64 encoded format in the appended tag of the XML file.\n Supported topologies are:\n- RectilinearGrid;\n- StructuredGrid;\n- UnstructuredGrid. Example of usage integer ( I4P ) :: nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ... E_IO = VTK_INI_XML ( 'BINARY' , 'XML_RECT_BINARY.vtr' , 'RectilinearGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) ... Note that the file extension is necessary in the file name. The XML standard has different extensions for each\n different topologies (e.g. vtr for rectilinear topology). See the VTK-standard file for more information. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_ini_xml_write.html","title":"VTK_INI_XML_WRITE – Lib_VTK_IO"},{"text":"public function VTK_INI_XML_READ(fformat, filename, mesh_topology, npieces, nx1, nx2, ny1, ny2, nz1, nz2, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat File format: ASCII,  BINARY or RAW character(len=*), intent(in) :: filename File name character(len=*), intent(in) :: mesh_topology Mesh topology integer(kind=I4P), intent(out), optional :: npieces Number of pieces stored in the file integer(kind=I4P), intent(out), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(out), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(out), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(out), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(out), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(out), optional :: nz2 Final node of z axis. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Procedure for initializing VTK-XML file (importer). Supported input formats are (the passed specifier value is case insensitive):\n- ASCII: data are saved in ASCII format; (Not implemented!)\n- BINARY: data are saved in base64 encoded format; (Not tested!)\n- RAW: data are saved in raw-binary format in the appended tag of the XML file; (Not implemented!)\n- BINARY-APPENDED: data are saved in base64 encoded format in the appended tag of the XML file. (Not implemented!)\n Supported topologies are:\n- RectilinearGrid; (Not tested!)\n- StructuredGrid; (Not tested!)\n- UnstructuredGrid. (Not tested!) Example of usage integer ( I4P ) :: nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ... E_IO = VTK_INI_XML_READ ( 'BINARY' , 'XML_RECT_BINARY.vtr' , 'RectilinearGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , cf = rf ) ... Note that the file extension is necessary in the file name. The XML standard has different extensions for each\n different topologies (e.g. vtr for rectilinear topology). See the VTK-standard file for more information. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: np Real number of pieces. character(len=:), public, allocatable :: s_buffer Buffer string. character, public :: c1 character, public :: c2 Characters dummies. character(len=:), public, allocatable :: aux Auxiliary string. integer(kind=I4P), public, dimension(6) :: rn Real node ranges in WholeExtent [nx1,nx2,ny1,ny2,nz1,nz2]. logical, public :: fexist Flag for checking the existence of file to import.","tags":"","loc":"proc/vtk_ini_xml_read.html","title":"VTK_INI_XML_READ – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_OC(fld_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fld_action Field data tag action: OPEN or CLOSE tag. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for open/close field data tag. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_oc.html","title":"VTK_FLD_XML_OC – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_R8(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R8P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_r8.html","title":"VTK_FLD_XML_R8 – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_R4(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R4P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_r4.html","title":"VTK_FLD_XML_R4 – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_I8(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I8P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_i8.html","title":"VTK_FLD_XML_I8 – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_I4(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I4P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I8P), public :: Nfldp Dimension of fldp, packed data.","tags":"","loc":"proc/vtk_fld_xml_i4.html","title":"VTK_FLD_XML_I4 – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_I2(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I2P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_i2.html","title":"VTK_FLD_XML_I2 – Lib_VTK_IO"},{"text":"private function VTK_FLD_XML_I1(fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I1P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: fldp (:) Packed field data. character(len=:), public, allocatable :: fld64 Field data encoded in base64. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_fld_xml_i1.html","title":"VTK_FLD_XML_I1 – Lib_VTK_IO"},{"text":"public interface VTK_FLD_XML Procedure for saving field data (global auxiliary data, eg time, step number, dataset name, etc). VTK_FLD_XML is an interface to 7 different functions, there are 2 functions for real field data, 4 functions for integer one\n and one function for open and close field data tag.\n VTK_FLD_XML must be called after VTK_INI_XML and before VTK_GEO_XML. It must always called three times at least: for opening the FieldData tag; for saving at least one FieldData entry; for closing the FieldData tag. Example of usage: ... real ( R8P ) :: time integer ( I4P ) :: step ... E_IO = VTK_FLD_XML ( fld_action = 'open' ) E_IO = VTK_FLD_XML ( fld = time , fname = 'TIME' ) E_IO = VTK_FLD_XML ( fld = step , fname = 'CYCLE' ) E_IO = VTK_FLD_XML ( fld_action = 'close' ) ... Module Procedures private function VTK_FLD_XML_OC (fld_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fld_action Field data tag action: OPEN or CLOSE tag. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for open/close field data tag. private function VTK_FLD_XML_R8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R8P). private function VTK_FLD_XML_R4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R4P). private function VTK_FLD_XML_I8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I8P). private function VTK_FLD_XML_I4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I4P). private function VTK_FLD_XML_I2 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I2P). private function VTK_FLD_XML_I1 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I1P).","tags":"","loc":"interface/vtk_fld_xml.html","title":"VTK_FLD_XML – Lib_VTK_IO"},{"text":"public function VTK_DAT_XML(var_location, var_block_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location Location of saving variables: CELL or NODE centered. character(len=*), intent(in) :: var_block_action Variables block action: OPEN or CLOSE block. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. Function that must be called before saving the data related to geometric mesh, this function initializes the\n saving of data variables indicating the type (node or cell centered) of variables that will be saved. Note A single file can contain both cell and node centered variables. In this case the VTK_DAT_XML function must be\n called two times, before saving cell-centered variables and before saving node-centered variables. Examples of usage Opening node piece E_IO = VTK_DAT_XML ( 'node' , 'OPeN' ) Closing node piece E_IO = VTK_DAT_XML ( 'node' , 'CLosE' ) Opening cell piece E_IO = VTK_DAT_XML ( 'cell' , 'OPEN' ) Closing cell piece E_IO = VTK_DAT_XML ( 'cell' , 'close' ) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_dat_xml.html","title":"VTK_DAT_XML – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_R8(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_scal_1da_r8.html","title":"VTK_VAR_XML_SCAL_1DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_R8(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_var_xml_scal_3da_r8.html","title":"VTK_VAR_XML_SCAL_3DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_R4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_scal_1da_r4.html","title":"VTK_VAR_XML_SCAL_1DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_R4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_var_xml_scal_3da_r4.html","title":"VTK_VAR_XML_SCAL_3DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_I8(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_scal_1da_i8.html","title":"VTK_VAR_XML_SCAL_1DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_I8(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_var_xml_scal_3da_i8.html","title":"VTK_VAR_XML_SCAL_3DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_I4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_scal_1da_i4.html","title":"VTK_VAR_XML_SCAL_1DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_I4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_scal_3da_i4.html","title":"VTK_VAR_XML_SCAL_3DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_I2(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_scal_1da_i2.html","title":"VTK_VAR_XML_SCAL_1DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_I2(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_var_xml_scal_3da_i2.html","title":"VTK_VAR_XML_SCAL_3DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_1DA_I1(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_scal_1da_i1.html","title":"VTK_VAR_XML_SCAL_1DA_I1 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_SCAL_3DA_I1(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_var_xml_scal_3da_i1.html","title":"VTK_VAR_XML_SCAL_3DA_I1 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_R8(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R8P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R8P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_vect_1da_r8.html","title":"VTK_VAR_XML_VECT_1DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_R8(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R8P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_vect_3da_r8.html","title":"VTK_VAR_XML_VECT_3DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_R4(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R4P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R4P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_vect_1da_r4.html","title":"VTK_VAR_XML_VECT_1DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_R4(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R4P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_vect_3da_r4.html","title":"VTK_VAR_XML_VECT_3DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_I8(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I8P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I8P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_vect_1da_i8.html","title":"VTK_VAR_XML_VECT_1DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_I8(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I8P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_vect_3da_i8.html","title":"VTK_VAR_XML_VECT_3DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_I4(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I4P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_vect_1da_i4.html","title":"VTK_VAR_XML_VECT_1DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_I4(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_vect_3da_i4.html","title":"VTK_VAR_XML_VECT_3DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_I2(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I2P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I2P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I2P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_vect_1da_i2.html","title":"VTK_VAR_XML_VECT_1DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_I2(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I2P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_vect_3da_i2.html","title":"VTK_VAR_XML_VECT_3DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_1DA_I1(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I1P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I1P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 1D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_xml_vect_1da_i1.html","title":"VTK_VAR_XML_VECT_1DA_I1 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_VECT_3DA_I1(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 3D arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: var (:) X, Y, Z component. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_vect_3da_i1.html","title":"VTK_VAR_XML_VECT_3DA_I1 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_R8(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_xml_list_1da_r8.html","title":"VTK_VAR_XML_LIST_1DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_R8(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_list_3da_r8.html","title":"VTK_VAR_XML_LIST_3DA_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_R4(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_xml_list_1da_r4.html","title":"VTK_VAR_XML_LIST_1DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_R4(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_list_3da_r4.html","title":"VTK_VAR_XML_LIST_3DA_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_I8(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_xml_list_1da_i8.html","title":"VTK_VAR_XML_LIST_1DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_I8(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_list_3da_i8.html","title":"VTK_VAR_XML_LIST_3DA_I8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_I4(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_list_1da_i4.html","title":"VTK_VAR_XML_LIST_1DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_I4(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters. integer(kind=I8P), public :: Nvarp Dimension of varp, packed data.","tags":"","loc":"proc/vtk_var_xml_list_3da_i4.html","title":"VTK_VAR_XML_LIST_3DA_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_I2(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_xml_list_1da_i2.html","title":"VTK_VAR_XML_LIST_1DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_I2(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_list_3da_i2.html","title":"VTK_VAR_XML_LIST_3DA_I2 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_1DA_I1(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 1D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_xml_list_1da_i1.html","title":"VTK_VAR_XML_LIST_1DA_I1 – Lib_VTK_IO"},{"text":"private function VTK_VAR_XML_LIST_3DA_I1(NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 3D array). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: varp (:) Packed data. character(len=:), public, allocatable :: var64 Variable encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz integer(kind=I4P), public :: n1 Counters.","tags":"","loc":"proc/vtk_var_xml_list_3da_i1.html","title":"VTK_VAR_XML_LIST_3DA_I1 – Lib_VTK_IO"},{"text":"public interface VTK_VAR_XML Procedure for saving data variable(s) in VTK-XML standard. VTK_VAR_XML is an interface to 36 different functions, there are 6 functions for scalar variables, 6 functions for vectorial\n variables and 6 functions for 3D(or higher) vectorial variables: for all of types the precision can be R8P, R4P, I8P, I4P, I2P\n and I1P. This function saves the data variables related (cell-centered or node-centered) to geometric mesh.\n 1D/3D-rank arrays and packed API for any kinds\n The inputs arrays can be passed as 1D-rank or 3D-rank and the vectorial variables can be component-separated (one for each of\n the 3 components) or packed into one multidimensional array: scalar input: input is 1D-rank array: var[1:NC_NN]; input is 3D-rank array: var[nx1:nx2,ny1:ny2,nz1:nz2]; vectorial inputs: inputs are 1D-rank arrays: varX[1:NC_NN],varY[1:NC_NN],varZ[1:NC_NN]; inputs are 3D-rank arrays: varX[nx1:nx2,ny1:ny2,nz1:nz2],varY[nx1:nx2,ny1:ny2,nz1:nz2],varX[nx1:nx2,ny1:ny2,nz1:nz2]; 3D(or higher) vectorial inputs: input is 1D-rank (packed API): var[1:N_COL,1:NC_NN]; input is 3D-rank (packed API): var[1:N_COL,nx1:nx2,ny1:ny2,nz1:nz2]. Note Note that the inputs that must be passed change depending on the data variables type. Examples of usage Scalar data calling integer ( I4P ) :: NN real ( R8P ) :: var ( 1 : NN ) ... E_IO = VTK_VAR_XML ( NN , 'Sca' , var ) ... Vectorial data calling integer ( I4P ) :: NN real ( R8P ) :: varX ( 1 : NN ), varY ( 1 : NN ), varZ ( 1 : NN ), ... E_IO = VTK_VAR_XML ( NN , 'Vec' , varX , varY , varZ ) ... Module Procedures private function VTK_VAR_XML_SCAL_1DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 3D array). private function VTK_VAR_XML_VECT_1DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R8P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R4P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I8P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I4P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I2P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I2P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I1P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I1P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 3D arrays). private function VTK_VAR_XML_LIST_1DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 1D array). private function VTK_VAR_XML_LIST_3DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 3D array). private function VTK_VAR_XML_LIST_1DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 1D array). private function VTK_VAR_XML_LIST_3DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 1D array). private function VTK_VAR_XML_LIST_3DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 3D array). private function VTK_VAR_XML_LIST_1DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 1D array). private function VTK_VAR_XML_LIST_3DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 1D array). private function VTK_VAR_XML_LIST_3DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 3D array). private function VTK_VAR_XML_LIST_1DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 1D array). private function VTK_VAR_XML_LIST_3DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 3D array).","tags":"","loc":"interface/vtk_var_xml.html","title":"VTK_VAR_XML – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4 – Lib_VTK_IO"},{"text":"private puresubroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description @brief Subroutine for packing different kinds of data into single I1P array. Procedure for packing different kinds of data into single I1P array. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data.","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2 – Lib_VTK_IO"},{"text":"public interface pack_data Procedure for packing different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Module Procedures private puresubroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description @brief Subroutine for packing different kinds of data into single I1P array.","tags":"","loc":"interface/pack_data.html","title":"pack_data – Lib_VTK_IO"},{"text":"public function VTK_CON_XML(NC, connect, offset, cell_type, idx, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC Number of cells. integer(kind=I4P), intent(in) :: connect (1:) Mesh connectivity. integer(kind=I4P), intent(in) :: offset (1:NC) Cell offset. integer(kind=I1P), intent(in) :: cell_type (1:) VTK cell type. integer(kind=I1P), intent(in), optional :: idx Id offset to convert Fortran (first id 1) to C (first id 0) standards. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh connectivity. Function that must be used when unstructured grid is used, it saves the connectivity of the unstructured gird. Note The vector connect must follow the VTK-XML standard. It is passed as assumed-shape array because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following\n equation: dc = \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i }.\n Note that this equation is different from the legacy one. The XML connectivity convention is quite different from the\n legacy standard.\n As an example suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with\n square basis (5 vertices) and suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells\n share 4 vertices. The above equation gives dc=8+5=13. The connectivity vector for this mesh can be: first cell connect(1)  = 0 identification flag of 1&#94;\\circ vertex of first cell connect(2)  = 1 identification flag of 2&#94;\\circ vertex of first cell connect(3)  = 2 identification flag of 3&#94;\\circ vertex of first cell connect(4)  = 3 identification flag of 4&#94;\\circ vertex of first cell connect(5)  = 4 identification flag of 5&#94;\\circ vertex of first cell connect(6)  = 5 identification flag of 6&#94;\\circ vertex of first cell connect(7)  = 6 identification flag of 7&#94;\\circ vertex of first cell connect(8)  = 7 identification flag of 8&#94;\\circ vertex of first cell second cell connect(9 ) = 0 identification flag of 1&#94;\\circ vertex of second cell connect(10) = 1 identification flag of 2&#94;\\circ vertex of second cell connect(11) = 2 identification flag of 3&#94;\\circ vertex of second cell connect(12) = 3 identification flag of 4&#94;\\circ vertex of second cell connect(13) = 8 identification flag of 5&#94;\\circ vertex of second cell Therefore this connectivity vector convention is more simple than the legacy convention, now we must create also the offset vector that contains the data now missing in the connect vector. The offset\n vector for this mesh can be: first cell offset(1) = 8  => summ of nodes of 1&#94;\\circ cell second cell offset(2) = 13 => summ of nodes of 1&#94;\\circ and 2&#94;\\circ cells The value of every cell-offset can be calculated by the following equation: offset_c=\\sum\\limits_{i=1}&#94;{c}{nvertex_i}\n where offset_c is the value of c&#94;{th} cell and nvertex_i is the number of vertices of i&#94;{th} cell.\n The function VTK_CON_XML does not calculate the connectivity and offset vectors: it writes the connectivity and offset\n vectors conforming the VTK-XML standard, but does not calculate them.\n The vector variable cell_type must conform the VTK-XML standard (see the file VTK-Standard at the\n Kitware homepage) that is the same of the legacy standard. It contains the type of each cells. For the above example this vector is: first cell cell_type(1) = 12 hexahedron type of first cell second cell cell_type(2) = 14 pyramid type of second cell Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: cocp (:) Packed data. character(len=:), public, allocatable :: coc64 Data encoded in base64. integer(kind=I1P), public :: incr Actual id offset increment. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter. integer(kind=I8P), public :: Ncocp Dimension of cocp, packed data.","tags":"","loc":"proc/vtk_con_xml.html","title":"VTK_CON_XML – Lib_VTK_IO"},{"text":"public function Get_Unit(Free_Unit) result(funit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: Free_Unit Free logic unit. Return Value integer Free logic unit. Description Procedure for obtaining a free logic unit for safely opening a file. Note If no units are available, -1 is returned. On-the-fly usage The unit value is returned by the function and also by the optional argument Free_Unit . This allows the function to\n be used directly (on-the-fly) in an open statement like open ( unit = Get_Unit ( myunit ),...) ; read ( myunit )... Variables Type Visibility Attributes Name Initial integer, public :: n1 Counter. integer, public :: ios Inquiring flag. logical, public :: lopen Inquiring flag.","tags":"","loc":"proc/get_unit.html","title":"Get_Unit – Lib_VTK_IO"},{"text":"public elementalfunction Upper_Case(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Function for converting lower case characters of a string to upper case ones. The library uses this function in order to achieve case-insensitivty: all character variables used within the libary functions\n are pre-processed by Uppper_Case function before these variables are used. So the users can call the library functions without\n pay attention of the case of the keywords passed to the functions: calling the function VTK_INI with the string E_IO = VTK_INI('Ascii',...) is equivalent to E_IO = VTK_INI('ASCII',...) . Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter.","tags":"","loc":"proc/upper_case.html","title":"Upper_Case – Lib_VTK_IO"},{"text":"public elementalfunction adjustlt(string) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len(string)) Output string with leading tab characters or blanks removed. Description Extend adjustl to remove tab characters (char(9)).","tags":"","loc":"proc/adjustlt.html","title":"adjustlt – Lib_VTK_IO"},{"text":"public function read_record(from, cf, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: from Offset. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). character(len=:), intent(out), allocatable :: buffer String containing the next record. Return Value integer(kind=i4P) Error trapping flag. Description The read action stops when finding a EOR character (char(10)) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character, public :: c Dummy character storage. integer, public :: n integer, public :: p Counters.","tags":"","loc":"proc/read_record.html","title":"read_record – Lib_VTK_IO"},{"text":"public function move(to_find, repeat, cf, upper, inside, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: to_find Searched XML element. integer, intent(in), optional :: repeat Number of repetitions. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). logical, intent(in), optional :: upper True if return buffer in upper case. character(len=*), intent(in) :: inside XML element where to search 'to_find'. character(len=:), intent(out), allocatable :: buffer String. Return Value integer(kind=I4P) Error trapping flag. Description Advance in VTK file inside the mark 'inside', until find the mark 'to_find', 'repeat' times. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: buff Auxiliary buffer. integer(kind=I4P), public :: rf Real file index. logical, public :: up Readl upper case logical. integer(kind=I4P), public :: n Counter.","tags":"","loc":"proc/move.html","title":"move – Lib_VTK_IO"},{"text":"public function search(cf, from, content, inside, to_find, with_attribute, of_value, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: from Offset. Start point. character(len=:), intent(out), optional allocatable :: content String with the content inside 'to_find' element. character(len=*), intent(in) :: inside XML element where to search 'to_find'. character(len=*), intent(in) :: to_find Searched XML element. character(len=*), intent(in) :: with_attribute XML attribute id. character(len=*), intent(in) :: of_value Attribute value. character(len=:), intent(inout), allocatable :: buffer String. Return Value integer(kind=I4P) Error trapping flag. Description Search in VTK file from position 'pos' inside the mark 'inside', until find the mark 'to_find', eventually, having\n attribute 'with_attribute' matching the value 'of_value'. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index character(len=:), public, allocatable :: strng String. integer(kind=I4P), public :: pos Positional counter. integer(kind=I4P), public :: p1 integer(kind=I4P), public :: p2 integer(kind=I4P), public :: p3 Positional counters.","tags":"","loc":"proc/search.html","title":"search – Lib_VTK_IO"},{"text":"public elementalsubroutine byte_update(vtk, N_Byte) Arguments Type Intent Optional Attributes Name class( Type_VTK_File ), intent(inout) :: vtk Global data of VTK file. integer(kind=I8P), intent(in) :: N_Byte Number of bytes saved. Description Subroutine for updating N_Byte and ioffset pointer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: N_Byte Number of bytes saved.","tags":"","loc":"proc/byte_update.html","title":"byte_update – Lib_VTK_IO"},{"text":"public puresubroutine vtk_update(act, cf, Nvtk, vtk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: act Action: 'ADD' one more element, 'REMOVE' current element file. integer(kind=I4P), intent(inout) :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(inout) :: Nvtk Number of (concurrent) VTK files. type( Type_VTK_File ), intent(inout), allocatable :: vtk (:) VTK files data. Description Subroutine for updating (adding and removing elements into) vtk array. Variables Type Visibility Attributes Name Initial type( Type_VTK_File ), public, allocatable :: vtk_tmp (:) Temporary array of VTK files data.","tags":"","loc":"proc/vtk_update.html","title":"vtk_update – Lib_VTK_IO"},{"text":"public subroutine get_int(case, E_IO, buffer, attrib, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: case Attribute string case. integer(kind=I4P), intent(out), optional :: E_IO Error trapping flag. character(len=*), intent(in) :: buffer String where to search the attrib. character(len=*), intent(in) :: attrib XML attribute id. integer(kind=I4P), intent(out) :: val Returned integer value. Description Get integer value of attribute 'attrib' defined into buffer. Variables Type Visibility Attributes Name Initial integer, public :: pos (2) Position counter. integer, public :: E_IOD Dummy error trapping flag.","tags":"","loc":"proc/get_int.html","title":"get_int – Lib_VTK_IO"},{"text":"public subroutine get_char(case, E_IO, buffer, attrib, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: case Attribute string case. integer(kind=I4P), intent(out), optional :: E_IO Error trapping flag. character(len=*), intent(in) :: buffer String where to search the attrib character(len=*), intent(in) :: attrib XML attribute id character(len=:), intent(out), allocatable :: val Returned string value Description Get character value of attribute 'attrib' defined into buffer. Variables Type Visibility Attributes Name Initial integer, public :: pos (2) Position counter. integer, public :: E_IOD Dummy error trapping flag.","tags":"","loc":"proc/get_char.html","title":"get_char – Lib_VTK_IO"},{"text":"public function VTK_INI(fformat, filename, title, mesh_topology, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat Output format: ASCII or RAW. character(len=*), intent(in) :: filename Name of file. character(len=*), intent(in) :: title Title. character(len=*), intent(in) :: mesh_topology Mesh topology. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing VTK-legacy file. Note This function must be the first to be called. Usage E_IO = VTK_INI ( 'Binary' , 'example.vtk' , 'VTK legacy file' , 'UNSTRUCTURED_GRID' ) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_ini.html","title":"VTK_INI – Lib_VTK_IO"},{"text":"public function PVD_INI_XML(filename, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing a PVD-XML file. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvd_ini_xml.html","title":"PVD_INI_XML – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_R8(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_r8.html","title":"PVD_DAT_XML_R8 – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_R4(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_r4.html","title":"PVD_DAT_XML_R4 – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_I8(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_i8.html","title":"PVD_DAT_XML_I8 – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_I4(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_i4.html","title":"PVD_DAT_XML_I4 – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_I2(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I2P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_i2.html","title":"PVD_DAT_XML_I2 – Lib_VTK_IO"},{"text":"private function PVD_DAT_XML_I1(filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I1P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: rp Real part index.","tags":"","loc":"proc/pvd_dat_xml_i1.html","title":"PVD_DAT_XML_I1 – Lib_VTK_IO"},{"text":"public function PVD_END_XML(cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the PVD-XML file. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/pvd_end_xml.html","title":"PVD_END_XML – Lib_VTK_IO"},{"text":"public interface PVD_DAT_XML Procedure for saving data variable(s) in VTK-XML standard. PVD_DAT_XML is an interface to 6 different functions, depending on the datatype of the timestep Examples of usage Calling PVD_DAT_XML integer ( I4P ) :: timestep ... E_IO = PVD_DAT_XML ( ' file . vtu , timestep ) ... Module Procedures private function PVD_DAT_XML_R8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_R4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I2 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I2P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I1 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I1P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files","tags":"","loc":"interface/pvd_dat_xml.html","title":"PVD_DAT_XML – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DA_R8_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: XYZp (:) Packed coordinates data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_strg_1da_r8_write.html","title":"VTK_GEO_XML_STRG_1DA_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DA_R8_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: XYZp (:) Packed coordinates data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_geo_xml_strg_3da_r8_write.html","title":"VTK_GEO_XML_STRG_3DA_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DAP_R8_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: XYZp (:) Packed coordinates data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_strg_1dap_r8_write.html","title":"VTK_GEO_XML_STRG_1DAP_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DAP_R8_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays, packed API). Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: XYZp (:) Packed coordinates data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_geo_xml_strg_3dap_r8_write.html","title":"VTK_GEO_XML_STRG_3DAP_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DA_R4_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_strg_1da_r4_write.html","title":"VTK_GEO_XML_STRG_1DA_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DA_R4_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_geo_xml_strg_3da_r4_write.html","title":"VTK_GEO_XML_STRG_3DA_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DAP_R4_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays, packed API). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_strg_1dap_r4_write.html","title":"VTK_GEO_XML_STRG_1DAP_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DAP_R4_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API) [1:3,nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays, packed API). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: nx integer(kind=I4P), public :: ny integer(kind=I4P), public :: nz Counters.","tags":"","loc":"proc/vtk_geo_xml_strg_3dap_r4_write.html","title":"VTK_GEO_XML_STRG_3DAP_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_RECT_R8_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R8P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R8P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R8P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R8P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_rect_r8_write.html","title":"VTK_GEO_XML_RECT_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_RECT_R4_WRITE(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R4P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R4P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R4P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R4P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_rect_r4_write.html","title":"VTK_GEO_XML_RECT_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_R8_WRITE(NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: X (1:NN) X coordinates. real(kind=R8P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R8P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R8P), public, allocatable :: XYZa (:) X, Y, Z coordinates. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_unst_r8_write.html","title":"VTK_GEO_XML_UNST_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_PACK_R8_WRITE(NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P, packed API). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R8P), public, allocatable :: XYZa (:) X, Y, Z coordinates. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_unst_pack_r8_write.html","title":"VTK_GEO_XML_UNST_PACK_R8_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_R4_WRITE(NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: X (1:NN) X coordinates. real(kind=R4P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R4P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R4P), public, allocatable :: XYZa (:) X, Y, Z coordinates. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_unst_r4_write.html","title":"VTK_GEO_XML_UNST_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_PACK_R4_WRITE(NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P, packed API). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. real(kind=R4P), public, allocatable :: XYZa (:) X, Y, Z coordinates. integer(kind=I1P), public, allocatable :: XYZp (:) Packed data. character(len=:), public, allocatable :: XYZ64 X, Y, Z coordinates encoded in base64. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_geo_xml_unst_pack_r4_write.html","title":"VTK_GEO_XML_UNST_PACK_R4_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_CLOSEP_WRITE(cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for closing mesh block data. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_geo_xml_closep_write.html","title":"VTK_GEO_XML_CLOSEP_WRITE – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DA_R8_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_1da_r8_read.html","title":"VTK_GEO_XML_STRG_1DA_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DA_R8_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_3da_r8_read.html","title":"VTK_GEO_XML_STRG_3DA_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DAP_R8_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_1dap_r8_read.html","title":"VTK_GEO_XML_STRG_1DAP_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DAP_R8_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: l integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_3dap_r8_read.html","title":"VTK_GEO_XML_STRG_3DAP_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DA_R4_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_1da_r4_read.html","title":"VTK_GEO_XML_STRG_1DA_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DA_R4_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_3da_r4_read.html","title":"VTK_GEO_XML_STRG_3DA_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_1DAP_R4_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_1dap_r4_read.html","title":"VTK_GEO_XML_STRG_1DAP_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_STRG_3DAP_R4_READ(nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: l integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_strg_3dap_r4_read.html","title":"VTK_GEO_XML_STRG_3DAP_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_RECT_R8_READ(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: fmtX character(len=:), public, allocatable :: fmtY character(len=:), public, allocatable :: fmtZ character(len=:), public, allocatable :: type character(len=:), public, allocatable :: typeX character(len=:), public, allocatable :: typeY character(len=:), public, allocatable :: typeZ character(len=:), public, allocatable :: data integer(kind=I4P), public :: offsX integer(kind=I4P), public :: offsY integer(kind=I4P), public :: offsZ integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_rect_r8_read.html","title":"VTK_GEO_XML_RECT_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_RECT_R4_READ(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: aux Auxiliary string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: fmtX character(len=:), public, allocatable :: fmtY character(len=:), public, allocatable :: fmtZ character(len=:), public, allocatable :: type character(len=:), public, allocatable :: typeX character(len=:), public, allocatable :: typeY character(len=:), public, allocatable :: typeZ character(len=:), public, allocatable :: data integer(kind=I4P), public :: offsX integer(kind=I4P), public :: offsY integer(kind=I4P), public :: offsZ integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_rect_r4_read.html","title":"VTK_GEO_XML_RECT_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_R8_READ(NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_unst_r8_read.html","title":"VTK_GEO_XML_UNST_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_PACK_R8_READ(NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R8P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_unst_pack_r8_read.html","title":"VTK_GEO_XML_UNST_PACK_R8_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_R4_READ(NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_unst_r4_read.html","title":"VTK_GEO_XML_UNST_R4_READ – Lib_VTK_IO"},{"text":"private function VTK_GEO_XML_UNST_PACK_R4_READ(NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. character(len=:), public, allocatable :: s_buffer Buffer string. character(len=:), public, allocatable :: fmt character(len=:), public, allocatable :: type character(len=:), public, allocatable :: data integer(kind=I4P), public :: np integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: offs integer(kind=I4P), public :: N_Byte integer(kind=I4P), public :: pos integer(kind=I4P), public :: s integer(kind=I1P), public, allocatable :: dI1P (:) real(kind=R4P), public, allocatable :: XYZp (:)","tags":"","loc":"proc/vtk_geo_xml_unst_pack_r4_read.html","title":"VTK_GEO_XML_UNST_PACK_R4_READ – Lib_VTK_IO"},{"text":"public interface VTK_GEO_XML_WRITE Export (write) mesh with different topologies in VTK-XML standard. VTK_GEO_XML is an interface to 15 different functions; there are 2 functions for each of 3 topologies supported and a function\n for closing XML pieces: one function for mesh coordinates with R8P precision and one for mesh coordinates with R4P precision.\n 1D/3D-rank arrays and packed API for any kinds For StructuredGrid there are 4 functions for each real kinds: inputs are 1D-rank arrays: X[1:NN],Y[1:NN],Z[1:NN]; inputs are 3D-rank arrays: X[nx1:nx2,ny1:ny2,nz1:nz2],Y[nx1:nx2,ny1:ny2,nz1:nz2],Z[nx1:nx2,ny1:ny2,nz1:nz2]; input is 1D-rank array (packed API): XYZ[1:3,1:NN]; input is 3D-rank array (packed API): XYZ[1:3,nx1:nx2,ny1:ny2,nz1:nz2]. For UnStructuredGrid there are 2 functions for each real kinds: inputs are 1D arrays: X[1:NN],Y[1:NN],Z[1:NN]; input is 1D array (packed API): XYZ[1:3,1:NN]. VTK_GEO_XML must be called after VTK_INI_XML. It saves the mesh geometry. The inputs that must be passed\n change depending on the topologies chosen. Not all VTK topologies have been implemented ( polydata topologies are absent). Note The XML standard is more powerful than legacy. XML file can contain more than 1 mesh with its\n associated variables. Thus there is the necessity to close each pieces that compose the data-set saved in the\n XML file. The VTK_GEO_XML called in the close piece format is used just to close the\n current piece before saving another piece or closing the file. Examples of usage Structured grid calling integer ( I4P ) :: nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN real ( R8P ) :: X ( 1 : NN ), Y ( 1 : NN ), Z ( 1 : NN ) ... E_IO = VTK_GEO_XML ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , Nn , X , Y , Z ) Rectilinear grid calling integer ( I4P ) :: nx1 , nx2 , ny1 , ny2 , nz1 , nz2 real ( R8P ) :: X ( nx1 : nx2 ), Y ( ny1 : ny2 ), Z ( nz1 : nz2 ) ... E_IO = VTK_GEO_XML ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z ) Unstructured grid calling integer ( I4P ) :: Nn , Nc real ( R8P ) :: X ( 1 : Nn ), Y ( 1 : Nn ), Z ( 1 : Nn ) ... E_IO = VTK_GEO_XML ( Nn , Nc , X , Y , Z ) Closing piece calling E_IO = VTK_GEO_XML () Module Procedures private function VTK_GEO_XML_STRG_1DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays, packed API). private function VTK_GEO_XML_STRG_1DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API) [1:3,nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays, packed API). private function VTK_GEO_XML_RECT_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R8P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R8P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R8P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R4P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R4P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R4P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R4P). private function VTK_GEO_XML_UNST_R8_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: X (1:NN) X coordinates. real(kind=R8P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R8P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R4_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P, packed API). private function VTK_GEO_XML_UNST_R4_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: X (1:NN) X coordinates. real(kind=R4P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R4P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P). private function VTK_GEO_XML_UNST_PACK_R8_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P, packed API). private function VTK_GEO_XML_CLOSEP_WRITE (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for closing mesh block data.","tags":"","loc":"interface/vtk_geo_xml_write.html","title":"VTK_GEO_XML_WRITE – Lib_VTK_IO"},{"text":"public interface VTK_GEO_XML_READ Import (read) mesh with different topologies in VTK-XML standard. VTK_GEO_XML_READ is an interface to 14 different functions; there are 2 functions for each of 3 topologies supported and a\n function for closing XML pieces: one function for mesh coordinates with R8P (Ok!) precision and one for mesh coordinates with\n R4P (Not tested!) precision. 1D/3D-rank arrays and packed API for ascii and raw data, binary is not implemented yet! For StructuredGrid there are 4 functions for each real kinds: inputs are 1D-rank arrays: X[1:NN],Y[1:NN],Z[1:NN]; (Not tested!) inputs are 3D-rank arrays: X[nx1:nx2,ny1:ny2,nz1:nz2],Y[nx1:nx2,ny1:ny2,nz1:nz2],Z[nx1:nx2,ny1:ny2,nz1:nz2]; (Not tested!) input is 1D-rank array (packed API): XYZ[1:3,1:NN]; (Not tested!) input is 3D-rank array (packed API): XYZ[1:3,nx1:nx2,ny1:ny2,nz1:nz2]. (Not tested!) For UnStructuredGrid there are 2 functions for each real kinds: inputs are 1D arrays: X[1:NN],Y[1:NN],Z[1:NN]; (Ok!) input is 1D array (packed API): XYZ[1:3,1:NN]. (Not tested!) VTK_GEO_XML_READ must be called after VTK_INI_XML_READ. It reads the mesh geometry. The inputs that must be passed\n change depending on the topologies chosen. Not all VTK topologies have been implemented ( polydata topologies are absent). Note The XML standard is more powerful than legacy. XML file can contain more than 1 mesh with its\n associated variables. Thus there is the necessity to close each pieces that compose the data-set saved in the\n XML file. The VTK_GEO_XML_READ uses the close piece format is used just to close the\n current piece before saving another piece or closing the file. Examples of usage Module Procedures private function VTK_GEO_XML_STRG_1DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R8_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R4_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R4_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R8_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P).","tags":"","loc":"interface/vtk_geo_xml_read.html","title":"VTK_GEO_XML_READ – Lib_VTK_IO"},{"text":"public function VTK_END(cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTK-XML file. Usage E_IO = VTK_END () Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_end.html","title":"VTK_END – Lib_VTK_IO"},{"text":"public function VTK_CON(NC, connect, cell_type, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC Number of cells. integer(kind=I4P), intent(in) :: connect (:) Mesh connectivity. integer(kind=I4P), intent(in) :: cell_type (1:NC) VTK cell type. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh connectivity. Function that must be used when unstructured grid is used, it saves the connectivity of the unstructured gird. Note The vector connect must follow the VTK-legacy standard. It is passed as assumed-shape array\n because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following\n equation: dc = NC + \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i }\n where dc is connectivity vector dimension and nvertex_i is the number of vertices of i&#94;{th} cell. The VTK-\n legacy standard for the mesh connectivity is quite obscure at least at first sight. It is more simple analyzing an example.\n Suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices) and\n suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices.\n The above equation !> gives dc=2+8+5=15. The connectivity vector for this mesh can be: first cell connect(1)  = 8 number of vertices of first cell connect(2)  = 0 identification flag of 1&#94;\\circ vertex of first cell connect(3)  = 1 identification flag of 2&#94;\\circ vertex of first cell connect(4)  = 2 identification flag of 3&#94;\\circ vertex of first cell connect(5)  = 3 identification flag of 4&#94;\\circ vertex of first cell connect(6)  = 4 identification flag of 5&#94;\\circ vertex of first cell connect(7)  = 5 identification flag of 6&#94;\\circ vertex of first cell connect(8)  = 6 identification flag of 7&#94;\\circ vertex of first cell connect(9)  = 7 identification flag of 8&#94;\\circ vertex of first cell second cell connect(10) = 5 number of vertices of first cell connect(11) = 0 identification flag of 1&#94;\\circ vertex of second cell connect(12) = 1 identification flag of 2&#94;\\circ vertex of second cell connect(13) = 2 identification flag of 3&#94;\\circ vertex of second cell connect(14) = 3 identification flag of 4&#94;\\circ vertex of second cell connect(15) = 8 identification flag of 5&#94;\\circ vertex of second cell Note that the first 4 identification flags of pyramid vertices as the same of the first 4 identification flags of\n the hexahedron because the two cells share this face. It is also important to note that the identification flags start\n form $0$ value: this is impose to the VTK standard. The function VTK_CON does not calculate the connectivity vector: it\n writes the connectivity vector conforming the VTK standard, but does not calculate it.\n The vector variable cell_type must conform the VTK-legacy standard (see the file VTK-Standard at the\n Kitware homepage). It contains the type of each cells. For the above example this vector is: first cell cell_type(1) = 12 hexahedron type of first cell second cell cell_type(2) = 14 pyramid type of second cell Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: ncon Dimension of connectivity vector. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_con.html","title":"VTK_CON – Lib_VTK_IO"},{"text":"public function VTK_DAT(NC_NN, var_location, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes of field. character(len=*), intent(in) :: var_location Location of saving variables: cell for cell-centered, node for node-centered. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. Function that must be called before saving the data related to geometric mesh, this function initializes the\n saving of data variables indicating the type (node or cell centered) of variables that will be saved. Note A single file can contain both cell and node centered variables. In this case the VTK_DAT function must be\n called two times, before saving cell-centered variables and before saving node-centered variables. Examples of usage Saving node data E_IO = VTK_DAT_XML ( 50 , 'node' ) Saving cell data E_IO = VTK_DAT_XML ( 50 , 'cell' ) Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_dat.html","title":"VTK_DAT – Lib_VTK_IO"},{"text":"private function VTK_VAR_SCAL_R8(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_var_scal_r8.html","title":"VTK_VAR_SCAL_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_SCAL_R4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_var_scal_r4.html","title":"VTK_VAR_SCAL_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_SCAL_I4(NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index.","tags":"","loc":"proc/vtk_var_scal_i4.html","title":"VTK_VAR_SCAL_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_VECT_R8(vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R8P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R8P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_vect_r8.html","title":"VTK_VAR_VECT_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_VECT_R4(vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R4P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_vect_r4.html","title":"VTK_VAR_VECT_R4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_VECT_I4(NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:NC_NN) X component of vector. integer(kind=I4P), intent(in) :: varY (1:NC_NN) Y component of vector. integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 Counter.","tags":"","loc":"proc/vtk_var_vect_i4.html","title":"VTK_VAR_VECT_I4 – Lib_VTK_IO"},{"text":"private function VTK_VAR_TEXT_R8(NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R8P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_text_r8.html","title":"VTK_VAR_TEXT_R8 – Lib_VTK_IO"},{"text":"private function VTK_VAR_TEXT_R4(NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R4P). Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string. integer(kind=I4P), public :: rf Real file index. integer(kind=I4P), public :: n1 integer(kind=I4P), public :: n2 Counters.","tags":"","loc":"proc/vtk_var_text_r4.html","title":"VTK_VAR_TEXT_R4 – Lib_VTK_IO"},{"text":"public interface VTK_VAR Procedure for saving data variable(s) in VTK-legacy standard. VTK_VAR is an interface to 8 different functions, there are 3 functions for scalar variables, 3 functions for vectorial\n variables and 2 functions texture variables: scalar and vectorial data can be R8P, R4P and I4P data while texture variables can\n be only R8P or R4P. This function saves the data variables related to geometric mesh. Note The inputs that must be passed change depending on the data\n variables type. Examples of usage Scalar data calling integer ( I4P ) :: NN real ( R4P ) :: var ( 1 : NN ) ... E_IO = VTK_VAR ( NN , 'Sca' , var ) ... Vectorial data calling integer ( I4P ) :: NN real ( R4P ) :: varX ( 1 : NN ), varY ( 1 : NN ), varZ ( 1 : NN ) ... E_IO = VTK_VAR ( 'vect' , NN , 'Vec' , varX , varY , varZ ) ... Module Procedures private function VTK_VAR_SCAL_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P). private function VTK_VAR_SCAL_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P). private function VTK_VAR_SCAL_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P). private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R8P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R8P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P). private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R4P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P). private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:NC_NN) X component of vector. integer(kind=I4P), intent(in) :: varY (1:NC_NN) Y component of vector. integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P). private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R8P). private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R4P).","tags":"","loc":"interface/vtk_var.html","title":"VTK_VAR – Lib_VTK_IO"},{"text":"public function VTM_INI_XML(filename) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name of output VTM file. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK-XML files. Variables Type Visibility Attributes Name Initial character(len=maxlen), public :: s_buffer Buffer string.","tags":"","loc":"proc/vtm_ini_xml.html","title":"VTM_INI_XML – Lib_VTK_IO"},{"text":"public function VTM_BLK_XML(block_action, name) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: block_action Block action: OPEN or CLOSE block. character(len=*), intent(in), optional :: name Block name. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for opening or closing a block level of a VTM file.","tags":"","loc":"proc/vtm_blk_xml.html","title":"VTM_BLK_XML – Lib_VTK_IO"},{"text":"private function VTM_WRF_XML_array(nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: nlist (:) List names attributed to wrapped files. character(len=*), intent(in) :: flist (:) List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. Note the list is passed as an array. Example of usage: 3 files blocks E_IO = VTK_WRF_XML ( flist = [ 'file_1.vts' , 'file_2.vts' , 'file_3.vtu' ]) Example of usage: 3 files blocks with custom name E_IO = VTK_WRF_XML ( flist = [ 'file_1.vts' , 'file_2.vts' , 'file_3.vtu' ],& nlist = [ 'block-bar' , 'block-foo' , 'block-baz' ]) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: f File counter.","tags":"","loc":"proc/vtm_wrf_xml_array.html","title":"VTM_WRF_XML_array – Lib_VTK_IO"},{"text":"private function VTM_WRF_XML_string(delimiter, nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: delimiter Delimiter of files into files list string. character(len=*), intent(in), optional :: nlist List names attributed to wrapped files. character(len=*), intent(in) :: flist List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. Note the list is passed as a single string. The delimiter of each file can be customized: default value is \"&\". For supporting\n compiler with not varying string support the maximum delimiter length is fixed to 50. Examples of usage Example: 3 files block with default delimiter E_IO = VTK_WRF_XML ( flist = 'file_1.vts&file_2.vts&file_3.vtu' ) Example: 3 files block with custom name E_IO = VTK_WRF_XML ( flist = 'file_1.vts&file_2.vts&file_3.vtu' ,& nlist = 'foo&bar&baz' ) Example: 2 files block with custom delimiter (!!) E_IO = VTK_WRF_XML ( flist = 'file_1.vts!!file_2.vts' , delimiter = '!!' ) Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: f File counter. character(len=50), public :: delimit Delimiter value. character(len=len(flist)), public :: flistd Dummy files list. character(len=len(flist)), public :: nlistd Dummy names list. character(len=len(flist)), public :: dummy (1:2) Dummy strings. integer(kind=I4P), public :: d_len Delimiter character length. integer(kind=I4P), public :: i integer(kind=I4P), public :: n Counters.","tags":"","loc":"proc/vtm_wrf_xml_string.html","title":"VTM_WRF_XML_string – Lib_VTK_IO"},{"text":"public function VTM_END_XML() result(E_IO) Arguments None Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTM-XML file.","tags":"","loc":"proc/vtm_end_xml.html","title":"VTM_END_XML – Lib_VTK_IO"},{"text":"public interface VTM_WRF_XML Procedure for saving the list of VTK-XML wrapped files by a mutliblock VTM file. VTK_WRF_XML is an interface to 2 different functions, one for files list passed as an array and one for files list passed\n a single string. If a single string is used, the delimiter of each file can be customized, while the default values is '&'. Examples of usage Example with array files list: 3 files block with default delimiter E_IO = VTK_WRF_XML ( flist = [ 'file_1.vts' , 'file_2.vts' , 'file_3.vtu' ]) Example with single string files list: 3 files block with default delimiter E_IO = VTK_WRF_XML ( flist = 'file_1.vts&file_2.vts&file_3.vtu' ) Example with single string files list: 2 files block with custom delimiter (!!) E_IO = VTK_WRF_XML ( flist = 'file_1.vts!!file_2.vts' , delimiter = '!!' ) Module Procedures private function VTM_WRF_XML_array (nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: nlist (:) List names attributed to wrapped files. character(len=*), intent(in) :: flist (:) List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. private function VTM_WRF_XML_string (delimiter, nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: delimiter Delimiter of files into files list string. character(len=*), intent(in), optional :: nlist List names attributed to wrapped files. character(len=*), intent(in) :: flist List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file.","tags":"","loc":"interface/vtm_wrf_xml.html","title":"VTM_WRF_XML – Lib_VTK_IO"},{"text":"public subroutine test_stress() Arguments None Description Procedure for testing all functions. R4P and R8P mesh data, 1D and 3D arrays inputs, standard (X,Y,Z,... separated arrays) and\n packed API (X,Y,Z,... packed into a single array). All available formats are used. The StructuredGrid topology is used. Note This subroutine is designed not as an example rather than a comprehensive stress-tester for functions of any kind/rank. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 0_I4P integer(kind=I4P), public, parameter :: nx2 = 9_I4P integer(kind=I4P), public, parameter :: ny1 = 0_I4P integer(kind=I4P), public, parameter :: ny2 = 5_I4P integer(kind=I4P), public, parameter :: nz1 = 0_I4P integer(kind=I4P), public, parameter :: nz2 = 5_I4P integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1) real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: x real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: y real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: z real(kind=R8P), public, dimension(1:3,nx1:nx2,ny1:ny2,nz1:nz2) :: xyz real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: v_R integer(kind=I8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: v_I real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: vX_R real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: vY_R real(kind=R8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: Vz_R integer(kind=I8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: vX_I integer(kind=I8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: vY_I integer(kind=I8P), public, dimension(    nx1:nx2,ny1:ny2,nz1:nz2) :: Vz_I real(kind=R8P), public, dimension(1:4,nx1:nx2,ny1:ny2,nz1:nz2) :: vP_R integer(kind=I8P), public, dimension(1:4,nx1:nx2,ny1:ny2,nz1:nz2) :: vP_I integer(kind=I4P), public :: E_IO Functions function save_node_variables(threeD) result(E_IO) Arguments Type Intent Optional Attributes Name logical, intent(in) :: threeD Flag for checking the rank-dimensions of outputs. Return Value integer(kind=I4P) Error trapping flag. Description Procedure for saving StructuredGrid files. function save_strg(x64, y64, z64, xyz64, x32, y32, z32, xyz32, threeD, out_f) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: x64 (:,:,:) X Coordinates components (64 bits). real(kind=R8P), intent(in), optional :: y64 (:,:,:) Y Coordinates components (64 bits). real(kind=R8P), intent(in), optional :: z64 (:,:,:) Z Coordinates components (64 bits). real(kind=R8P), intent(in), optional :: xyz64 (:,:,:,:) Packed coordinates components (64 bits). real(kind=R4P), intent(in), optional :: x32 (:,:,:) X Coordinates components (32 bits). real(kind=R4P), intent(in), optional :: y32 (:,:,:) Y Coordinates components (32 bits). real(kind=R4P), intent(in), optional :: z32 (:,:,:) Z Coordinates components (32 bits). real(kind=R4P), intent(in), optional :: xyz32 (:,:,:,:) Packed coordinates components (32 bits). logical, intent(in) :: threeD Flag for checking the rank-dimensions of outputs. character(len=*), intent(in) :: out_f Output format. Return Value integer(kind=I4P) Error trapping flag. Description Procedure for saving node-located variables. Subroutines subroutine initialize() Arguments None Description Procedure for initializing data.","tags":"","loc":"proc/test_stress.html","title":"test_stress – Lib_VTK_IO"},{"text":"public subroutine test_unst() Arguments None Description Procedure for testing UnstructuredGrid functions. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: Nn = 27_I4P integer(kind=I4P), public, parameter :: Ne = 11_I4P real(kind=R4P), public, dimension(1:Nn) :: x = [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2] real(kind=R4P), public, dimension(1:Nn) :: y = [0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] real(kind=R4P), public, dimension(1:Nn) :: z = [0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6] integer(kind=I1P), public, dimension(1:Ne) :: cell_type = [12_I1P,12_I1P,10_I1P,10_I1P,7_I1P,6_I1P,9_I1P,5_I1P,5_I1P,3_I1P,1_I1P] integer(kind=I4P), public, dimension(1:Ne) :: offset = [8_I4P,16_I4P,20_I4P,24_I4P,30_I4P,36_I4P,40_I4P,43_I4P,46_I4P,48_I4P,49_I4P] integer(kind=I4P), public, dimension(1:49) :: connect real(kind=R8P), public, dimension(1:Nn) :: v integer(kind=I4P), public, dimension(1:Nn) :: v_X integer(kind=I4P), public, dimension(1:Nn) :: v_Y integer(kind=I4P), public, dimension(1:Nn) :: v_Z integer(kind=I4P), public :: E_IO","tags":"","loc":"proc/test_unst.html","title":"test_unst – Lib_VTK_IO"},{"text":"public subroutine test_strg() Arguments None Description Procedure for testing StructuredGrid functions. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 0_I4P integer(kind=I4P), public, parameter :: nx2 = 9_I4P integer(kind=I4P), public, parameter :: ny1 = 0_I4P integer(kind=I4P), public, parameter :: ny2 = 5_I4P integer(kind=I4P), public, parameter :: nz1 = 0_I4P integer(kind=I4P), public, parameter :: nz2 = 5_I4P integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1) real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: x real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: y real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: z real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: v_R integer(kind=I4P), public :: E_IO integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k","tags":"","loc":"proc/test_strg.html","title":"test_strg – Lib_VTK_IO"},{"text":"public subroutine test_rect() Arguments None Description Procedure for testing RectilinearGrid functions. Note This subroutine also shows the usage of FieldData functions that are useful for saving global auxiliary data, e.g. time,\n time step, ecc. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 0_I4P integer(kind=I4P), public, parameter :: nx2 = 16_I4P integer(kind=I4P), public, parameter :: ny1 = 0_I4P integer(kind=I4P), public, parameter :: ny2 = 16_I4P integer(kind=I4P), public, parameter :: nz1 = 0_I4P integer(kind=I4P), public, parameter :: nz2 = 16_I4P integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1) real(kind=R8P), public :: x (nx1:nx2) real(kind=R8P), public :: y (ny1:ny2) real(kind=R8P), public :: z (nz1:nz2) real(kind=R8P), public :: x1 = -3._R8P real(kind=R8P), public :: x2 = 3._R8P real(kind=R8P), public :: y1 = -2._R8P real(kind=R8P), public :: y2 = 0.25_R8P real(kind=R8P), public :: z1 = -2._R8P real(kind=R8P), public :: z2 = 0.16_R8P integer(kind=I4P), public :: v (1:nn) integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: n integer(kind=I4P), public :: E_IO","tags":"","loc":"proc/test_rect.html","title":"test_rect – Lib_VTK_IO"},{"text":"public subroutine test_punst() Arguments None Description Procedure for testing parallel (partitioned) PStructuredGrid functions. Note Note that the two parts are completely independet. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: Nn = 27_I4P integer(kind=I4P), public, parameter :: Ne = 11_I4P real(kind=R4P), public, dimension(1:Nn) :: x = [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2] real(kind=R4P), public, dimension(1:Nn) :: y = [0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] real(kind=R4P), public, dimension(1:Nn) :: z = [0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6] integer(kind=I1P), public, dimension(1:Ne) :: cell_type = [12_I1P,12_I1P,10_I1P,10_I1P,7_I1P,6_I1P,9_I1P,5_I1P,5_I1P,3_I1P,1_I1P] integer(kind=I4P), public, dimension(1:Ne) :: offset = [8_I4P,16_I4P,20_I4P,24_I4P,30_I4P,36_I4P,40_I4P,43_I4P,46_I4P,48_I4P,49_I4P] integer(kind=I4P), public, dimension(1:49) :: connect real(kind=R8P), public, dimension(1:Nn) :: v integer(kind=I4P), public, dimension(1:Nn) :: v_X integer(kind=I4P), public, dimension(1:Nn) :: v_Y integer(kind=I4P), public, dimension(1:Nn) :: v_Z integer(kind=I4P), public :: E_IO","tags":"","loc":"proc/test_punst.html","title":"test_punst – Lib_VTK_IO"},{"text":"public subroutine test_pstrg() Arguments None Description Procedure for testing parallel (partitioned) PStructuredGrid functions. The mesh is a simple prism partitioned into two pieces along x direction at ordinate i=nx2_p(1). y &#94;\n   |               ny2 +-----------------+--------------+\n   |                   |                 |              |\n   |                   |                 |              |\n   |                   |                 |              |\n   |                   |                 |              |\n   o-------->      ny1 +-----------------+--------------+\n            x         nx1               i=nx2_p(1)     nx2 Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 0_I4P integer(kind=I4P), public, parameter :: nx2 = 9_I4P integer(kind=I4P), public, parameter :: ny1 = 0_I4P integer(kind=I4P), public, parameter :: ny2 = 5_I4P integer(kind=I4P), public, parameter :: nz1 = 0_I4P integer(kind=I4P), public, parameter :: nz2 = 5_I4P integer(kind=I4P), public, parameter :: nx1_p (1:2) = [nx1,4_I4P] integer(kind=I4P), public, parameter :: nx2_p (1:2) = [4_I4P,nx2] integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1) integer(kind=I4P), public, parameter :: nn_p (1:2) = [(nx2_p(1)-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1),(nx2_p(2)-nx2_p(1)+1)*(ny2-ny1+1)*(nz2-nz1+1)] real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: x real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: y real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: z integer(kind=I4P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: v integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: p integer(kind=I4P), public :: mf (1:2) integer(kind=I4P), public :: E_IO","tags":"","loc":"proc/test_pstrg.html","title":"test_pstrg – Lib_VTK_IO"},{"text":"public subroutine test_vtm() Arguments None Description Procedure for testing multi-blocks VTM functions. There are 4 subset of data organized into 2 blocks. All the subsets are simple StructuredGrid prisms shifted along x direction. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 0_I4P integer(kind=I4P), public, parameter :: nx2 = 9_I4P integer(kind=I4P), public, parameter :: ny1 = 0_I4P integer(kind=I4P), public, parameter :: ny2 = 5_I4P integer(kind=I4P), public, parameter :: nz1 = 0_I4P integer(kind=I4P), public, parameter :: nz2 = 5_I4P integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1)*(ny2-ny1+1)*(nz2-nz1+1) real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: x real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: y real(kind=R8P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: z integer(kind=I4P), public, dimension(nx1:nx2,ny1:ny2,nz1:nz2) :: v integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: b integer(kind=I4P), public :: mf (1:4) integer(kind=I4P), public :: E_IO","tags":"","loc":"proc/test_vtm.html","title":"test_vtm – Lib_VTK_IO"},{"text":"public subroutine test_openmp(Nf_tot) Uses: omp_lib Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nf_tot Total number of files saved. Description Procedure for testing the libray in an OpenMP parallel framework. It is used for testing thread-safe capability and the\n library speedup into OpenMP parallel framework. The output is a parallel (partitioned) PStructuredGrid file. Note The whole grid is composed of blocks of 32x32x32 structured mesh. The total number of blocks/files, Nf_tot, is passed as\n argument. The whole grid is built up composing the blocks along the X axis with a regular shift as following: y &#94;\n   |               ny2 +------------+------------+------------+------///////////-----+\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   o-------->      ny1 +------------+------------+------------+------///////////-----+\n            x         nx1          nx2    2*(nx2-nx+1)  3*(nx2-nx+1)          Nf_tot*(nx2-nx+1) Note When the total number of blocks/files, Nf_tot, is not an integral of the number of threads used, Nths, the last\n thread saves its own files (Nf_tot/Nths) plus the remainder blocks/files (mod(Nf_tot,Nths)). As a consequence the last\n thread could has different elapsed time and it could degrade the speedup. Therefore the subroutine prints to stdout the\n maximum and minimum elapsed time among the threads as well the average elapsed time in order to facilitate the assessing\n of the parallel scalability. Note It is important to note that the output files initialization and finalization must be done outside the parallel ambient. Note The array containing the files indexes could be shared among threads, but the counter of this array ('p' in this example)\n must be private. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 1_I4P First node in x direction. integer(kind=I4P), public, parameter :: nx2 = 32_I4P Last node in x direction. integer(kind=I4P), public, parameter :: ny1 = 1_I4P First node in y direction. integer(kind=I4P), public, parameter :: ny2 = 32_I4P Last node in y direction. integer(kind=I4P), public, parameter :: nz1 = 1_I4P First node in z direction. integer(kind=I4P), public, parameter :: nz2 = 32_I4P Last node in z direction. integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1_I4P)*(ny2-ny1+1_I4P)*(nz2-nz1+1_I4P) Whole grid extents. real(kind=R8P), public :: x (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in x direction. real(kind=R8P), public :: y (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in y direction. real(kind=R8P), public :: z (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in z direction. real(kind=R8P), public :: xf (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in x shifted by file offset. integer(kind=I4P), public, allocatable :: v (:,:,:,:) Variable associated to nodes. integer(kind=I4P), public :: mf (1:Nf_tot) File indexes. integer(kind=I4P), public :: Nths Number of concurrent threads. integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: f integer(kind=I4P), public :: nxf integer(kind=I4P), public :: th Counters. integer(kind=I4P), public :: E_IO Error trapping flag. real(kind=R8P), public :: vtk_start real(kind=R8P), public :: vtk_stop Timing variables. real(kind=R8P), public, allocatable :: t (:) Timing variables.","tags":"","loc":"proc/test_openmp.html","title":"test_openmp – Lib_VTK_IO"},{"text":"public subroutine test_mpi(Nf_tot) Uses: mpi Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nf_tot Total number of files saved. Description Procedure for testing the library in an MPI parallel framework. It is used for testing the process-safe capability and the\n library speedup into MPI parallel framework.  The output is a parallel (partitioned) PStructuredGrid file. Note The whole grid is composed of blocks of 32x32x32 structured mesh. The total number of blocks/files, Nf_tot, is passed as\n argument. The whole grid is built up composing the blocks along the X axis with a regular shift as following: y &#94;\n   |               ny2 +------------+------------+------------+------///////////-----+\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   |                   |            |            |            |                      |\n   o-------->      ny1 +------------+------------+------------+------///////////-----+\n            x         nx1          nx2    2*(nx2-nx+1)  3*(nx2-nx+1)          Nf_tot*(nx2-nx+1) Note When the total number of blocks/files, Nf_tot, is not an integral of the number of processes used, nproc, the last\n process saves its own files (Nf_tot/nproc) plus the remainder blocks/files (mod(Nf_tot,nproc)). As a consequence the last\n process could has different elapsed time and it could degrade the speedup. Therefore the subroutine prints to stdout the\n maximum and minimum elapsed time among the processes as well the average elapsed time in order to facilitate the assessing\n of the parallel scalability. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: nx1 = 1_I4P First node in x direction. integer(kind=I4P), public, parameter :: nx2 = 32_I4P Last node in x direction. integer(kind=I4P), public, parameter :: ny1 = 1_I4P First node in y direction. integer(kind=I4P), public, parameter :: ny2 = 32_I4P Last node in y direction. integer(kind=I4P), public, parameter :: nz1 = 1_I4P First node in z direction. integer(kind=I4P), public, parameter :: nz2 = 32_I4P Last node in z direction. integer(kind=I4P), public, parameter :: nn = (nx2-nx1+1_I4P)*(ny2-ny1+1_I4P)*(nz2-nz1+1_I4P) Whole grid extents. real(kind=R8P), public :: x (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in x direction. real(kind=R8P), public :: y (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in y direction. real(kind=R8P), public :: z (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in z direction. integer(kind=I4P), public :: v (nx1:nx2,ny1:ny2,nz1:nz2) Variable associated to nodes. real(kind=R8P), public :: xf (nx1:nx2,ny1:ny2,nz1:nz2) Coordinates in x shifted by file offset direction. integer(kind=I4P), public :: i integer(kind=I4P), public :: j integer(kind=I4P), public :: k integer(kind=I4P), public :: f integer(kind=I4P), public :: foffset integer(kind=I4P), public :: nxf Counters. integer(kind=I4P), public :: myrank Rank of current process. integer(kind=I4P), public :: Nf Number of files saved by the current process. integer(kind=I4P), public :: nproc Number of concurrent processes. integer(kind=I4P), public :: E_IO Error trapping flag. real(kind=R8P), public :: vtk_start real(kind=R8P), public :: vtk_stop real(kind=R8P), public :: t real(kind=R8P), public :: tmax real(kind=R8P), public :: tmin real(kind=R8P), public :: tmean Timing variables.","tags":"","loc":"proc/test_mpi.html","title":"test_mpi – Lib_VTK_IO"},{"text":"subroutine print_usage() Arguments None Description Procedure for printing usage help message to stdout.","tags":"","loc":"proc/print_usage.html","title":"print_usage – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End PVTK_XML interface definitions for Lib_VTK_IO. Functions public function PVTK_INI_XML (filename, mesh_topology, tp, cf, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. character(len=*), intent(in) :: mesh_topology Mesh topology. character(len=*), intent(in) :: tp Type of geometry representation (Float32, Float64, ecc). integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing parallel (partitioned) VTK-XML file. public function PVTK_GEO_XML (source, cf, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source file name containing the piece data. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving piece geometry source for parallel (partitioned) VTK-XML file. public function PVTK_DAT_XML (var_location, var_block_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location Location of saving variables: CELL or NODE centered. character(len=*), intent(in) :: var_block_action Variables block action: OPEN or CLOSE block. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. public function PVTK_VAR_XML (varname, tp, cf, Nc) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: varname Variable name. character(len=*), intent(in) :: tp Type of data representation (Float32, Float64, ecc). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: Nc Number of components of variable. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving variable associated to nodes or cells geometry. public function PVTK_END_XML (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the parallel (partitioned) VTK-XML file.","tags":"","loc":"module/lib_vtk_io_pvtk_xml.html","title":"Lib_VTK_IO_PVTK_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End END_XML interface definition for Lib_VTK_IO. Functions public function VTK_END_XML (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTK-XML file.","tags":"","loc":"module/lib_vtk_io_end_xml.html","title":"Lib_VTK_IO_END_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_VTK_IO_Back_End GEO interface definition for Lib_VTK_IO. Interfaces public interface VTK_GEO Procedure for saving mesh with different topologies in VTK-legacy standard. private function VTK_GEO_UNST_R8 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P). private function VTK_GEO_UNST_P_R8 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P, packed API). private function VTK_GEO_UNST_R4 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P). private function VTK_GEO_UNST_P_R4 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P, packed API). private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X0 X coordinate of origin. real(kind=R8P), intent(in) :: Y0 Y coordinate of origin. real(kind=R8P), intent(in) :: Z0 Z coordinate of origin. real(kind=R8P), intent(in) :: Dx Space step in x direction. real(kind=R8P), intent(in) :: Dy Space step in y direction. real(kind=R8P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R8P). private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X0 X coordinate of origin. real(kind=R4P), intent(in) :: Y0 Y coordinate of origin. real(kind=R4P), intent(in) :: Z0 Z coordinate of origin. real(kind=R4P), intent(in) :: Dx Space step in x direction. real(kind=R4P), intent(in) :: Dy Space step in y direction. real(kind=R4P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R4P). private function VTK_GEO_STRG_1DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays). private function VTK_GEO_STRG_3DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays). private function VTK_GEO_STRG_1DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays, packed API). private function VTK_GEO_STRG_3DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays, packed API). private function VTK_GEO_STRG_1DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays). private function VTK_GEO_STRG_3DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays). private function VTK_GEO_STRG_1DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays, packed API). private function VTK_GEO_STRG_3DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays, packed API). private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X (1:Nx) X coordinates. real(kind=R8P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R8P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R8P). private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X (1:Nx) X coordinates. real(kind=R4P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R4P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R4P). Functions private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X0 X coordinate of origin. real(kind=R8P), intent(in) :: Y0 Y coordinate of origin. real(kind=R8P), intent(in) :: Z0 Z coordinate of origin. real(kind=R8P), intent(in) :: Dx Space step in x direction. real(kind=R8P), intent(in) :: Dy Space step in y direction. real(kind=R8P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R8P). private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X0 X coordinate of origin. real(kind=R4P), intent(in) :: Y0 Y coordinate of origin. real(kind=R4P), intent(in) :: Z0 Z coordinate of origin. real(kind=R4P), intent(in) :: Dx Space step in x direction. real(kind=R4P), intent(in) :: Dy Space step in y direction. real(kind=R4P), intent(in) :: Dz Space step in z direction. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_POINTS topology (R4P). private function VTK_GEO_STRG_1DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays). private function VTK_GEO_STRG_1DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 1D arrays, packed API). private function VTK_GEO_STRG_3DA_R8 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays). private function VTK_GEO_STRG_3DAP_R8 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R8P, 3D arrays, packed API). private function VTK_GEO_STRG_1DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays). private function VTK_GEO_STRG_1DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 1D arrays, packed API). private function VTK_GEO_STRG_3DA_R4 (Nx, Ny, Nz, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:,1:,1:) X coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Y (1:,1:,1:) Y coordinates [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: Z (1:,1:,1:) Z coordinates [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays). private function VTK_GEO_STRG_3DAP_R4 (Nx, Ny, Nz, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:,1:,1:) X, Y and Z coordinates [1:3,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with STRUCTURED_GRID topology (R4P, 3D arrays, packed API). private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R8P), intent(in) :: X (1:Nx) X coordinates. real(kind=R8P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R8P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R8P). private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx Number of nodes in x direction. integer(kind=I4P), intent(in) :: Ny Number of nodes in y direction. integer(kind=I4P), intent(in) :: Nz Number of nodes in z direction. real(kind=R4P), intent(in) :: X (1:Nx) X coordinates. real(kind=R4P), intent(in) :: Y (1:Ny) Y coordinates. real(kind=R4P), intent(in) :: Z (1:Nz) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with RECTILINEAR_GRID topology (R4P). private function VTK_GEO_UNST_R8 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P). private function VTK_GEO_UNST_P_R8 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R8P, packed API). private function VTK_GEO_UNST_R4 (NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates of all nodes [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates of all nodes [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P). private function VTK_GEO_UNST_P_R4 (NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN number of nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y and Z coordinates of all nodes [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with UNSTRUCTURED_GRID topology (R4P, packed API).","tags":"","loc":"module/lib_vtk_io_geo.html","title":"Lib_VTK_IO_GEO – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End INI_XML interface definition for Lib_VTK_IO. Functions public function VTK_INI_XML_WRITE (fformat, filename, mesh_topology, nx1, nx2, ny1, ny2, nz1, nz2, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat File format: ASCII, BINARY, RAW or BINARY-APPENDED. character(len=*), intent(in) :: filename File name. character(len=*), intent(in) :: mesh_topology Mesh topology. integer(kind=I4P), intent(in), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(in), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(in), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(in), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(in), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(in), optional :: nz2 Final node of z axis. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Procedure for initializing VTK-XML file (exporter). public function VTK_INI_XML_READ (fformat, filename, mesh_topology, npieces, nx1, nx2, ny1, ny2, nz1, nz2, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat File format: ASCII,  BINARY or RAW character(len=*), intent(in) :: filename File name character(len=*), intent(in) :: mesh_topology Mesh topology integer(kind=I4P), intent(out), optional :: npieces Number of pieces stored in the file integer(kind=I4P), intent(out), optional :: nx1 Initial node of x axis. integer(kind=I4P), intent(out), optional :: nx2 Final node of x axis. integer(kind=I4P), intent(out), optional :: ny1 Initial node of y axis. integer(kind=I4P), intent(out), optional :: ny2 Final node of y axis. integer(kind=I4P), intent(out), optional :: nz1 Initial node of z axis. integer(kind=I4P), intent(out), optional :: nz2 Final node of z axis. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Procedure for initializing VTK-XML file (importer).","tags":"","loc":"module/lib_vtk_io_ini_xml.html","title":"Lib_VTK_IO_INI_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End FLD_XML interface definition for Lib_VTK_IO. Interfaces public interface VTK_FLD_XML Procedure for saving field data (global auxiliary data, eg time, step number, dataset name, etc). private function VTK_FLD_XML_OC (fld_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fld_action Field data tag action: OPEN or CLOSE tag. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for open/close field data tag. private function VTK_FLD_XML_R8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R8P). private function VTK_FLD_XML_R4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R4P). private function VTK_FLD_XML_I8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I8P). private function VTK_FLD_XML_I4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I4P). private function VTK_FLD_XML_I2 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I2P). private function VTK_FLD_XML_I1 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I1P). Functions private function VTK_FLD_XML_OC (fld_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fld_action Field data tag action: OPEN or CLOSE tag. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for open/close field data tag. private function VTK_FLD_XML_R8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R8P). private function VTK_FLD_XML_R4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (R4P). private function VTK_FLD_XML_I8 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I8P). private function VTK_FLD_XML_I4 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I4P). private function VTK_FLD_XML_I2 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I2P). private function VTK_FLD_XML_I1 (fld, fname, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: fld Field data value. character(len=*), intent(in) :: fname Field data name. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field data (global auxiliary data, e.g. time, step number, data set name...) (I1P).","tags":"","loc":"module/lib_vtk_io_fld_xml.html","title":"Lib_VTK_IO_FLD_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End DAT_XML and VAR_XML interface definitions for Lib_VTK_IO. Interfaces public interface VTK_VAR_XML Procedure for saving data variable(s) in VTK-XML standard. private function VTK_VAR_XML_SCAL_1DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 3D array). private function VTK_VAR_XML_VECT_1DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R8P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R4P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I8P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I4P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I2P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I2P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I1P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I1P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 3D arrays). private function VTK_VAR_XML_LIST_1DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 1D array). private function VTK_VAR_XML_LIST_3DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 3D array). private function VTK_VAR_XML_LIST_1DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 1D array). private function VTK_VAR_XML_LIST_3DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 1D array). private function VTK_VAR_XML_LIST_3DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 3D array). private function VTK_VAR_XML_LIST_1DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 1D array). private function VTK_VAR_XML_LIST_3DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 1D array). private function VTK_VAR_XML_LIST_3DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 3D array). private function VTK_VAR_XML_LIST_1DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 1D array). private function VTK_VAR_XML_LIST_3DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 3D array). Functions public function VTK_DAT_XML (var_location, var_block_action, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location Location of saving variables: CELL or NODE centered. character(len=*), intent(in) :: var_block_action Variables block action: OPEN or CLOSE block. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. private function VTK_VAR_XML_SCAL_1DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I8P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I2 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I2P, 3D array). private function VTK_VAR_XML_SCAL_1DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:) Variable to be saved [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 1D array). private function VTK_VAR_XML_SCAL_3DA_I1 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:) Variable to be saved [1:Nx,1:ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I1P, 3D array). private function VTK_VAR_XML_VECT_1DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R8P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:) X component [1:NC_NN]. real(kind=R4P), intent(in) :: varY (1:) Y component [1:NC_NN]. real(kind=R4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_R4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. real(kind=R4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I8P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I8P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I8 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I8P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I8P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I4P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I4P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I2P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I2P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I2 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I2P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I2P, 3D arrays). private function VTK_VAR_XML_VECT_1DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:) X component [1:NC_NN]. integer(kind=I1P), intent(in) :: varY (1:) Y component [1:NC_NN]. integer(kind=I1P), intent(in) :: varZ (1:) Z component [1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 1D arrays). private function VTK_VAR_XML_VECT_3DA_I1 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: varX (1:,1:,1:) X component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varY (1:,1:,1:) Y component [1:Nx,1:Ny,1:Nz]. integer(kind=I1P), intent(in) :: varZ (1:,1:,1:) Z component [1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I1P, 3D arrays). private function VTK_VAR_XML_LIST_1DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 1D array). private function VTK_VAR_XML_LIST_3DA_R8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R8P, 3D array). private function VTK_VAR_XML_LIST_1DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 1D array). private function VTK_VAR_XML_LIST_3DA_R4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (R4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 1D array). private function VTK_VAR_XML_LIST_3DA_I8 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I8P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I8P, 3D array). private function VTK_VAR_XML_LIST_1DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 1D array). private function VTK_VAR_XML_LIST_3DA_I4 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I4P, 3D array). private function VTK_VAR_XML_LIST_1DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 1D array). private function VTK_VAR_XML_LIST_3DA_I2 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I2P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I2P, 3D array). private function VTK_VAR_XML_LIST_1DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:) Components [1:N_COL,1:NC_NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 1D array). private function VTK_VAR_XML_LIST_3DA_I1 (NC_NN, N_COL, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes. integer(kind=I4P), intent(in) :: N_COL Number of columns. character(len=*), intent(in) :: varname Variable name. integer(kind=I1P), intent(in) :: var (1:,1:,1:,1:) Components [1:N_COL,1:Nx,1:Ny,1:Nz]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of list variable (I1P, 3D array).","tags":"","loc":"module/lib_vtk_io_dat_var_xml.html","title":"Lib_VTK_IO_DAT_VAR_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision KISS library for packing heterogeneous data into single (homogeneous) packed one Interfaces public interface pack_data Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description @brief Subroutine for packing different kinds of data into single I1P array. Subroutines private puresubroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Procedure for packing different kinds of data into single I1P array. private puresubroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description @brief Subroutine for packing different kinds of data into single I1P array.","tags":"","loc":"module/lib_pack_data.html","title":"Lib_Pack_Data – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End Lib_VTK_IO_INI_XML Lib_VTK_IO_FLD_XML Lib_VTK_IO_GEO_XML Lib_VTK_IO_CON_XML Lib_VTK_IO_DAT_VAR_XML Lib_VTK_IO_END_XML Lib_VTK_IO_VTM_XML Lib_VTK_IO_PVTK_XML Lib_VTK_IO_PVD_XML Lib_VTK_IO_INI Lib_VTK_IO_GEO Lib_VTK_IO_CON Lib_VTK_IO_DAT_VAR Lib_VTK_IO_END Pure Fortran (2003+) library to write and read data conforming the VTK standard Lib_VTK_IO Lib_VTK_IO, VTK IO in pure Fortran (2003+) A KISS pure Fortran Library to IO data conforming the VTK standard Lib_VTK_IO is a pure Fortran library to write and read data conforming the VTK standard ; Lib_VTK_IO is Fortran 2003+ standard compliant; Lib_VTK_IO supports parallel architectures by means OpenMP and MPI paradigms; Lib_VTK_IO supports ascii , binary and base64 file formats; Lib_VTK_IO is a Free, Open Source Project. Table of Contents Main features Copyrights Documentation A Taste of Lib_VTK_IO Issues Compiler Support -brightgreen.svg) -brightgreen.svg) Main features VTK features Exporters Legacy standard Structured Points; Structured Grid; Unstructured Grid; Polydata; Rectilinear Grid; Field; XML standard serial dataset: Image Data; Polydata; Rectilinear Grid; Structured Grid; Unstructured Grid; parallel (partitioned) dataset: Image Data; Polydata; Rectilinear Grid; Structured Grid; Unstructured Grid; composite dataset: vtkMultiBlockDataSet. Importers The importers are under developing. Parallel Architectures Lib_VTK_IO can handle multiple concurrent files and it is \\b thread/processor-safe, meaning that it can be safely used into parallel architectures using OpenMP and/or MPI paradigms. Into section [[Parallel-benchmarks]] some more details can be found. Copyrights Lib_VTK_IO is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to Lib_VTK_IO is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the Lib_VTK_IO documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top A taste of Lib_VTK_IO Let us assume our aim being to save our pure Fortran data into a VTK structured grid file in binary XML form. This is simple as USE Lib_VTK_IO ... ! dataset dimensions integer , parameter :: nx1 = 0 , nx2 = 9 , ny1 = 0 , ny2 = 5 , nz1 = 0 , nz2 = 5 integer , parameter :: nn = ( nx2 - nx1 + 1 ) * ( ny2 - ny1 + 1 ) * ( nz2 - nz1 + 1 ) ! grid coordinates real , dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: x , y , z ! variables associated at grid nodes real , dimension ( nx1 : nx2 , ny1 : ny2 , nz1 : nz2 ) :: v_R ! auxiliary variables integer :: E_IO ... E_IO = VTK_INI_XML ( output_format = 'binary' , filename = 'XML_STRG.vts' , mesh_topology = 'StructuredGrid' , nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 ) E_IO = VTK_GEO_XML ( nx1 = nx1 , nx2 = nx2 , ny1 = ny1 , ny2 = ny2 , nz1 = nz1 , nz2 = nz2 , NN = nn , X = x , Y = y , Z = z ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'open' ) E_IO = VTK_VAR_XML ( NC_NN = nn , varname = 'real scalar' , var = v_R ) E_IO = VTK_DAT_XML ( var_location = 'node' , var_block_action = 'close' ) E_IO = VTK_GEO_XML () E_IO = VTK_END_XML () Note that all Lib_VTK_IO functions return an error code ( E_IO ) that can be used for sophisticated error trapping algorithms.","tags":"","loc":"module/lib_vtk_io.html","title":"Lib_VTK_IO – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End CON_XML interface definition for Lib_VTK_IO. Functions public function VTK_CON_XML (NC, connect, offset, cell_type, idx, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC Number of cells. integer(kind=I4P), intent(in) :: connect (1:) Mesh connectivity. integer(kind=I4P), intent(in) :: offset (1:NC) Cell offset. integer(kind=I1P), intent(in) :: cell_type (1:) VTK cell type. integer(kind=I1P), intent(in), optional :: idx Id offset to convert Fortran (first id 1) to C (first id 0) standards. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh connectivity.","tags":"","loc":"module/lib_vtk_io_con_xml.html","title":"Lib_VTK_IO_CON_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision iso_fortran_env Back-end module for Lib_VTK_IO. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: maxlen = 500 Max number of characters of static string. character(len=1), public, parameter :: end_rec = char(10) End-character for binary-record finalize. integer(kind=I4P), public, parameter :: ascii = 0 Ascii-output-format parameter identifier. integer(kind=I4P), public, parameter :: binary = 1 Base64-output-format parameter identifier. integer(kind=I4P), public, parameter :: raw = 2 Raw-appended-binary-output-format parameter identifier. integer(kind=I4P), public, parameter :: bin_app = 3 Base64-appended-output-format parameter identifier. type( Type_VTK_File ), public, allocatable :: vtk (:) Global data of VTK files [1:Nvtk]. integer(kind=I4P), public :: Nvtk = 0_I4P Number of (concurrent) VTK files. integer(kind=I4P), public :: f = 0_I4P Current VTK file index. type( Type_VTM_File ), public :: vtm Global data of VTM files. Derived Types type, private :: Type_VTK_File Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: f = ascii Current output-format (initialized to ascii format). character(len=maxlen), public :: topology = '' Mesh topology. integer(kind=I4P), public :: u = 0_I4P Logical unit. integer(kind=I4P), public :: ua = 0_I4P Logical unit for raw binary XML append file. integer(kind=I8P), public :: N_Byte = 0_I8P Number of byte to be written/read. integer(kind=I4P), public :: N_Byte = 0_I4P Number of byte to be written/read. integer(kind=I8P), public :: ioffset = 0_I8P Offset pointer. integer(kind=I4P), public :: indent = 0_I4P Indent pointer. Type-Bound Procedures procedure, public :: byte_update Procedure for updating N_Byte and ioffset pointer. Description Derived type for handling VTK files. type, private :: Type_VTM_File Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: u = 0_I4P Logical unit. integer(kind=I4P), public :: blk (1:2) = [0_I4P,0_I4P] Block indexes. integer(kind=I4P), public :: indent = 0_I4P Indent pointer. Description Derived type for handling VTM files. Functions public function Get_Unit (Free_Unit) result(funit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: Free_Unit Free logic unit. Return Value integer Free logic unit. Description Procedure for obtaining a free logic unit for safely opening a file. public elementalfunction Upper_Case (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Function for converting lower case characters of a string to upper case ones. public elementalfunction adjustlt (string) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len(string)) Output string with leading tab characters or blanks removed. Description Extend adjustl to remove tab characters (char(9)). public function read_record (from, cf, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: from Offset. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). character(len=:), intent(out), allocatable :: buffer String containing the next record. Return Value integer(kind=i4P) Error trapping flag. Description The read action stops when finding a EOR character (char(10)) public function move (to_find, repeat, cf, upper, inside, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: to_find Searched XML element. integer, intent(in), optional :: repeat Number of repetitions. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). logical, intent(in), optional :: upper True if return buffer in upper case. character(len=*), intent(in) :: inside XML element where to search 'to_find'. character(len=:), intent(out), allocatable :: buffer String. Return Value integer(kind=I4P) Error trapping flag. Description Advance in VTK file inside the mark 'inside', until find the mark 'to_find', 'repeat' times. public function search (cf, from, content, inside, to_find, with_attribute, of_value, buffer) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(in), optional :: from Offset. Start point. character(len=:), intent(out), optional allocatable :: content String with the content inside 'to_find' element. character(len=*), intent(in) :: inside XML element where to search 'to_find'. character(len=*), intent(in) :: to_find Searched XML element. character(len=*), intent(in) :: with_attribute XML attribute id. character(len=*), intent(in) :: of_value Attribute value. character(len=:), intent(inout), allocatable :: buffer String. Return Value integer(kind=I4P) Error trapping flag. Description Search in VTK file from position 'pos' inside the mark 'inside', until find the mark 'to_find', eventually, having\n attribute 'with_attribute' matching the value 'of_value'. Subroutines public elementalsubroutine byte_update (vtk, N_Byte) Arguments Type Intent Optional Attributes Name class( Type_VTK_File ), intent(inout) :: vtk Global data of VTK file. integer(kind=I8P), intent(in) :: N_Byte Number of bytes saved. Description Subroutine for updating N_Byte and ioffset pointer. public puresubroutine vtk_update (act, cf, Nvtk, vtk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: act Action: 'ADD' one more element, 'REMOVE' current element file. integer(kind=I4P), intent(inout) :: cf Current file index (for concurrent files IO). integer(kind=I4P), intent(inout) :: Nvtk Number of (concurrent) VTK files. type( Type_VTK_File ), intent(inout), allocatable :: vtk (:) VTK files data. Description Subroutine for updating (adding and removing elements into) vtk array. public subroutine get_int (case, E_IO, buffer, attrib, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: case Attribute string case. integer(kind=I4P), intent(out), optional :: E_IO Error trapping flag. character(len=*), intent(in) :: buffer String where to search the attrib. character(len=*), intent(in) :: attrib XML attribute id. integer(kind=I4P), intent(out) :: val Returned integer value. Description Get integer value of attribute 'attrib' defined into buffer. public subroutine get_char (case, E_IO, buffer, attrib, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: case Attribute string case. integer(kind=I4P), intent(out), optional :: E_IO Error trapping flag. character(len=*), intent(in) :: buffer String where to search the attrib character(len=*), intent(in) :: attrib XML attribute id character(len=:), intent(out), allocatable :: val Returned string value Description Get character value of attribute 'attrib' defined into buffer.","tags":"","loc":"module/lib_vtk_io_back_end.html","title":"Lib_VTK_IO_Back_End – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End INI interface definition for Lib_VTK_IO. Functions public function VTK_INI (fformat, filename, title, mesh_topology, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fformat Output format: ASCII or RAW. character(len=*), intent(in) :: filename Name of file. character(len=*), intent(in) :: title Title. character(len=*), intent(in) :: mesh_topology Mesh topology. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing VTK-legacy file.","tags":"","loc":"module/lib_vtk_io_ini.html","title":"Lib_VTK_IO_INI – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End PVD_XML interface definitions for Lib_VTK_IO. Interfaces public interface PVD_DAT_XML Procedure for saving data variable(s) in VTK-XML standard. private function PVD_DAT_XML_R8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_R4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I2 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I2P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I1 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I1P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files Functions public function PVD_INI_XML (filename, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. integer(kind=I4P), intent(out), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing a PVD-XML file. private function PVD_DAT_XML_R8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_R4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. real(kind=R4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I8 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I8P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I4 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I4P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I2 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I2P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files private function PVD_DAT_XML_I1 (filename, timestep, part, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Location of saving variables: CELL or NODE centered. integer(kind=I1P), intent(in) :: timestep Timestep index integer(kind=I4P), intent(in), optional :: part Part index integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving of PVD data associated to the sequence of VTK files public function PVD_END_XML (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the PVD-XML file.","tags":"","loc":"module/lib_vtk_io_pvd_xml.html","title":"Lib_VTK_IO_PVD_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End GEO_XML interface definition for Lib_VTK_IO. Interfaces public interface VTK_GEO_XML_WRITE Export (write) mesh with different topologies in VTK-XML standard. private function VTK_GEO_XML_STRG_1DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays, packed API). private function VTK_GEO_XML_STRG_1DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API) [1:3,nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays, packed API). private function VTK_GEO_XML_RECT_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R8P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R8P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R8P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R4P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R4P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R4P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R4P). private function VTK_GEO_XML_UNST_R8_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: X (1:NN) X coordinates. real(kind=R8P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R8P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R4_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P, packed API). private function VTK_GEO_XML_UNST_R4_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: X (1:NN) X coordinates. real(kind=R4P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R4P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P). private function VTK_GEO_XML_UNST_PACK_R8_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P, packed API). private function VTK_GEO_XML_CLOSEP_WRITE (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for closing mesh block data. public interface VTK_GEO_XML_READ Import (read) mesh with different topologies in VTK-XML standard. private function VTK_GEO_XML_STRG_1DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R8_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R4_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R4_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R8_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). Functions private function VTK_GEO_XML_STRG_1DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R8P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R8P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R8P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R8P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R8P, 3D Arrays, packed API). private function VTK_GEO_XML_STRG_1DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (1:) X coordinates [1:NN]. real(kind=R4P), intent(in) :: Y (1:) Y coordinates [1:NN]. real(kind=R4P), intent(in) :: Z (1:) Z coordinates [1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays). private function VTK_GEO_XML_STRG_3DA_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: X (nx1:,ny1:,nz1:) X coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Y (nx1:,ny1:,nz1:) Y coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. real(kind=R4P), intent(in) :: Z (nx1:,ny1:,nz1:) Z coordinates [nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays). private function VTK_GEO_XML_STRG_1DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,1:) X, Y, Z coordinates (packed API) [1:3,1:NN]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 1D Arrays, packed API). private function VTK_GEO_XML_STRG_3DAP_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. integer(kind=I4P), intent(in) :: NN Number of all nodes. real(kind=R4P), intent(in) :: XYZ (1:,nx1:,ny1:,nz1:) X, Y, Z coordinates (packed API) [1:3,nx1:nx2,ny1:ny2,nz1:nz2]. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Error trapping flag. Description Function for saving mesh with \\b StructuredGrid topology (R4P, 3D Arrays, packed API). private function VTK_GEO_XML_RECT_R8_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R8P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R8P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R8P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_WRITE (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 Initial node of x axis. integer(kind=I4P), intent(in) :: nx2 Final node of x axis. integer(kind=I4P), intent(in) :: ny1 Initial node of y axis. integer(kind=I4P), intent(in) :: ny2 Final node of y axis. integer(kind=I4P), intent(in) :: nz1 Initial node of z axis. integer(kind=I4P), intent(in) :: nz2 Final node of z axis. real(kind=R4P), intent(in) :: X (nx1:nx2) X coordinates. real(kind=R4P), intent(in) :: Y (ny1:ny2) Y coordinates. real(kind=R4P), intent(in) :: Z (nz1:nz2) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b RectilinearGrid topology (R4P). private function VTK_GEO_XML_UNST_R8_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: X (1:NN) X coordinates. real(kind=R8P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R8P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R8_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R8P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R8P, packed API). private function VTK_GEO_XML_UNST_R4_WRITE (NN, NC, X, Y, Z, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: X (1:NN) X coordinates. real(kind=R4P), intent(in) :: Y (1:NN) Y coordinates. real(kind=R4P), intent(in) :: Z (1:NN) Z coordinates. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P). private function VTK_GEO_XML_UNST_PACK_R4_WRITE (NN, NC, XYZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN Number of nodes. integer(kind=I4P), intent(in) :: NC Number of cells. real(kind=R4P), intent(in) :: XYZ (1:3,1:NN) X, Y, Z coordinates (packed API). integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh with \\b UnstructuredGrid topology (R4P, packed API). private function VTK_GEO_XML_CLOSEP_WRITE (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for closing mesh block data. private function VTK_GEO_XML_STRG_1DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R8P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DA_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: X (:,:,:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:,:,:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:,:,:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_1DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_STRG_3DAP_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, NN, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. integer(kind=I4P), intent(out) :: NN Number of nodes real(kind=R4P), intent(out), allocatable :: XYZ (:,:,:,:) x coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R8_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_RECT_R4_READ (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: nx1 Initial node of x axis. integer(kind=I4P), intent(out) :: nx2 Final node of x axis. integer(kind=I4P), intent(out) :: ny1 Initial node of y axis. integer(kind=I4P), intent(out) :: ny2 Final node of y axis. integer(kind=I4P), intent(out) :: nz1 Initial node of z axis. integer(kind=I4P), intent(out) :: nz2 Final node of z axis. real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R8_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: X (:) x coordinates real(kind=R8P), intent(out), allocatable :: Y (:) y coordinates real(kind=R8P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R8_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R8P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_R4_READ (NN, NC, X, Y, Z, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: X (:) x coordinates real(kind=R4P), intent(out), allocatable :: Y (:) y coordinates real(kind=R4P), intent(out), allocatable :: Z (:) z coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P). private function VTK_GEO_XML_UNST_PACK_R4_READ (NN, NC, XYZ, npiece, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(out) :: NN number of nodes integer(kind=I4P), intent(out) :: NC number of cells real(kind=R4P), intent(out), allocatable :: XYZ (:,:) Coordinates integer(kind=I4P), intent(in), optional :: npiece Number of the piece to read (by default: 1) integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done Description Function for reading mesh with \\b UnstructuredGrid topology (R8P).","tags":"","loc":"module/lib_vtk_io_geo_xml.html","title":"Lib_VTK_IO_GEO_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_VTK_IO_Back_End END interface definition for Lib_VTK_IO. Functions public function VTK_END (cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(inout), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTK-XML file.","tags":"","loc":"module/lib_vtk_io_end.html","title":"Lib_VTK_IO_END – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_VTK_IO_Back_End CON interface definition for Lib_VTK_IO. Functions public function VTK_CON (NC, connect, cell_type, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC Number of cells. integer(kind=I4P), intent(in) :: connect (:) Mesh connectivity. integer(kind=I4P), intent(in) :: cell_type (1:NC) VTK cell type. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving mesh connectivity.","tags":"","loc":"module/lib_vtk_io_con.html","title":"Lib_VTK_IO_CON – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_VTK_IO_Back_End DAT and VAR interface definitions for Lib_VTK_IO. Interfaces public interface VTK_VAR Procedure for saving data variable(s) in VTK-legacy standard. private function VTK_VAR_SCAL_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P). private function VTK_VAR_SCAL_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P). private function VTK_VAR_SCAL_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P). private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R8P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R8P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P). private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R4P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P). private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:NC_NN) X component of vector. integer(kind=I4P), intent(in) :: varY (1:NC_NN) Y component of vector. integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P). private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R8P). private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R4P). Functions public function VTK_DAT (NC_NN, var_location, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of cells or nodes of field. character(len=*), intent(in) :: var_location Location of saving variables: cell for cell-centered, node for node-centered. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing/finalizing the saving of data associated to the mesh. private function VTK_VAR_SCAL_R8 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R8P). private function VTK_VAR_SCAL_R4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (R4P). private function VTK_VAR_SCAL_I4 (NC_NN, varname, var, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: var (1:NC_NN) Variable to be saved. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of scalar variable (I4P). private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R8P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R8P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R8P). private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type Vector type: vect = generic vector , norm = normal vector. integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: varX (1:NC_NN) X component of vector. real(kind=R4P), intent(in) :: varY (1:NC_NN) Y component of vector. real(kind=R4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (R4P). private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. character(len=*), intent(in) :: varname Variable name. integer(kind=I4P), intent(in) :: varX (1:NC_NN) X component of vector. integer(kind=I4P), intent(in) :: varY (1:NC_NN) Y component of vector. integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Z component of vector. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving field of vectorial variable (I4P). private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R8P). private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo, cf) result(E_IO) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN Number of nodes or cells. integer(kind=I4P), intent(in) :: dimm Texture dimensions. character(len=*), intent(in) :: varname Variable name. real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Texture. integer(kind=I4P), intent(in), optional :: cf Current file index (for concurrent files IO). Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for saving texture variable (R4P).","tags":"","loc":"module/lib_vtk_io_dat_var.html","title":"Lib_VTK_IO_DAT_VAR – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Base64 Lib_VTK_IO_Back_End VTM_XML interface definitions for Lib_VTK_IO. Interfaces public interface VTM_WRF_XML Procedure for saving the list of VTK-XML wrapped files by a mutliblock VTM file. private function VTM_WRF_XML_array (nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: nlist (:) List names attributed to wrapped files. character(len=*), intent(in) :: flist (:) List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. private function VTM_WRF_XML_string (delimiter, nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: delimiter Delimiter of files into files list string. character(len=*), intent(in), optional :: nlist List names attributed to wrapped files. character(len=*), intent(in) :: flist List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. Functions public function VTM_INI_XML (filename) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name of output VTM file. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK-XML files. public function VTM_BLK_XML (block_action, name) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: block_action Block action: OPEN or CLOSE block. character(len=*), intent(in), optional :: name Block name. Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for opening or closing a block level of a VTM file. private function VTM_WRF_XML_array (nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: nlist (:) List names attributed to wrapped files. character(len=*), intent(in) :: flist (:) List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. private function VTM_WRF_XML_string (delimiter, nlist, flist) result(E_IO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: delimiter Delimiter of files into files list string. character(len=*), intent(in), optional :: nlist List names attributed to wrapped files. character(len=*), intent(in) :: flist List of VTK-XML wrapped files. Return Value integer(kind=I4P) Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done. Description Function for saving the list of VTK-XML wrapped files by the actual block of the mutliblock VTM file. public function VTM_END_XML () result(E_IO) Arguments None Return Value integer(kind=I4P) Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done. Description Function for finalizing the VTM-XML file.","tags":"","loc":"module/lib_vtk_io_vtm_xml.html","title":"Lib_VTK_IO_VTM_XML – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_VTK_IO iso_fortran_env Module library of procedures for testing Lib_VTK_IO and for providing practical examples. Subroutines public subroutine test_stress () Arguments None Description Procedure for testing all functions. public subroutine test_unst () Arguments None Description Procedure for testing UnstructuredGrid functions. public subroutine test_strg () Arguments None Description Procedure for testing StructuredGrid functions. public subroutine test_rect () Arguments None Description Procedure for testing RectilinearGrid functions. public subroutine test_punst () Arguments None Description Procedure for testing parallel (partitioned) PStructuredGrid functions. public subroutine test_pstrg () Arguments None Description Procedure for testing parallel (partitioned) PStructuredGrid functions. public subroutine test_vtm () Arguments None Description Procedure for testing multi-blocks VTM functions. public subroutine test_openmp (Nf_tot) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nf_tot Total number of files saved. Description Procedure for testing the libray in an OpenMP parallel framework. public subroutine test_mpi (Nf_tot) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nf_tot Total number of files saved. Description Procedure for testing the library in an MPI parallel framework.","tags":"","loc":"module/lib_testers.html","title":"Lib_Testers – Lib_VTK_IO"},{"text":"Uses: IR_Precision Lib_Testers iso_fortran_env Testing program for Lib_VTK_IO, a pure Fortran (2003+) library to write and read data conforming the VTK standard Usage For printing help message for usage run it without command line arguments ./Test_Driver Testing UnstructuredGrid functions ./Test_Driver -unst Testing StructuredGrid functions ./Test_Driver -strg Testing RectilinearGrid functions ./Test_Driver -rect Testing parallel (partitioned) PUnstructuredGrid functions ./Test_Driver -punst Testing parallel (partitioned) PStructuredGrid functions ./Test_Driver -pstrg Testing multi-blocks VTM functions ./Test_Driver -vtm Testing thread-safe capability into an OpenMP parallel framework ./Test_Driver -openmp Testing process-safe capability into a MPI parallel framework ./Test_Driver -mpi Variables Type Attributes Name Initial integer(kind=I4P) :: Nca = 0 Number of command line arguments. character(len=7) :: cas Command line argument switch. character(len=10) :: nF Number of files for MPI and OpenMP benchmarks. Subroutines subroutine print_usage () Arguments None Description Procedure for printing usage help message to stdout.","tags":"","loc":"program/test_driver.html","title":"Test_Driver – Lib_VTK_IO"}]}